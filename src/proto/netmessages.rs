// This file is generated. Do not edit

#![allow(dead_code)]
#![allow(non_camel_case_types)]

use descriptor::*;

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x11, 0x6e, 0x65, 0x74, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2d, 0x0a, 0x0a, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63,
    0x74, 0x6f, 0x72, 0x12, 0x09, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x12, 0x09,
    0x0a, 0x01, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x12, 0x09, 0x0a, 0x01, 0x7a, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x02, 0x22, 0x24, 0x0a, 0x0c, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74,
    0x6f, 0x72, 0x32, 0x44, 0x12, 0x09, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x12,
    0x09, 0x0a, 0x01, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x22, 0x2d, 0x0a, 0x0a, 0x43, 0x4d,
    0x73, 0x67, 0x51, 0x41, 0x6e, 0x67, 0x6c, 0x65, 0x12, 0x09, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x02, 0x12, 0x09, 0x0a, 0x01, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x12, 0x09,
    0x0a, 0x01, 0x7a, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x22, 0x52, 0x0a, 0x0a, 0x43, 0x4d, 0x73,
    0x67, 0x5f, 0x43, 0x56, 0x61, 0x72, 0x73, 0x12, 0x1f, 0x0a, 0x05, 0x63, 0x76, 0x61, 0x72, 0x73,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x56,
    0x61, 0x72, 0x73, 0x2e, 0x43, 0x56, 0x61, 0x72, 0x1a, 0x23, 0x0a, 0x04, 0x43, 0x56, 0x61, 0x72,
    0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0d,
    0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x0d, 0x0a,
    0x0b, 0x43, 0x4e, 0x45, 0x54, 0x4d, 0x73, 0x67, 0x5f, 0x4e, 0x4f, 0x50, 0x22, 0x22, 0x0a, 0x12,
    0x43, 0x4e, 0x45, 0x54, 0x4d, 0x73, 0x67, 0x5f, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
    0x63, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
    0x22, 0x61, 0x0a, 0x0c, 0x43, 0x4e, 0x45, 0x54, 0x4d, 0x73, 0x67, 0x5f, 0x46, 0x69, 0x6c, 0x65,
    0x12, 0x13, 0x0a, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1b, 0x0a, 0x13, 0x69, 0x73, 0x5f, 0x72,
    0x65, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x64, 0x65, 0x6d, 0x6f, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x65, 0x6e, 0x79, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x08, 0x22, 0x27, 0x0a, 0x17, 0x43, 0x4e, 0x45, 0x54, 0x4d, 0x73, 0x67, 0x5f, 0x53,
    0x70, 0x6c, 0x69, 0x74, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0c,
    0x0a, 0x04, 0x73, 0x6c, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22, 0x5a, 0x0a, 0x0c,
    0x43, 0x4e, 0x45, 0x54, 0x4d, 0x73, 0x67, 0x5f, 0x54, 0x69, 0x63, 0x6b, 0x12, 0x0c, 0x0a, 0x04,
    0x74, 0x69, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x68, 0x6f,
    0x73, 0x74, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x24, 0x0a, 0x1c, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x74, 0x69, 0x6d, 0x65, 0x5f, 0x73, 0x74, 0x64, 0x5f, 0x64, 0x65, 0x76, 0x69, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x24, 0x0a, 0x11, 0x43, 0x4e, 0x45, 0x54,
    0x4d, 0x73, 0x67, 0x5f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x43, 0x6d, 0x64, 0x12, 0x0f, 0x0a,
    0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x22, 0x31,
    0x0a, 0x11, 0x43, 0x4e, 0x45, 0x54, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e,
    0x56, 0x61, 0x72, 0x12, 0x1c, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x56, 0x61, 0x72,
    0x73, 0x22, 0x8a, 0x01, 0x0a, 0x13, 0x43, 0x4e, 0x45, 0x54, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x69,
    0x67, 0x6e, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x69, 0x67,
    0x6e, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x13, 0x0a, 0x0b, 0x73, 0x70, 0x61, 0x77, 0x6e, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x1a, 0x0a, 0x12, 0x6e, 0x75, 0x6d, 0x5f, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x1a, 0x0a, 0x12, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5f, 0x6e, 0x65, 0x74, 0x77,
    0x6f, 0x72, 0x6b, 0x69, 0x64, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08,
    0x6d, 0x61, 0x70, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x22, 0xa6,
    0x01, 0x0a, 0x12, 0x43, 0x43, 0x4c, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x61,
    0x62, 0x6c, 0x65, 0x5f, 0x63, 0x72, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07, 0x12, 0x14, 0x0a,
    0x0c, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x69, 0x73, 0x5f, 0x68, 0x6c, 0x74, 0x76, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x11, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x61,
    0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x12, 0x12, 0x0a, 0x0a, 0x66, 0x72, 0x69, 0x65, 0x6e,
    0x64, 0x73, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x66,
    0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65,
    0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x07, 0x22, 0x53, 0x0a, 0x0c, 0x43, 0x43, 0x4c, 0x43, 0x4d,
    0x73, 0x67, 0x5f, 0x4d, 0x6f, 0x76, 0x65, 0x12, 0x1b, 0x0a, 0x13, 0x6e, 0x75, 0x6d, 0x5f, 0x62,
    0x61, 0x63, 0x6b, 0x75, 0x70, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10, 0x6e, 0x75, 0x6d, 0x5f, 0x6e, 0x65, 0x77, 0x5f,
    0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c,
    0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x2f, 0x0a, 0x11,
    0x43, 0x43, 0x4c, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x44, 0x61, 0x74,
    0x61, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x12,
    0x0c, 0x0a, 0x04, 0x78, 0x75, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x22, 0x41, 0x0a,
    0x13, 0x43, 0x43, 0x4c, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x42, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e,
    0x65, 0x41, 0x63, 0x6b, 0x12, 0x15, 0x0a, 0x0d, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65,
    0x5f, 0x74, 0x69, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x62,
    0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6e, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
    0x22, 0x2a, 0x0a, 0x14, 0x43, 0x43, 0x4c, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x4c, 0x69, 0x73, 0x74,
    0x65, 0x6e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x12, 0x0a, 0x0a, 0x65, 0x76, 0x65, 0x6e,
    0x74, 0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x18, 0x01, 0x20, 0x03, 0x28, 0x07, 0x22, 0x5c, 0x0a, 0x18,
    0x43, 0x43, 0x4c, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x43,
    0x76, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6f, 0x6f, 0x6b,
    0x69, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x73, 0x74, 0x61, 0x74,
    0x75, 0x73, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a,
    0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x22, 0x6d, 0x0a, 0x14, 0x43, 0x43,
    0x4c, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x52, 0x43, 0x43, 0x68, 0x65,
    0x63, 0x6b, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x66, 0x69, 0x6c, 0x65,
    0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x69,
    0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0b, 0x0a, 0x03,
    0x63, 0x72, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x22, 0x2b, 0x0a, 0x17, 0x43, 0x43, 0x4c,
    0x43, 0x4d, 0x73, 0x67, 0x5f, 0x4c, 0x6f, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x67,
    0x72, 0x65, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22, 0x3a, 0x0a, 0x1a, 0x43, 0x43, 0x4c, 0x43, 0x4d, 0x73,
    0x67, 0x5f, 0x53, 0x70, 0x6c, 0x69, 0x74, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x43, 0x6f, 0x6e,
    0x6e, 0x65, 0x63, 0x74, 0x12, 0x1c, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x76, 0x61, 0x72, 0x73, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x56, 0x61,
    0x72, 0x73, 0x22, 0x37, 0x0a, 0x15, 0x43, 0x43, 0x4c, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x6d,
    0x73, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a,
    0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x22, 0xe2, 0x02, 0x0a, 0x12,
    0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x49, 0x6e,
    0x66, 0x6f, 0x12, 0x10, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x63,
    0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c, 0x69, 0x73,
    0x5f, 0x64, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08,
    0x12, 0x0f, 0x0a, 0x07, 0x69, 0x73, 0x5f, 0x68, 0x6c, 0x74, 0x76, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x08, 0x12, 0x11, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x0c, 0x0a, 0x04, 0x63, 0x5f, 0x6f, 0x73, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x6d, 0x61, 0x70, 0x5f, 0x63, 0x72, 0x63, 0x18, 0x07, 0x20,
    0x01, 0x28, 0x07, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x72,
    0x63, 0x18, 0x08, 0x20, 0x01, 0x28, 0x07, 0x12, 0x18, 0x0a, 0x10, 0x73, 0x74, 0x72, 0x69, 0x6e,
    0x67, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x63, 0x72, 0x63, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x07, 0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73,
    0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x5f, 0x63, 0x6c,
    0x61, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x70,
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x73, 0x6c, 0x6f, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x15, 0x0a, 0x0d, 0x74, 0x69, 0x63, 0x6b, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
    0x6c, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x02, 0x12, 0x10, 0x0a, 0x08, 0x67, 0x61, 0x6d, 0x65, 0x5f,
    0x64, 0x69, 0x72, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x61, 0x70,
    0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x73,
    0x6b, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x10, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a,
    0x09, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x11, 0x20, 0x01, 0x28, 0x09,
    0x22, 0xa4, 0x01, 0x0a, 0x11, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6c, 0x61,
    0x73, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
    0x5f, 0x6f, 0x6e, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
    0x12, 0x2b, 0x0a, 0x07, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x1a, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6c, 0x61, 0x73,
    0x73, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x1a, 0x48, 0x0a,
    0x07, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x12, 0x10, 0x0a, 0x08, 0x63, 0x6c, 0x61, 0x73,
    0x73, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x17, 0x0a, 0x0f, 0x64, 0x61,
    0x74, 0x61, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x22, 0x22, 0x0a, 0x10, 0x43, 0x53, 0x56, 0x43, 0x4d,
    0x73, 0x67, 0x5f, 0x53, 0x65, 0x74, 0x50, 0x61, 0x75, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x70,
    0x61, 0x75, 0x73, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x22, 0x33, 0x0a, 0x11, 0x43,
    0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x69, 0x74,
    0x12, 0x0f, 0x0a, 0x07, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x0d, 0x0a, 0x05, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
    0x22, 0x1d, 0x0a, 0x0d, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x72, 0x69, 0x6e,
    0x74, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x22,
    0xb6, 0x03, 0x0a, 0x0e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x6f, 0x75, 0x6e,
    0x64, 0x73, 0x12, 0x16, 0x0a, 0x0e, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73,
    0x6f, 0x75, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x12, 0x2b, 0x0a, 0x06, 0x73, 0x6f,
    0x75, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x43, 0x53, 0x56,
    0x43, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x6f, 0x75, 0x6e, 0x64, 0x73, 0x2e, 0x73, 0x6f, 0x75, 0x6e,
    0x64, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x74, 0x1a, 0xde, 0x02, 0x0a, 0x0b, 0x73, 0x6f, 0x75, 0x6e,
    0x64, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x74, 0x12, 0x10, 0x0a, 0x08, 0x6f, 0x72, 0x69, 0x67, 0x69,
    0x6e, 0x5f, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x11, 0x12, 0x10, 0x0a, 0x08, 0x6f, 0x72, 0x69,
    0x67, 0x69, 0x6e, 0x5f, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x11, 0x12, 0x10, 0x0a, 0x08, 0x6f,
    0x72, 0x69, 0x67, 0x69, 0x6e, 0x5f, 0x7a, 0x18, 0x03, 0x20, 0x01, 0x28, 0x11, 0x12, 0x0e, 0x0a,
    0x06, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a,
    0x0b, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x05, 0x20, 0x01,
    0x28, 0x02, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x6e,
    0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c, 0x65,
    0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x07, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x08, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x0d, 0x0a, 0x05, 0x70, 0x69, 0x74, 0x63, 0x68, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x0d, 0x0a, 0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x11, 0x0a, 0x09, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x0b, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x6e, 0x75, 0x6d,
    0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x07, 0x12, 0x16, 0x0a,
    0x0e, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18,
    0x0d, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x72, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x5f,
    0x73, 0x65, 0x65, 0x64, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x73, 0x6f,
    0x75, 0x6e, 0x64, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x13, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x10,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x12, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x61, 0x6d, 0x62, 0x69, 0x65,
    0x6e, 0x74, 0x18, 0x11, 0x20, 0x01, 0x28, 0x08, 0x22, 0x27, 0x0a, 0x10, 0x43, 0x53, 0x56, 0x43,
    0x4d, 0x73, 0x67, 0x5f, 0x50, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x12, 0x13, 0x0a, 0x0b,
    0x73, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x05, 0x22, 0x27, 0x0a, 0x0f, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x65, 0x74,
    0x56, 0x69, 0x65, 0x77, 0x12, 0x14, 0x0a, 0x0c, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x69,
    0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22, 0x40, 0x0a, 0x10, 0x43, 0x53,
    0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x46, 0x69, 0x78, 0x41, 0x6e, 0x67, 0x6c, 0x65, 0x12, 0x10,
    0x0a, 0x08, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
    0x12, 0x1a, 0x0a, 0x05, 0x61, 0x6e, 0x67, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x51, 0x41, 0x6e, 0x67, 0x6c, 0x65, 0x22, 0x34, 0x0a, 0x16,
    0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x72, 0x6f, 0x73, 0x73, 0x68, 0x61, 0x69,
    0x72, 0x41, 0x6e, 0x67, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x05, 0x61, 0x6e, 0x67, 0x6c, 0x65, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x51, 0x41, 0x6e, 0x67,
    0x6c, 0x65, 0x22, 0x8a, 0x01, 0x0a, 0x10, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x42,
    0x53, 0x50, 0x44, 0x65, 0x63, 0x61, 0x6c, 0x12, 0x18, 0x0a, 0x03, 0x70, 0x6f, 0x73, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f,
    0x72, 0x12, 0x1b, 0x0a, 0x13, 0x64, 0x65, 0x63, 0x61, 0x6c, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x75,
    0x72, 0x65, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14,
    0x0a, 0x0c, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x69, 0x6e,
    0x64, 0x65, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c, 0x6c, 0x6f, 0x77,
    0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x22,
    0x61, 0x0a, 0x13, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x70, 0x6c, 0x69, 0x74,
    0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x12, 0x26, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x45, 0x53, 0x70, 0x6c, 0x69, 0x74, 0x53, 0x63, 0x72,
    0x65, 0x65, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0c,
    0x0a, 0x04, 0x73, 0x6c, 0x6f, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c,
    0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x05, 0x22, 0x39, 0x0a, 0x14, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x47, 0x65,
    0x74, 0x43, 0x76, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6f,
    0x6f, 0x6b, 0x69, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x76,
    0x61, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x3c, 0x0a,
    0x0c, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x4d, 0x65, 0x6e, 0x75, 0x12, 0x13, 0x0a,
    0x0b, 0x64, 0x69, 0x61, 0x6c, 0x6f, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x17, 0x0a, 0x0f, 0x6d, 0x65, 0x6e, 0x75, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x22, 0xb0, 0x02, 0x0a, 0x11,
    0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x65, 0x6e, 0x64, 0x54, 0x61, 0x62, 0x6c,
    0x65, 0x12, 0x0e, 0x0a, 0x06, 0x69, 0x73, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x08, 0x12, 0x16, 0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6e,
    0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x15, 0x0a, 0x0d, 0x6e, 0x65, 0x65,
    0x64, 0x73, 0x5f, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08,
    0x12, 0x2c, 0x0a, 0x05, 0x70, 0x72, 0x6f, 0x70, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x1d, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x65, 0x6e, 0x64, 0x54, 0x61,
    0x62, 0x6c, 0x65, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x70, 0x5f, 0x74, 0x1a, 0xad,
    0x01, 0x0a, 0x0a, 0x73, 0x65, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x70, 0x5f, 0x74, 0x12, 0x0c, 0x0a,
    0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x76,
    0x61, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0d, 0x0a,
    0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08,
    0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f,
    0x0a, 0x07, 0x64, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x14, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x5f, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18,
    0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x6c, 0x6f, 0x77, 0x5f, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x12, 0x12, 0x0a, 0x0a, 0x68, 0x69, 0x67, 0x68,
    0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x02, 0x12, 0x10, 0x0a, 0x08,
    0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x69, 0x74, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x22, 0xfc,
    0x01, 0x0a, 0x11, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45,
    0x76, 0x65, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x0a, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x65, 0x76, 0x65, 0x6e,
    0x74, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x26, 0x0a, 0x04, 0x6b, 0x65, 0x79,
    0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73,
    0x67, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x6b, 0x65, 0x79, 0x5f,
    0x74, 0x1a, 0x99, 0x01, 0x0a, 0x05, 0x6b, 0x65, 0x79, 0x5f, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x74,
    0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x76, 0x61, 0x6c,
    0x5f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a,
    0x09, 0x76, 0x61, 0x6c, 0x5f, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02,
    0x12, 0x10, 0x0a, 0x08, 0x76, 0x61, 0x6c, 0x5f, 0x6c, 0x6f, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x76, 0x61, 0x6c, 0x5f, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x76, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74,
    0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x76, 0x61, 0x6c, 0x5f, 0x62,
    0x6f, 0x6f, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x12, 0x12, 0x0a, 0x0a, 0x76, 0x61, 0x6c,
    0x5f, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x22, 0xd1, 0x01,
    0x0a, 0x15, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x76,
    0x65, 0x6e, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x38, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x70, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x43,
    0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74,
    0x4c, 0x69, 0x73, 0x74, 0x2e, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x5f,
    0x74, 0x1a, 0x23, 0x0a, 0x05, 0x6b, 0x65, 0x79, 0x5f, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x1a, 0x59, 0x0a, 0x0c, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x70, 0x74, 0x6f, 0x72, 0x5f, 0x74, 0x12, 0x0f, 0x0a, 0x07, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x2a, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x03, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x47, 0x61,
    0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x2e, 0x6b, 0x65, 0x79, 0x5f,
    0x74, 0x22, 0xac, 0x01, 0x0a, 0x16, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61,
    0x63, 0x6b, 0x65, 0x74, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x13, 0x0a, 0x0b,
    0x6d, 0x61, 0x78, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x17, 0x0a, 0x0f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x65, 0x6e, 0x74,
    0x72, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x69, 0x73,
    0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x17, 0x0a, 0x0f,
    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x08, 0x12, 0x10, 0x0a, 0x08, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e,
    0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x64, 0x65, 0x6c, 0x74, 0x61,
    0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x65,
    0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c,
    0x22, 0x52, 0x0a, 0x14, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x54, 0x65, 0x6d, 0x70,
    0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x10, 0x0a, 0x08, 0x72, 0x65, 0x6c, 0x69,
    0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x12, 0x13, 0x0a, 0x0b, 0x6e, 0x75,
    0x6d, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x13, 0x0a, 0x0b, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0c, 0x22, 0xca, 0x01, 0x0a, 0x19, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67,
    0x5f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62,
    0x6c, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6e, 0x75, 0x6d, 0x5f, 0x65, 0x6e, 0x74,
    0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1c, 0x0a, 0x14, 0x75, 0x73,
    0x65, 0x72, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x66, 0x69, 0x78, 0x65, 0x64, 0x5f, 0x73, 0x69,
    0x7a, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x12, 0x16, 0x0a, 0x0e, 0x75, 0x73, 0x65, 0x72,
    0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x1b, 0x0a, 0x13, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x69,
    0x7a, 0x65, 0x5f, 0x62, 0x69, 0x74, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0d, 0x0a,
    0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b,
    0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x08, 0x20, 0x01, 0x28,
    0x0c, 0x22, 0x5f, 0x0a, 0x19, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x55, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x10,
    0x0a, 0x08, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x1b, 0x0a, 0x13, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x5f,
    0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a,
    0x0b, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x0c, 0x22, 0x39, 0x0a, 0x13, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x55, 0x73,
    0x65, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x73, 0x67,
    0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x6d,
    0x73, 0x67, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x6e, 0x0a,
    0x11, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x44, 0x61,
    0x74, 0x61, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x78, 0x69, 0x6d, 0x69, 0x74, 0x79, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0c, 0x0a, 0x04, 0x78, 0x75, 0x69, 0x64, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c, 0x61, 0x75, 0x64, 0x69, 0x62, 0x6c, 0x65, 0x5f, 0x6d,
    0x61, 0x73, 0x6b, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x76, 0x6f, 0x69,
    0x63, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x85, 0x01,
    0x0a, 0x16, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x4c, 0x69, 0x73, 0x74, 0x5f, 0x47, 0x61,
    0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x2f, 0x0a, 0x06, 0x65, 0x76, 0x65, 0x6e,
    0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d,
    0x73, 0x67, 0x4c, 0x69, 0x73, 0x74, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74,
    0x73, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x1a, 0x3a, 0x0a, 0x07, 0x65, 0x76, 0x65,
    0x6e, 0x74, 0x5f, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x69, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x21, 0x0a, 0x05, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x12, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x47, 0x61, 0x6d, 0x65,
    0x45, 0x76, 0x65, 0x6e, 0x74, 0x22, 0x8f, 0x01, 0x0a, 0x18, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73,
    0x67, 0x4c, 0x69, 0x73, 0x74, 0x5f, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x73, 0x12, 0x35, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6d, 0x73, 0x67, 0x73, 0x18, 0x01,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x4c, 0x69,
    0x73, 0x74, 0x5f, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e,
    0x75, 0x73, 0x65, 0x72, 0x6d, 0x73, 0x67, 0x5f, 0x74, 0x1a, 0x3c, 0x0a, 0x09, 0x75, 0x73, 0x65,
    0x72, 0x6d, 0x73, 0x67, 0x5f, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x69, 0x63, 0x6b, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x21, 0x0a, 0x03, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x14, 0x2e, 0x43, 0x53, 0x56, 0x43, 0x4d, 0x73, 0x67, 0x5f, 0x55, 0x73, 0x65, 0x72,
    0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2a, 0x9f, 0x01, 0x0a, 0x0c, 0x4e, 0x45, 0x54, 0x5f,
    0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x5f,
    0x4e, 0x4f, 0x50, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x5f, 0x44, 0x69, 0x73,
    0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x6e, 0x65, 0x74,
    0x5f, 0x46, 0x69, 0x6c, 0x65, 0x10, 0x02, 0x12, 0x17, 0x0a, 0x13, 0x6e, 0x65, 0x74, 0x5f, 0x53,
    0x70, 0x6c, 0x69, 0x74, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x10, 0x03,
    0x12, 0x0c, 0x0a, 0x08, 0x6e, 0x65, 0x74, 0x5f, 0x54, 0x69, 0x63, 0x6b, 0x10, 0x04, 0x12, 0x11,
    0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x5f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x43, 0x6d, 0x64, 0x10,
    0x05, 0x12, 0x11, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x5f, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x56,
    0x61, 0x72, 0x10, 0x06, 0x12, 0x13, 0x0a, 0x0f, 0x6e, 0x65, 0x74, 0x5f, 0x53, 0x69, 0x67, 0x6e,
    0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x10, 0x07, 0x2a, 0xd2, 0x01, 0x0a, 0x0b, 0x53, 0x49,
    0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x49, 0x47,
    0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00, 0x12,
    0x19, 0x0a, 0x15, 0x53, 0x49, 0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x43,
    0x48, 0x41, 0x4c, 0x4c, 0x45, 0x4e, 0x47, 0x45, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x53, 0x49,
    0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43,
    0x54, 0x45, 0x44, 0x10, 0x02, 0x12, 0x13, 0x0a, 0x0f, 0x53, 0x49, 0x47, 0x4e, 0x4f, 0x4e, 0x53,
    0x54, 0x41, 0x54, 0x45, 0x5f, 0x4e, 0x45, 0x57, 0x10, 0x03, 0x12, 0x18, 0x0a, 0x14, 0x53, 0x49,
    0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x50, 0x52, 0x45, 0x53, 0x50, 0x41,
    0x57, 0x4e, 0x10, 0x04, 0x12, 0x15, 0x0a, 0x11, 0x53, 0x49, 0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54,
    0x41, 0x54, 0x45, 0x5f, 0x53, 0x50, 0x41, 0x57, 0x4e, 0x10, 0x05, 0x12, 0x14, 0x0a, 0x10, 0x53,
    0x49, 0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x46, 0x55, 0x4c, 0x4c, 0x10,
    0x06, 0x12, 0x1b, 0x0a, 0x17, 0x53, 0x49, 0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45,
    0x5f, 0x43, 0x48, 0x41, 0x4e, 0x47, 0x45, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x10, 0x07, 0x2a, 0xea,
    0x01, 0x0a, 0x0c, 0x43, 0x4c, 0x43, 0x5f, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x12,
    0x12, 0x0a, 0x0e, 0x63, 0x6c, 0x63, 0x5f, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66,
    0x6f, 0x10, 0x08, 0x12, 0x0c, 0x0a, 0x08, 0x63, 0x6c, 0x63, 0x5f, 0x4d, 0x6f, 0x76, 0x65, 0x10,
    0x09, 0x12, 0x11, 0x0a, 0x0d, 0x63, 0x6c, 0x63, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x44, 0x61,
    0x74, 0x61, 0x10, 0x0a, 0x12, 0x13, 0x0a, 0x0f, 0x63, 0x6c, 0x63, 0x5f, 0x42, 0x61, 0x73, 0x65,
    0x6c, 0x69, 0x6e, 0x65, 0x41, 0x63, 0x6b, 0x10, 0x0b, 0x12, 0x14, 0x0a, 0x10, 0x63, 0x6c, 0x63,
    0x5f, 0x4c, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x10, 0x0c, 0x12,
    0x18, 0x0a, 0x14, 0x63, 0x6c, 0x63, 0x5f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x43, 0x76,
    0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x10, 0x0d, 0x12, 0x14, 0x0a, 0x10, 0x63, 0x6c, 0x63,
    0x5f, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x52, 0x43, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x10, 0x0e, 0x12,
    0x17, 0x0a, 0x13, 0x63, 0x6c, 0x63, 0x5f, 0x4c, 0x6f, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x72,
    0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x10, 0x0f, 0x12, 0x1a, 0x0a, 0x16, 0x63, 0x6c, 0x63, 0x5f,
    0x53, 0x70, 0x6c, 0x69, 0x74, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
    0x63, 0x74, 0x10, 0x10, 0x12, 0x15, 0x0a, 0x11, 0x63, 0x6c, 0x63, 0x5f, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x10, 0x11, 0x2a, 0xf1, 0x03, 0x0a, 0x0c,
    0x53, 0x56, 0x43, 0x5f, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x12, 0x0a, 0x0e,
    0x73, 0x76, 0x63, 0x5f, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x10, 0x08,
    0x12, 0x11, 0x0a, 0x0d, 0x73, 0x76, 0x63, 0x5f, 0x53, 0x65, 0x6e, 0x64, 0x54, 0x61, 0x62, 0x6c,
    0x65, 0x10, 0x09, 0x12, 0x11, 0x0a, 0x0d, 0x73, 0x76, 0x63, 0x5f, 0x43, 0x6c, 0x61, 0x73, 0x73,
    0x49, 0x6e, 0x66, 0x6f, 0x10, 0x0a, 0x12, 0x10, 0x0a, 0x0c, 0x73, 0x76, 0x63, 0x5f, 0x53, 0x65,
    0x74, 0x50, 0x61, 0x75, 0x73, 0x65, 0x10, 0x0b, 0x12, 0x19, 0x0a, 0x15, 0x73, 0x76, 0x63, 0x5f,
    0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c,
    0x65, 0x10, 0x0c, 0x12, 0x19, 0x0a, 0x15, 0x73, 0x76, 0x63, 0x5f, 0x55, 0x70, 0x64, 0x61, 0x74,
    0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x10, 0x0d, 0x12, 0x11,
    0x0a, 0x0d, 0x73, 0x76, 0x63, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x69, 0x74, 0x10,
    0x0e, 0x12, 0x11, 0x0a, 0x0d, 0x73, 0x76, 0x63, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x44, 0x61,
    0x74, 0x61, 0x10, 0x0f, 0x12, 0x0d, 0x0a, 0x09, 0x73, 0x76, 0x63, 0x5f, 0x50, 0x72, 0x69, 0x6e,
    0x74, 0x10, 0x10, 0x12, 0x0e, 0x0a, 0x0a, 0x73, 0x76, 0x63, 0x5f, 0x53, 0x6f, 0x75, 0x6e, 0x64,
    0x73, 0x10, 0x11, 0x12, 0x0f, 0x0a, 0x0b, 0x73, 0x76, 0x63, 0x5f, 0x53, 0x65, 0x74, 0x56, 0x69,
    0x65, 0x77, 0x10, 0x12, 0x12, 0x10, 0x0a, 0x0c, 0x73, 0x76, 0x63, 0x5f, 0x46, 0x69, 0x78, 0x41,
    0x6e, 0x67, 0x6c, 0x65, 0x10, 0x13, 0x12, 0x16, 0x0a, 0x12, 0x73, 0x76, 0x63, 0x5f, 0x43, 0x72,
    0x6f, 0x73, 0x73, 0x68, 0x61, 0x69, 0x72, 0x41, 0x6e, 0x67, 0x6c, 0x65, 0x10, 0x14, 0x12, 0x10,
    0x0a, 0x0c, 0x73, 0x76, 0x63, 0x5f, 0x42, 0x53, 0x50, 0x44, 0x65, 0x63, 0x61, 0x6c, 0x10, 0x15,
    0x12, 0x13, 0x0a, 0x0f, 0x73, 0x76, 0x63, 0x5f, 0x53, 0x70, 0x6c, 0x69, 0x74, 0x53, 0x63, 0x72,
    0x65, 0x65, 0x6e, 0x10, 0x16, 0x12, 0x13, 0x0a, 0x0f, 0x73, 0x76, 0x63, 0x5f, 0x55, 0x73, 0x65,
    0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x10, 0x17, 0x12, 0x15, 0x0a, 0x11, 0x73, 0x76,
    0x63, 0x5f, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x10,
    0x18, 0x12, 0x11, 0x0a, 0x0d, 0x73, 0x76, 0x63, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65,
    0x6e, 0x74, 0x10, 0x19, 0x12, 0x16, 0x0a, 0x12, 0x73, 0x76, 0x63, 0x5f, 0x50, 0x61, 0x63, 0x6b,
    0x65, 0x74, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x10, 0x1a, 0x12, 0x14, 0x0a, 0x10,
    0x73, 0x76, 0x63, 0x5f, 0x54, 0x65, 0x6d, 0x70, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73,
    0x10, 0x1b, 0x12, 0x10, 0x0a, 0x0c, 0x73, 0x76, 0x63, 0x5f, 0x50, 0x72, 0x65, 0x66, 0x65, 0x74,
    0x63, 0x68, 0x10, 0x1c, 0x12, 0x0c, 0x0a, 0x08, 0x73, 0x76, 0x63, 0x5f, 0x4d, 0x65, 0x6e, 0x75,
    0x10, 0x1d, 0x12, 0x15, 0x0a, 0x11, 0x73, 0x76, 0x63, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x76,
    0x65, 0x6e, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x10, 0x1e, 0x12, 0x14, 0x0a, 0x10, 0x73, 0x76, 0x63,
    0x5f, 0x47, 0x65, 0x74, 0x43, 0x76, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x10, 0x1f, 0x2a,
    0x75, 0x0a, 0x17, 0x45, 0x53, 0x70, 0x6c, 0x69, 0x74, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x4d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x17, 0x4d, 0x53,
    0x47, 0x5f, 0x53, 0x50, 0x4c, 0x49, 0x54, 0x53, 0x43, 0x52, 0x45, 0x45, 0x4e, 0x5f, 0x41, 0x44,
    0x44, 0x55, 0x53, 0x45, 0x52, 0x10, 0x00, 0x12, 0x1e, 0x0a, 0x1a, 0x4d, 0x53, 0x47, 0x5f, 0x53,
    0x50, 0x4c, 0x49, 0x54, 0x53, 0x43, 0x52, 0x45, 0x45, 0x4e, 0x5f, 0x52, 0x45, 0x4d, 0x4f, 0x56,
    0x45, 0x55, 0x53, 0x45, 0x52, 0x10, 0x01, 0x12, 0x1d, 0x0a, 0x19, 0x4d, 0x53, 0x47, 0x5f, 0x53,
    0x50, 0x4c, 0x49, 0x54, 0x53, 0x43, 0x52, 0x45, 0x45, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
    0x42, 0x49, 0x54, 0x53, 0x10, 0x01, 0x42, 0x03, 0x80, 0x01, 0x00, 0x4a, 0xd4, 0xa4, 0x01, 0x0a,
    0x07, 0x12, 0x05, 0x2e, 0x00, 0xb5, 0x04, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x2e,
    0x00, 0x23, 0x0a, 0x41, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x2e, 0x00, 0x23, 0x1a,
    0x34, 0x20, 0x57, 0x65, 0x20, 0x64, 0x6f, 0x6e, 0x27, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c,
    0x69, 0x74, 0x79, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03,
    0x2e, 0x07, 0x1a, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x2e,
    0x07, 0x1a, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x2e,
    0x07, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x03, 0x2e, 0x1d, 0x22,
    0x0a, 0x09, 0x0a, 0x02, 0x03, 0x00, 0x12, 0x03, 0x47, 0x07, 0x29, 0x0a, 0x0a, 0x0a, 0x02, 0x04,
    0x00, 0x12, 0x04, 0x4d, 0x00, 0x52, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03,
    0x4d, 0x08, 0x12, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x4f, 0x08, 0x1d,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x4f, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x4f, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x4f, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x03, 0x4f, 0x1b, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x01,
    0x12, 0x03, 0x50, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x04, 0x12, 0x03,
    0x50, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x05, 0x12, 0x03, 0x50, 0x11,
    0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x50, 0x17, 0x18, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x50, 0x1b, 0x1c, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x51, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x02, 0x04, 0x12, 0x03, 0x51, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02,
    0x05, 0x12, 0x03, 0x51, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12,
    0x03, 0x51, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x03, 0x12, 0x03, 0x51,
    0x1b, 0x1c, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x54, 0x00, 0x58, 0x01, 0x0a, 0x0a,
    0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x54, 0x08, 0x14, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01,
    0x02, 0x00, 0x12, 0x03, 0x56, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04,
    0x12, 0x03, 0x56, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x05, 0x12, 0x03,
    0x56, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x56, 0x17,
    0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03, 0x56, 0x1b, 0x1c, 0x0a,
    0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x01, 0x12, 0x03, 0x57, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x01, 0x04, 0x12, 0x03, 0x57, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01,
    0x02, 0x01, 0x05, 0x12, 0x03, 0x57, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01,
    0x01, 0x12, 0x03, 0x57, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x03, 0x12,
    0x03, 0x57, 0x1b, 0x1c, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x5a, 0x00, 0x5f, 0x01,
    0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x5a, 0x08, 0x12, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x02, 0x02, 0x00, 0x12, 0x03, 0x5c, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x00, 0x04, 0x12, 0x03, 0x5c, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x05,
    0x12, 0x03, 0x5c, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x5c, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x03, 0x5c, 0x1b,
    0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x5d, 0x08, 0x1d, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x04, 0x12, 0x03, 0x5d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x01, 0x05, 0x12, 0x03, 0x5d, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x01, 0x01, 0x12, 0x03, 0x5d, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01,
    0x03, 0x12, 0x03, 0x5d, 0x1b, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x02, 0x12, 0x03,
    0x5e, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x04, 0x12, 0x03, 0x5e, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x05, 0x12, 0x03, 0x5e, 0x11, 0x16, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x01, 0x12, 0x03, 0x5e, 0x17, 0x18, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x02, 0x03, 0x12, 0x03, 0x5e, 0x1b, 0x1c, 0x0a, 0x0a, 0x0a, 0x02, 0x05,
    0x00, 0x12, 0x04, 0x65, 0x00, 0x6f, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01, 0x12, 0x03,
    0x65, 0x05, 0x11, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x67, 0x08, 0x14,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x67, 0x08, 0x0f, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x67, 0x12, 0x13, 0x0a, 0x36, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x01, 0x12, 0x03, 0x68, 0x08, 0x1b, 0x22, 0x29, 0x20, 0x64, 0x69, 0x73, 0x63,
    0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x2c, 0x20, 0x6c, 0x61, 0x73, 0x74, 0x20, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x68,
    0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x68, 0x19, 0x1a,
    0x0a, 0x36, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12, 0x03, 0x69, 0x08, 0x15, 0x22, 0x29, 0x20,
    0x66, 0x69, 0x6c, 0x65, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x2f, 0x64, 0x65, 0x6e, 0x79, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x03, 0x69, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x02, 0x12,
    0x03, 0x69, 0x13, 0x14, 0x0a, 0x56, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x03, 0x12, 0x03, 0x6a, 0x08,
    0x20, 0x22, 0x49, 0x20, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x20, 0x73, 0x70, 0x6c, 0x69,
    0x74, 0x20, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2c, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x6f, 0x74, 0x68, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69,
    0x64, 0x65, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x6a, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x03, 0x02, 0x12, 0x03, 0x6a, 0x1e, 0x1f, 0x0a, 0x34, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x04,
    0x12, 0x03, 0x6b, 0x08, 0x15, 0x22, 0x27, 0x20, 0x73, 0x2d, 0x3e, 0x63, 0x20, 0x77, 0x6f, 0x72,
    0x6c, 0x64, 0x20, 0x74, 0x69, 0x63, 0x6b, 0x2c, 0x20, 0x63, 0x2d, 0x3e, 0x73, 0x20, 0x61, 0x63,
    0x6b, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x74, 0x69, 0x63, 0x6b, 0x0d, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x6b, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x6b, 0x13, 0x14, 0x0a, 0x20, 0x0a, 0x04, 0x05, 0x00,
    0x02, 0x05, 0x12, 0x03, 0x6c, 0x08, 0x1a, 0x22, 0x13, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69,
    0x6e, 0x67, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x05, 0x01, 0x12, 0x03, 0x6c, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x05, 0x02, 0x12, 0x03, 0x6c, 0x18, 0x19, 0x0a, 0x3b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x06,
    0x12, 0x03, 0x6d, 0x08, 0x1a, 0x22, 0x2e, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x6f, 0x6e,
    0x65, 0x2f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x76, 0x61,
    0x72, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x69, 0x6e, 0x66, 0x6f, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69,
    0x6e, 0x67, 0x73, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03,
    0x6d, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x6d, 0x18,
    0x19, 0x0a, 0x34, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x07, 0x12, 0x03, 0x6e, 0x08, 0x1c, 0x22, 0x27,
    0x20, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x63, 0x6b, 0x73,
    0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x6f, 0x6e, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x65, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x07, 0x01,
    0x12, 0x03, 0x6e, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x07, 0x02, 0x12, 0x03,
    0x6e, 0x1a, 0x1b, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x01, 0x12, 0x04, 0x71, 0x00, 0x7b, 0x01, 0x0a,
    0x0a, 0x0a, 0x03, 0x05, 0x01, 0x01, 0x12, 0x03, 0x71, 0x05, 0x10, 0x0a, 0x2e, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x00, 0x12, 0x03, 0x73, 0x08, 0x2c, 0x22, 0x21, 0x20, 0x6e, 0x6f, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x65, 0x20, 0x79, 0x65, 0x74, 0x3b, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x74,
    0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x73, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x00, 0x02, 0x12, 0x03, 0x73, 0x2a, 0x2b, 0x0a, 0x3a, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x01, 0x12,
    0x03, 0x74, 0x08, 0x24, 0x22, 0x2d, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x63, 0x68,
    0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x3b, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x4f, 0x4f, 0x42, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
    0x73, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x74, 0x08,
    0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x02, 0x12, 0x03, 0x74, 0x22, 0x23, 0x0a,
    0x3d, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x02, 0x12, 0x03, 0x75, 0x08, 0x24, 0x22, 0x30, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x3b, 0x20, 0x6e, 0x65,
    0x74, 0x63, 0x68, 0x61, 0x6e, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x79, 0x0d, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x01, 0x02, 0x02, 0x01, 0x12, 0x03, 0x75, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x02, 0x02, 0x12, 0x03, 0x75, 0x22, 0x23, 0x0a, 0x35, 0x0a, 0x04, 0x05, 0x01,
    0x02, 0x03, 0x12, 0x03, 0x76, 0x08, 0x2c, 0x22, 0x28, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x67,
    0x6f, 0x74, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x69, 0x6e, 0x66, 0x6f, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x0d,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x01, 0x12, 0x03, 0x76, 0x08, 0x17, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x02, 0x12, 0x03, 0x76, 0x2a, 0x2b, 0x0a, 0x27, 0x0a,
    0x04, 0x05, 0x01, 0x02, 0x04, 0x12, 0x03, 0x77, 0x08, 0x24, 0x22, 0x1a, 0x20, 0x72, 0x65, 0x63,
    0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x6f, 0x6e, 0x20, 0x62, 0x75, 0x66,
    0x66, 0x65, 0x72, 0x73, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x04, 0x01, 0x12,
    0x03, 0x77, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x04, 0x02, 0x12, 0x03, 0x77,
    0x22, 0x23, 0x0a, 0x2f, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x05, 0x12, 0x03, 0x78, 0x08, 0x2c, 0x22,
    0x22, 0x20, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69,
    0x76, 0x65, 0x20, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
    0x73, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05, 0x01, 0x12, 0x03, 0x78, 0x08,
    0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05, 0x02, 0x12, 0x03, 0x78, 0x2a, 0x2b, 0x0a,
    0x47, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x06, 0x12, 0x03, 0x79, 0x08, 0x2c, 0x22, 0x3a, 0x20, 0x77,
    0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x20, 0x63, 0x6f, 0x6e, 0x6e,
    0x65, 0x63, 0x74, 0x65, 0x64, 0x3b, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x6e,
    0x2d, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x72, 0x65,
    0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06,
    0x01, 0x12, 0x03, 0x79, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06, 0x02, 0x12,
    0x03, 0x79, 0x2a, 0x2b, 0x0a, 0x35, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x07, 0x12, 0x03, 0x7a, 0x08,
    0x24, 0x22, 0x28, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x63, 0x68,
    0x61, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x3b, 0x20, 0x70, 0x6c,
    0x65, 0x61, 0x73, 0x65, 0x20, 0x77, 0x61, 0x69, 0x74, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x07, 0x01, 0x12, 0x03, 0x7a, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x07, 0x02, 0x12, 0x03, 0x7a, 0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x05, 0x7d,
    0x00, 0x86, 0x01, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x03, 0x7d, 0x08, 0x12,
    0x0a, 0x0d, 0x0a, 0x04, 0x04, 0x03, 0x03, 0x00, 0x12, 0x05, 0x7f, 0x08, 0x83, 0x01, 0x09, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x03, 0x00, 0x01, 0x12, 0x03, 0x7f, 0x10, 0x14, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x81, 0x01, 0x10, 0x29, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x81, 0x01, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x81, 0x01, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x81, 0x01, 0x20, 0x24,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x81, 0x01, 0x27,
    0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x82, 0x01, 0x10,
    0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x82, 0x01,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x82,
    0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x82, 0x01, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x82, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x04, 0x85,
    0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0x85, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x06, 0x12, 0x04, 0x85, 0x01, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x01, 0x16, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x01, 0x1e, 0x1f, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x06, 0x88, 0x01, 0x00, 0x8a, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x04, 0x01, 0x12, 0x04, 0x88, 0x01, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x05,
    0x12, 0x06, 0x8c, 0x01, 0x00, 0x8f, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12,
    0x04, 0x8c, 0x01, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x04, 0x8e,
    0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8e, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8e, 0x01, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x18, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8e, 0x01, 0x1f, 0x20, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x06, 0x12, 0x06, 0x91, 0x01, 0x00, 0x97, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x06, 0x01, 0x12, 0x04, 0x91, 0x01, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06,
    0x02, 0x00, 0x12, 0x04, 0x93, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x93, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x05,
    0x12, 0x04, 0x93, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x93, 0x01, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x93, 0x01, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x01, 0x12, 0x04, 0x94, 0x01,
    0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x04, 0x12, 0x04, 0x94, 0x01, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x05, 0x12, 0x04, 0x94, 0x01, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x01, 0x12, 0x04, 0x94, 0x01, 0x18, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x03, 0x12, 0x04, 0x94, 0x01, 0x24, 0x25, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x06, 0x02, 0x02, 0x12, 0x04, 0x95, 0x01, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x02, 0x04, 0x12, 0x04, 0x95, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x02, 0x05, 0x12, 0x04, 0x95, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x02, 0x01, 0x12, 0x04, 0x95, 0x01, 0x16, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x02, 0x03, 0x12, 0x04, 0x95, 0x01, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x03,
    0x12, 0x04, 0x96, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x04, 0x12,
    0x04, 0x96, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x05, 0x12, 0x04,
    0x96, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x01, 0x12, 0x04, 0x96,
    0x01, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x03, 0x12, 0x04, 0x96, 0x01,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x07, 0x12, 0x06, 0x99, 0x01, 0x00, 0x9c, 0x01, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x04, 0x99, 0x01, 0x08, 0x1f, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x04, 0x9b, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9b, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x9b, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x9b, 0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x9b, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0x9e,
    0x01, 0x00, 0xa3, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x04, 0x9e, 0x01,
    0x08, 0x14, 0x0a, 0x23, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x00, 0x12, 0x04, 0xa0, 0x01, 0x08, 0x21,
    0x22, 0x15, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x69, 0x63, 0x6b, 0x20,
    0x63, 0x6f, 0x75, 0x6e, 0x74, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xa0, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xa0, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xa0, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa0,
    0x01, 0x1f, 0x20, 0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x08,
    0x2b, 0x22, 0x2c, 0x20, 0x48, 0x6f, 0x73, 0x74, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x74,
    0x69, 0x6d, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x31, 0x2f, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x74,
    0x68, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x0d, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa1, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa1, 0x01, 0x29, 0x2a, 0x0a, 0x41, 0x0a, 0x04, 0x04,
    0x08, 0x02, 0x02, 0x12, 0x04, 0xa2, 0x01, 0x08, 0x39, 0x22, 0x33, 0x20, 0x48, 0x6f, 0x73, 0x74,
    0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x73, 0x74, 0x64, 0x64,
    0x65, 0x76, 0x20, 0x69, 0x6e, 0x20, 0x31, 0x2f, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x74, 0x68,
    0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x0d, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa2, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa2, 0x01, 0x18, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa2, 0x01, 0x37, 0x38, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x09,
    0x12, 0x06, 0xa5, 0x01, 0x00, 0xa8, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12,
    0x04, 0xa5, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x00, 0x12, 0x04, 0xa7,
    0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa7, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa7, 0x01, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa7, 0x01, 0x18, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa7, 0x01, 0x22, 0x23, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0xaa, 0x01, 0x00, 0xad, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0xaa, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a,
    0x02, 0x00, 0x12, 0x04, 0xac, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xac, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x06,
    0x12, 0x04, 0xac, 0x01, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xac, 0x01, 0x1c, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xac, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06, 0xaf, 0x01, 0x00, 0xb6,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12, 0x04, 0xaf, 0x01, 0x08, 0x1b, 0x0a,
    0x29, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x00, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x29, 0x22, 0x1b, 0x20,
    0x53, 0x65, 0x65, 0x20, 0x53, 0x49, 0x47, 0x4e, 0x4f, 0x4e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f,
    0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x73, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xb1, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xb1, 0x01, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xb1, 0x01, 0x27, 0x28, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12, 0x04,
    0xb2, 0x01, 0x08, 0x28, 0x22, 0x26, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x70,
    0x61, 0x77, 0x6e, 0x20, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x28, 0x73, 0x65, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x29, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb2, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xb2, 0x01, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xb2, 0x01, 0x26, 0x27, 0x0a, 0x52, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x02,
    0x12, 0x04, 0xb3, 0x01, 0x08, 0x35, 0x22, 0x44, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20,
    0x6f, 0x66, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x73, 0x20,
    0x61, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb3, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb3, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xb3, 0x01, 0x18, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xb3, 0x01, 0x33, 0x34, 0x0a, 0x23, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x03,
    0x12, 0x04, 0xb4, 0x01, 0x08, 0x2f, 0x22, 0x15, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x20,
    0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x69, 0x64, 0x73, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb4, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb4, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb4, 0x01, 0x18, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xb4, 0x01, 0x2d, 0x2e, 0x0a, 0x28, 0x0a, 0x04, 0x04, 0x0b, 0x02,
    0x04, 0x12, 0x04, 0xb5, 0x01, 0x08, 0x25, 0x22, 0x1a, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61,
    0x70, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb5, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb5, 0x01, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x18, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb5, 0x01, 0x23, 0x24, 0x0a,
    0x0c, 0x0a, 0x02, 0x05, 0x02, 0x12, 0x06, 0xbc, 0x01, 0x00, 0xc8, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x05, 0x02, 0x01, 0x12, 0x04, 0xbc, 0x01, 0x05, 0x11, 0x0a, 0x30, 0x0a, 0x04, 0x05, 0x02,
    0x02, 0x00, 0x12, 0x04, 0xbe, 0x01, 0x08, 0x34, 0x22, 0x22, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x20, 0x28, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x43, 0x52,
    0x43, 0x20, 0x65, 0x74, 0x63, 0x29, 0x20, 0x20, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbe, 0x01, 0x08, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x00, 0x02, 0x12, 0x04, 0xbe, 0x01, 0x32, 0x33, 0x0a, 0x20, 0x0a, 0x04, 0x05, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x3c, 0x22, 0x12, 0x20, 0x5b, 0x43, 0x55, 0x73, 0x65,
    0x72, 0x43, 0x6d, 0x64, 0x5d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x01, 0x02, 0x12, 0x04, 0xbf, 0x01, 0x3a, 0x3b, 0x0a, 0x33, 0x0a, 0x04, 0x05, 0x02,
    0x02, 0x02, 0x12, 0x04, 0xc0, 0x01, 0x08, 0x35, 0x22, 0x25, 0x20, 0x56, 0x6f, 0x69, 0x63, 0x65,
    0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x72, 0x6f, 0x6d,
    0x20, 0x61, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x20, 0x20, 0x20, 0x0d, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc0, 0x01, 0x08, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x02, 0x12, 0x04, 0xc0, 0x01, 0x32, 0x34, 0x0a, 0x3c, 0x0a,
    0x04, 0x05, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc1, 0x01, 0x08, 0x35, 0x22, 0x2e, 0x20, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65,
    0x20, 0x73, 0x65, 0x71, 0x6e, 0x72, 0x20, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x08, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x03, 0x02, 0x12, 0x04, 0xc1, 0x01, 0x32, 0x34, 0x0a, 0x3c, 0x0a, 0x04, 0x05, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xc2, 0x01, 0x08, 0x35, 0x22, 0x2e, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x73, 0x20, 0x61, 0x20,
    0x6e, 0x65, 0x77, 0x20, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x20, 0x73, 0x65, 0x71,
    0x6e, 0x72, 0x20, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x04, 0x01,
    0x12, 0x04, 0xc2, 0x01, 0x08, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x04, 0x02, 0x12,
    0x04, 0xc2, 0x01, 0x32, 0x34, 0x0a, 0x46, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc3,
    0x01, 0x08, 0x2d, 0x22, 0x38, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x73, 0x20,
    0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20,
    0x73, 0x76, 0x63, 0x5f, 0x47, 0x65, 0x74, 0x43, 0x76, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65,
    0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x05, 0x01, 0x12, 0x04, 0xc3, 0x01, 0x08, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x05, 0x02, 0x12, 0x04, 0xc3, 0x01, 0x2a, 0x2c, 0x0a, 0x50, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x06, 0x12, 0x04, 0xc4, 0x01, 0x08, 0x35, 0x22, 0x42, 0x20, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20,
    0x66, 0x69, 0x6c, 0x65, 0x27, 0x73, 0x20, 0x43, 0x52, 0x43, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x76,
    0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2e, 0x20, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x06, 0x01, 0x12, 0x04, 0xc4, 0x01, 0x08, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x06, 0x02, 0x12, 0x04, 0xc4, 0x01, 0x32, 0x34, 0x0a, 0x2a, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x07, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x2d, 0x22, 0x1c, 0x20, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72,
    0x65, 0x73, 0x73, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x07, 0x01,
    0x12, 0x04, 0xc5, 0x01, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x07, 0x02, 0x12,
    0x04, 0xc5, 0x01, 0x2a, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x08, 0x12, 0x04, 0xc6,
    0x01, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x08, 0x01, 0x12, 0x04, 0xc6, 0x01,
    0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x08, 0x02, 0x12, 0x04, 0xc6, 0x01, 0x2a,
    0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x09, 0x12, 0x04, 0xc7, 0x01, 0x08, 0x35, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x09, 0x01, 0x12, 0x04, 0xc7, 0x01, 0x08, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x09, 0x02, 0x12, 0x04, 0xc7, 0x01, 0x32, 0x34, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x0c, 0x12, 0x06, 0xca, 0x01, 0x00, 0xd3, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x0c, 0x01, 0x12, 0x04, 0xca, 0x01, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x00,
    0x12, 0x04, 0xcc, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xcc, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xcc, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcc,
    0x01, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcc, 0x01,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x01, 0x08, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcd, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcd, 0x01, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcd, 0x01, 0x18, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcd, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0c, 0x02, 0x02, 0x12, 0x04, 0xce, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xce, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xce, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xce, 0x01, 0x16, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xce, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x03, 0x12, 0x04,
    0xcf, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x04, 0x12, 0x04, 0xcf,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x05, 0x12, 0x04, 0xcf, 0x01,
    0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x01, 0x12, 0x04, 0xcf, 0x01, 0x16,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x03, 0x12, 0x04, 0xcf, 0x01, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x04, 0x12, 0x04, 0xd0, 0x01, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd0, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x04, 0x05, 0x12, 0x04, 0xd0, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd0, 0x01, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c,
    0x02, 0x05, 0x12, 0x04, 0xd1, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05,
    0x04, 0x12, 0x04, 0xd1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x05,
    0x12, 0x04, 0xd1, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x01, 0x12,
    0x04, 0xd1, 0x01, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x03, 0x12, 0x04,
    0xd1, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x06, 0x12, 0x04, 0xd2, 0x01,
    0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x04, 0x12, 0x04, 0xd2, 0x01, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x05, 0x12, 0x04, 0xd2, 0x01, 0x11, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd2, 0x01, 0x19, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x03, 0x12, 0x04, 0xd2, 0x01, 0x28, 0x29, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06, 0xd5, 0x01, 0x00, 0xda, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x0d, 0x01, 0x12, 0x04, 0xd5, 0x01, 0x08, 0x14, 0x0a, 0x46, 0x0a, 0x04, 0x04, 0x0d, 0x02,
    0x00, 0x12, 0x04, 0xd7, 0x01, 0x08, 0x30, 0x22, 0x38, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x63, 0x6f,
    0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x20, 0x3d, 0x20, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x63, 0x6d,
    0x64, 0x73, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x28, 0x29, 0x20, 0x2d, 0x20, 0x6e, 0x75, 0x6d, 0x5f,
    0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x0d,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd7, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd7, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd7, 0x01, 0x18, 0x2b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd7, 0x01, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xd8, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xd8, 0x01, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x02, 0x12,
    0x04, 0xd9, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xd9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd9,
    0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd9, 0x01,
    0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd9, 0x01, 0x1e,
    0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06, 0xdc, 0x01, 0x00, 0xe0, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x04, 0xdc, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0e, 0x02, 0x00, 0x12, 0x04, 0xde, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xde, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xde, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xde, 0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xde, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x01, 0x12, 0x04,
    0xdf, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdf,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xdf, 0x01,
    0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdf, 0x01, 0x19,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xdf, 0x01, 0x20, 0x21,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0f, 0x12, 0x06, 0xe2, 0x01, 0x00, 0xe6, 0x01, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0xe2, 0x01, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0f, 0x02, 0x00, 0x12, 0x04, 0xe4, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xe4, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xe4, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xe4, 0x01, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xe4, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x01, 0x12, 0x04, 0xe5,
    0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe5, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe5, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe5, 0x01, 0x17, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe5, 0x01, 0x25, 0x26, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x10, 0x12, 0x06, 0xe8, 0x01, 0x00, 0xeb, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x10, 0x01, 0x12, 0x04, 0xe8, 0x01, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10,
    0x02, 0x00, 0x12, 0x04, 0xea, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xea, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xea, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xea, 0x01, 0x19, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xea, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0xed, 0x01, 0x00, 0xf3,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xed, 0x01, 0x08, 0x20, 0x0a,
    0x22, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x00, 0x12, 0x04, 0xef, 0x01, 0x08, 0x22, 0x22, 0x14, 0x20,
    0x51, 0x75, 0x65, 0x72, 0x79, 0x43, 0x76, 0x61, 0x72, 0x43, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x5f,
    0x74, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x04, 0x12, 0x04, 0xef, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x05, 0x12, 0x04, 0xef, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x01, 0x12, 0x04, 0xef, 0x01, 0x17, 0x1d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x03, 0x12, 0x04, 0xef, 0x01, 0x20, 0x21, 0x0a,
    0x26, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x01, 0x08, 0x27, 0x22, 0x18, 0x20,
    0x45, 0x51, 0x75, 0x65, 0x72, 0x79, 0x43, 0x76, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x53,
    0x74, 0x61, 0x74, 0x75, 0x73, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xf0, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xf0, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xf0, 0x01, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf0,
    0x01, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x02, 0x12, 0x04, 0xf1, 0x01, 0x08,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf1, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf1, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf1, 0x01, 0x18, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf1, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x11, 0x02, 0x03, 0x12, 0x04, 0xf2, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xf2, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xf2, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x12, 0x12, 0x06, 0xf5,
    0x01, 0x00, 0xfc, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x12, 0x01, 0x12, 0x04, 0xf5, 0x01,
    0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x00, 0x12, 0x04, 0xf7, 0x01, 0x08, 0x25,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf7, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf7, 0x01, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf7, 0x01, 0x17, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf7, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x12, 0x02, 0x01, 0x12, 0x04, 0xf8, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xf8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xf8, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xf8, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xf8, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x02, 0x12, 0x04,
    0xf9, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf9,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf9, 0x01,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf9, 0x01, 0x17,
    0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf9, 0x01, 0x27, 0x28,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x03, 0x12, 0x04, 0xfa, 0x01, 0x08, 0x25, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x04, 0x12, 0x04, 0xfa, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x03, 0x05, 0x12, 0x04, 0xfa, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x03, 0x01, 0x12, 0x04, 0xfa, 0x01, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x03, 0x03, 0x12, 0x04, 0xfa, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12,
    0x02, 0x04, 0x12, 0x04, 0xfb, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xfb, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x05,
    0x12, 0x04, 0xfb, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xfb, 0x01, 0x19, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x03, 0x12, 0x04,
    0xfb, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x13, 0x12, 0x06, 0xfe, 0x01, 0x00, 0x81,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01, 0x12, 0x04, 0xfe, 0x01, 0x08, 0x1f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x13, 0x02, 0x00, 0x12, 0x04, 0x80, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x13, 0x02, 0x00, 0x04, 0x12, 0x04, 0x80, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x13, 0x02, 0x00, 0x05, 0x12, 0x04, 0x80, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x13, 0x02, 0x00, 0x01, 0x12, 0x04, 0x80, 0x02, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x80, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x14, 0x12,
    0x06, 0x83, 0x02, 0x00, 0x86, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04,
    0x83, 0x02, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x00, 0x12, 0x04, 0x85, 0x02,
    0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0x85, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x06, 0x12, 0x04, 0x85, 0x02, 0x11, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x02, 0x1c, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x02, 0x26, 0x27, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x15, 0x12, 0x06, 0x88, 0x02, 0x00, 0x8c, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x15, 0x01, 0x12, 0x04, 0x88, 0x02, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02,
    0x00, 0x12, 0x04, 0x8a, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x8a, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x05, 0x12,
    0x04, 0x8a, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x01, 0x12, 0x04,
    0x8a, 0x02, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8a,
    0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x01, 0x12, 0x04, 0x8b, 0x02, 0x08,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8b, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8b, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8b, 0x02, 0x17, 0x1b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8b, 0x02, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a,
    0x02, 0x05, 0x03, 0x12, 0x06, 0x92, 0x02, 0x00, 0xac, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05,
    0x03, 0x01, 0x12, 0x04, 0x92, 0x02, 0x05, 0x11, 0x0a, 0x3e, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x00,
    0x12, 0x04, 0x94, 0x02, 0x08, 0x2c, 0x22, 0x30, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x67, 0x61, 0x6d, 0x65, 0x3b, 0x20, 0x6d,
    0x61, 0x70, 0x20, 0x65, 0x74, 0x63, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x94, 0x02, 0x08, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x00, 0x02,
    0x12, 0x04, 0x94, 0x02, 0x2a, 0x2b, 0x0a, 0x3f, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x01, 0x12, 0x04,
    0x95, 0x02, 0x08, 0x2c, 0x22, 0x31, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x61, 0x20, 0x73,
    0x65, 0x6e, 0x64, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x67, 0x61, 0x6d, 0x65, 0x20,
    0x63, 0x6c, 0x61, 0x73, 0x73, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x95, 0x02, 0x08, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x02, 0x12,
    0x04, 0x95, 0x02, 0x2a, 0x2b, 0x0a, 0x4f, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x02, 0x12, 0x04, 0x96,
    0x02, 0x08, 0x2d, 0x22, 0x41, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74,
    0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x20, 0x28, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20,
    0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x43, 0x4c, 0x41, 0x53, 0x53, 0x49,
    0x4e, 0x46, 0x4f, 0x5f, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x29, 0x2e, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x96, 0x02, 0x08, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x02, 0x02, 0x12, 0x04,
    0x96, 0x02, 0x2a, 0x2c, 0x0a, 0x3a, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x03, 0x12, 0x04, 0x97, 0x02,
    0x08, 0x2d, 0x22, 0x2c, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x73, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x20, 0x69, 0x66, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x70, 0x61, 0x75, 0x73,
    0x65, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x75, 0x6e, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x0d, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x03, 0x01, 0x12, 0x04, 0x97, 0x02, 0x08, 0x14, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x03, 0x02, 0x12, 0x04, 0x97, 0x02, 0x2a, 0x2c, 0x0a, 0x2b,
    0x0a, 0x04, 0x05, 0x03, 0x02, 0x04, 0x12, 0x04, 0x98, 0x02, 0x08, 0x25, 0x22, 0x1d, 0x20, 0x69,
    0x6e, 0x69, 0x74, 0x73, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x03, 0x02, 0x04, 0x01, 0x12, 0x04, 0x98, 0x02, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03,
    0x02, 0x04, 0x02, 0x12, 0x04, 0x98, 0x02, 0x22, 0x24, 0x0a, 0x27, 0x0a, 0x04, 0x05, 0x03, 0x02,
    0x05, 0x12, 0x04, 0x99, 0x02, 0x08, 0x25, 0x22, 0x19, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65,
    0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x05, 0x01, 0x12, 0x04, 0x99, 0x02, 0x08,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x05, 0x02, 0x12, 0x04, 0x99, 0x02, 0x22, 0x24,
    0x0a, 0x32, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x06, 0x12, 0x04, 0x9a, 0x02, 0x08, 0x2d, 0x22, 0x24,
    0x20, 0x69, 0x6e, 0x69, 0x74, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x76, 0x6f, 0x69, 0x63,
    0x65, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x73, 0x20, 0x26, 0x20, 0x71, 0x75, 0x61, 0x6c, 0x69,
    0x74, 0x79, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x06, 0x01, 0x12, 0x04, 0x9a,
    0x02, 0x08, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x06, 0x02, 0x12, 0x04, 0x9a, 0x02,
    0x2a, 0x2c, 0x0a, 0x31, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x07, 0x12, 0x04, 0x9b, 0x02, 0x08, 0x2d,
    0x22, 0x23, 0x20, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x20, 0x64,
    0x61, 0x74, 0x61, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x07, 0x01, 0x12, 0x04,
    0x9b, 0x02, 0x08, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x07, 0x02, 0x12, 0x04, 0x9b,
    0x02, 0x2a, 0x2c, 0x0a, 0x26, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x08, 0x12, 0x04, 0x9c, 0x02, 0x08,
    0x35, 0x22, 0x18, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x74,
    0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x03, 0x02, 0x08, 0x01, 0x12, 0x04, 0x9c, 0x02, 0x08, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03,
    0x02, 0x08, 0x02, 0x12, 0x04, 0x9c, 0x02, 0x32, 0x34, 0x0a, 0x25, 0x0a, 0x04, 0x05, 0x03, 0x02,
    0x09, 0x12, 0x04, 0x9d, 0x02, 0x08, 0x35, 0x22, 0x17, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x73,
    0x20, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x0d, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x09, 0x01, 0x12, 0x04, 0x9d, 0x02, 0x08, 0x12, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x09, 0x02, 0x12, 0x04, 0x9d, 0x02, 0x32, 0x34, 0x0a, 0x2d,
    0x0a, 0x04, 0x05, 0x03, 0x02, 0x0a, 0x12, 0x04, 0x9e, 0x02, 0x08, 0x2d, 0x22, 0x1f, 0x20, 0x73,
    0x65, 0x74, 0x73, 0x20, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x20, 0x61, 0x73, 0x20, 0x70, 0x6f,
    0x69, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x76, 0x69, 0x65, 0x77, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x03, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x9e, 0x02, 0x08, 0x13, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x03, 0x02, 0x0a, 0x02, 0x12, 0x04, 0x9e, 0x02, 0x2a, 0x2c, 0x0a, 0x30, 0x0a, 0x04, 0x05,
    0x03, 0x02, 0x0b, 0x12, 0x04, 0x9f, 0x02, 0x08, 0x2d, 0x22, 0x22, 0x20, 0x73, 0x65, 0x74, 0x73,
    0x2f, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x73, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72,
    0x73, 0x20, 0x76, 0x69, 0x65, 0x77, 0x61, 0x6e, 0x67, 0x6c, 0x65, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x03, 0x02, 0x0b, 0x01, 0x12, 0x04, 0x9f, 0x02, 0x08, 0x14, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x03, 0x02, 0x0b, 0x02, 0x12, 0x04, 0x9f, 0x02, 0x2a, 0x2c, 0x0a, 0x45, 0x0a, 0x04, 0x05,
    0x03, 0x02, 0x0c, 0x12, 0x04, 0xa0, 0x02, 0x08, 0x2d, 0x22, 0x37, 0x20, 0x61, 0x64, 0x6a, 0x75,
    0x73, 0x74, 0x73, 0x20, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x68, 0x61, 0x69, 0x72, 0x20, 0x69, 0x6e,
    0x20, 0x61, 0x75, 0x74, 0x6f, 0x20, 0x61, 0x69, 0x6d, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x20, 0x74,
    0x6f, 0x20, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x72, 0x61, 0x67, 0x65, 0x74,
    0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xa0, 0x02, 0x08,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x0c, 0x02, 0x12, 0x04, 0xa0, 0x02, 0x2a, 0x2c,
    0x0a, 0x34, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x0d, 0x12, 0x04, 0xa1, 0x02, 0x08, 0x2d, 0x22, 0x26,
    0x20, 0x61, 0x64, 0x64, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x20, 0x64, 0x65,
    0x63, 0x61, 0x6c, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64,
    0x20, 0x42, 0x53, 0x50, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x0d, 0x01, 0x12,
    0x04, 0xa1, 0x02, 0x08, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x0d, 0x02, 0x12, 0x04,
    0xa1, 0x02, 0x2a, 0x2c, 0x0a, 0x2b, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x0e, 0x12, 0x04, 0xa2, 0x02,
    0x08, 0x2d, 0x22, 0x1d, 0x20, 0x73, 0x70, 0x6c, 0x69, 0x74, 0x20, 0x73, 0x63, 0x72, 0x65, 0x65,
    0x6e, 0x20, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x0d,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xa2, 0x02, 0x08, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x0e, 0x02, 0x12, 0x04, 0xa2, 0x02, 0x2a, 0x2c, 0x0a,
    0x29, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x0f, 0x12, 0x04, 0xa3, 0x02, 0x08, 0x2d, 0x22, 0x1b, 0x20,
    0x61, 0x20, 0x67, 0x61, 0x6d, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03,
    0x02, 0x0f, 0x01, 0x12, 0x04, 0xa3, 0x02, 0x08, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02,
    0x0f, 0x02, 0x12, 0x04, 0xa3, 0x02, 0x2a, 0x2c, 0x0a, 0x28, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x10,
    0x12, 0x04, 0xa4, 0x02, 0x08, 0x2d, 0x22, 0x1a, 0x20, 0x61, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79,
    0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x10, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x08,
    0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x10, 0x02, 0x12, 0x04, 0xa4, 0x02, 0x2a, 0x2c,
    0x0a, 0x28, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x11, 0x12, 0x04, 0xa5, 0x02, 0x08, 0x2d, 0x22, 0x1a,
    0x20, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x67, 0x61, 0x6d, 0x65, 0x20, 0x65, 0x76, 0x65,
    0x6e, 0x74, 0x20, 0x66, 0x69, 0x72, 0x65, 0x64, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03,
    0x02, 0x11, 0x01, 0x12, 0x04, 0xa5, 0x02, 0x08, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02,
    0x11, 0x02, 0x12, 0x04, 0xa5, 0x02, 0x2a, 0x2c, 0x0a, 0x2e, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x12,
    0x12, 0x04, 0xa6, 0x02, 0x08, 0x2d, 0x22, 0x20, 0x20, 0x6e, 0x6f, 0x6e, 0x2d, 0x64, 0x65, 0x6c,
    0x74, 0x61, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x65, 0x6e,
    0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x12,
    0x01, 0x12, 0x04, 0xa6, 0x02, 0x08, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x12, 0x02,
    0x12, 0x04, 0xa6, 0x02, 0x2a, 0x2c, 0x0a, 0x2a, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x13, 0x12, 0x04,
    0xa7, 0x02, 0x08, 0x2d, 0x22, 0x1c, 0x20, 0x6e, 0x6f, 0x6e, 0x2d, 0x72, 0x65, 0x6c, 0x69, 0x61,
    0x62, 0x6c, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
    0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x13, 0x01, 0x12, 0x04, 0xa7, 0x02, 0x08,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x13, 0x02, 0x12, 0x04, 0xa7, 0x02, 0x2a, 0x2c,
    0x0a, 0x2b, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x14, 0x12, 0x04, 0xa8, 0x02, 0x08, 0x2d, 0x22, 0x1d,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x69, 0x6e, 0x64, 0x69,
    0x63, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x77, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x03, 0x02, 0x14, 0x01, 0x12, 0x04, 0xa8, 0x02, 0x08, 0x14, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x03, 0x02, 0x14, 0x02, 0x12, 0x04, 0xa8, 0x02, 0x2a, 0x2c, 0x0a, 0x2d, 0x0a, 0x04, 0x05,
    0x03, 0x02, 0x15, 0x12, 0x04, 0xa9, 0x02, 0x08, 0x35, 0x22, 0x1f, 0x20, 0x64, 0x69, 0x73, 0x70,
    0x6c, 0x61, 0x79, 0x20, 0x61, 0x20, 0x6d, 0x65, 0x6e, 0x75, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20,
    0x61, 0x20, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03,
    0x02, 0x15, 0x01, 0x12, 0x04, 0xa9, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02,
    0x15, 0x02, 0x12, 0x04, 0xa9, 0x02, 0x32, 0x34, 0x0a, 0x36, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x16,
    0x12, 0x04, 0xaa, 0x02, 0x08, 0x2d, 0x22, 0x28, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66,
    0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x67, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x65, 0x76, 0x65,
    0x6e, 0x74, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x0d, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x16, 0x01, 0x12, 0x04, 0xaa, 0x02, 0x08, 0x19, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x16, 0x02, 0x12, 0x04, 0xaa, 0x02, 0x2a, 0x2c, 0x0a, 0x47,
    0x0a, 0x04, 0x05, 0x03, 0x02, 0x17, 0x12, 0x04, 0xab, 0x02, 0x08, 0x2d, 0x22, 0x39, 0x20, 0x53,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x6b,
    0x6e, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x6f, 0x66,
    0x20, 0x61, 0x20, 0x63, 0x76, 0x61, 0x72, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x17, 0x01,
    0x12, 0x04, 0xab, 0x02, 0x08, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x17, 0x02, 0x12,
    0x04, 0xab, 0x02, 0x2a, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x16, 0x12, 0x06, 0xae, 0x02, 0x00,
    0xc1, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xae, 0x02, 0x08, 0x1a,
    0x0a, 0x21, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x00, 0x12, 0x04, 0xb0, 0x02, 0x08, 0x24, 0x22, 0x13,
    0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb0, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb0, 0x02, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb0, 0x02, 0x17, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb0, 0x02, 0x22, 0x23, 0x0a,
    0x3a, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x01, 0x12, 0x04, 0xb1, 0x02, 0x08, 0x28, 0x22, 0x2c, 0x20,
    0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65,
    0x6c, 0x65, 0x76, 0x65, 0x6c, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x73, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xb1, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xb1, 0x02, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xb1, 0x02, 0x26, 0x27, 0x0a, 0x24, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x02, 0x12,
    0x04, 0xb2, 0x02, 0x08, 0x27, 0x22, 0x16, 0x20, 0x64, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65,
    0x64, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x3f, 0x09, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb2, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb2, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb2, 0x02, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xb2, 0x02, 0x25, 0x26, 0x0a, 0x1e, 0x0a, 0x04, 0x04, 0x16, 0x02,
    0x03, 0x12, 0x04, 0xb3, 0x02, 0x08, 0x22, 0x22, 0x10, 0x20, 0x48, 0x4c, 0x54, 0x56, 0x20, 0x73,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x3f, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x03, 0x04, 0x12, 0x04, 0xb3, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03,
    0x05, 0x12, 0x04, 0xb3, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xb3, 0x02, 0x16, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xb3, 0x02, 0x20, 0x21, 0x0a, 0x20, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x04, 0x12, 0x04, 0xb4,
    0x02, 0x08, 0x24, 0x22, 0x12, 0x20, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x73, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x20, 0x3f, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xb4, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x05, 0x12,
    0x04, 0xb4, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xb4, 0x02, 0x16, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb4,
    0x02, 0x22, 0x23, 0x0a, 0x25, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x05, 0x12, 0x04, 0xb5, 0x02, 0x08,
    0x20, 0x22, 0x17, 0x20, 0x4c, 0x20, 0x3d, 0x20, 0x6c, 0x69, 0x6e, 0x75, 0x78, 0x2c, 0x20, 0x57,
    0x20, 0x3d, 0x20, 0x57, 0x69, 0x6e, 0x33, 0x32, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xb5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x05, 0x05, 0x12, 0x04, 0xb5, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05,
    0x01, 0x12, 0x04, 0xb5, 0x02, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xb5, 0x02, 0x1e, 0x1f, 0x0a, 0x1f, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x06, 0x12, 0x04,
    0xb6, 0x02, 0x08, 0x25, 0x22, 0x11, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x6d, 0x61,
    0x70, 0x20, 0x43, 0x52, 0x43, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x04,
    0x12, 0x04, 0xb6, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x05, 0x12,
    0x04, 0xb6, 0x02, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x01, 0x12, 0x04,
    0xb6, 0x02, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x03, 0x12, 0x04, 0xb6,
    0x02, 0x23, 0x24, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x07, 0x12, 0x04, 0xb7, 0x02, 0x08,
    0x28, 0x22, 0x21, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x64, 0x6c, 0x6c, 0x20, 0x43,
    0x52, 0x43, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x69,
    0x6e, 0x67, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x04, 0x12, 0x04, 0xb7,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x05, 0x12, 0x04, 0xb7, 0x02,
    0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x01, 0x12, 0x04, 0xb7, 0x02, 0x19,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x03, 0x12, 0x04, 0xb7, 0x02, 0x26, 0x27,
    0x0a, 0x31, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x08, 0x12, 0x04, 0xb8, 0x02, 0x08, 0x2e, 0x22, 0x23,
    0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x43, 0x52,
    0x43, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x69, 0x6e,
    0x67, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x04, 0x12, 0x04, 0xb8, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x05, 0x12, 0x04, 0xb8, 0x02, 0x11,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x01, 0x12, 0x04, 0xb8, 0x02, 0x19, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x03, 0x12, 0x04, 0xb8, 0x02, 0x2c, 0x2d, 0x0a,
    0x30, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x09, 0x12, 0x04, 0xb9, 0x02, 0x08, 0x28, 0x22, 0x22, 0x20,
    0x6d, 0x61, 0x78, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x0d,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x04, 0x12, 0x04, 0xb9, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x05, 0x12, 0x04, 0xb9, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x01, 0x12, 0x04, 0xb9, 0x02, 0x17, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x03, 0x12, 0x04, 0xb9, 0x02, 0x25, 0x27, 0x0a, 0x2d, 0x0a,
    0x04, 0x04, 0x16, 0x02, 0x0a, 0x12, 0x04, 0xba, 0x02, 0x08, 0x28, 0x22, 0x1f, 0x20, 0x6d, 0x61,
    0x78, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xba, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xba, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x0a, 0x01, 0x12, 0x04, 0xba, 0x02, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x0a, 0x03, 0x12, 0x04, 0xba, 0x02, 0x25, 0x27, 0x0a, 0x27, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x0b,
    0x12, 0x04, 0xbb, 0x02, 0x08, 0x28, 0x22, 0x19, 0x20, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x20, 0x73, 0x6c, 0x6f, 0x74, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x0d,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xbb, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xbb, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xbb, 0x02, 0x17, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xbb, 0x02, 0x25, 0x27, 0x0a, 0x25, 0x0a,
    0x04, 0x04, 0x16, 0x02, 0x0c, 0x12, 0x04, 0xbc, 0x02, 0x08, 0x2a, 0x22, 0x17, 0x20, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x20, 0x74, 0x69, 0x63, 0x6b, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76,
    0x61, 0x6c, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xbc,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xbc, 0x02,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xbc, 0x02, 0x17,
    0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xbc, 0x02, 0x27, 0x29,
    0x0a, 0x28, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x0d, 0x12, 0x04, 0xbd, 0x02, 0x08, 0x26, 0x22, 0x1a,
    0x20, 0x67, 0x61, 0x6d, 0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x20,
    0x65, 0x67, 0x20, 0x22, 0x74, 0x66, 0x32, 0x22, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x0d, 0x04, 0x12, 0x04, 0xbd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x0d, 0x05, 0x12, 0x04, 0xbd, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0d,
    0x01, 0x12, 0x04, 0xbd, 0x02, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0d, 0x03,
    0x12, 0x04, 0xbd, 0x02, 0x23, 0x25, 0x0a, 0x25, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x0e, 0x12, 0x04,
    0xbe, 0x02, 0x08, 0x26, 0x22, 0x17, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x63,
    0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x70, 0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xbe, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xbe, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xbe, 0x02, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x0e, 0x03, 0x12, 0x04, 0xbe, 0x02, 0x23, 0x25, 0x0a, 0x28, 0x0a, 0x04, 0x04, 0x16, 0x02,
    0x0f, 0x12, 0x04, 0xbf, 0x02, 0x08, 0x26, 0x22, 0x1a, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f,
    0x66, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x6b, 0x79, 0x62, 0x6f, 0x78,
    0x20, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xbf, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xbf, 0x02, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xbf, 0x02, 0x18, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xbf, 0x02, 0x23, 0x25, 0x0a,
    0x1c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x10, 0x12, 0x04, 0xc0, 0x02, 0x08, 0x27, 0x22, 0x0e, 0x20,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x10, 0x04, 0x12, 0x04, 0xc0, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x10, 0x05, 0x12, 0x04, 0xc0, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x10, 0x01, 0x12, 0x04, 0xc0, 0x02, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x10, 0x03, 0x12, 0x04, 0xc0, 0x02, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x17, 0x12,
    0x06, 0xc3, 0x02, 0x00, 0xce, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01, 0x12, 0x04,
    0xc3, 0x02, 0x08, 0x19, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x17, 0x03, 0x00, 0x12, 0x06, 0xc5, 0x02,
    0x08, 0xca, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x03, 0x00, 0x01, 0x12, 0x04, 0xc5,
    0x02, 0x10, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xc7,
    0x02, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xc7, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xc7, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc7, 0x02, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xc7, 0x02, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xc8, 0x02, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xc8, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xc8, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc8, 0x02, 0x20, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc8, 0x02, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xc9, 0x02, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc9, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc9, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc9, 0x02, 0x20, 0x2a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc9, 0x02, 0x2d, 0x2e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x00, 0x12, 0x04, 0xcc, 0x02, 0x08, 0x2b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcc, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcc, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcc, 0x02, 0x16, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xcc, 0x02, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02,
    0x01, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xcd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x06, 0x12,
    0x04, 0xcd, 0x02, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xcd, 0x02, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcd,
    0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x18, 0x12, 0x06, 0xd0, 0x02, 0x00, 0xd3, 0x02,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01, 0x12, 0x04, 0xd0, 0x02, 0x08, 0x18, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04, 0xd2, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd2, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd2, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xd2, 0x02, 0x16, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xd2, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06,
    0xd5, 0x02, 0x00, 0xd9, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x19, 0x01, 0x12, 0x04, 0xd5,
    0x02, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x00, 0x12, 0x04, 0xd7, 0x02, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd7, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd7, 0x02, 0x17, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd7, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x19, 0x02, 0x01, 0x12, 0x04, 0xd8, 0x02, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd8, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xd8, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xd8, 0x02, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xd8, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1a, 0x12, 0x06, 0xdb,
    0x02, 0x00, 0xde, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1a, 0x01, 0x12, 0x04, 0xdb, 0x02,
    0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x02, 0x08, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdd, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdd, 0x02, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x02, 0x18, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdd, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x1b, 0x12, 0x06, 0xe0, 0x02, 0x00, 0xf9, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1b,
    0x01, 0x12, 0x04, 0xe0, 0x02, 0x08, 0x16, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1b, 0x03, 0x00, 0x12,
    0x06, 0xe2, 0x02, 0x08, 0xf5, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xe2, 0x02, 0x10, 0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x00,
    0x12, 0x04, 0xe4, 0x02, 0x10, 0x3d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xe4, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xe4, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xe4, 0x02, 0x30, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe4, 0x02, 0x3b, 0x3c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xe5, 0x02, 0x10, 0x3d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe5, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1b, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe5, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1b, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe5, 0x02, 0x30, 0x38, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe5, 0x02, 0x3b, 0x3c, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xe6, 0x02, 0x10, 0x3d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe6, 0x02, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe6, 0x02, 0x19, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x02, 0x30,
    0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe6, 0x02,
    0x3b, 0x3c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xe7, 0x02,
    0x10, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe7,
    0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xe7, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xe7, 0x02, 0x30, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xe7, 0x02, 0x39, 0x3a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x04,
    0x12, 0x04, 0xe8, 0x02, 0x10, 0x40, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xe8, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02,
    0x04, 0x05, 0x12, 0x04, 0xe8, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xe8, 0x02, 0x30, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03,
    0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe8, 0x02, 0x3e, 0x3f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xe9, 0x02, 0x10, 0x44, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe9, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1b, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xe9, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1b, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xe9, 0x02, 0x30, 0x3f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0xe9, 0x02, 0x42, 0x43, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0xea, 0x02, 0x10, 0x41, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xea, 0x02, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xea, 0x02, 0x19, 0x1e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xea, 0x02, 0x30,
    0x3c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xea, 0x02,
    0x3f, 0x40, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x07, 0x12, 0x04, 0xeb, 0x02,
    0x10, 0x3c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0xeb,
    0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x07, 0x05, 0x12, 0x04,
    0xeb, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x07, 0x01, 0x12,
    0x04, 0xeb, 0x02, 0x30, 0x37, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x07, 0x03,
    0x12, 0x04, 0xeb, 0x02, 0x3a, 0x3b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x08,
    0x12, 0x04, 0xec, 0x02, 0x10, 0x3a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x08,
    0x04, 0x12, 0x04, 0xec, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02,
    0x08, 0x05, 0x12, 0x04, 0xec, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00,
    0x02, 0x08, 0x01, 0x12, 0x04, 0xec, 0x02, 0x30, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03,
    0x00, 0x02, 0x08, 0x03, 0x12, 0x04, 0xec, 0x02, 0x38, 0x39, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x09, 0x12, 0x04, 0xed, 0x02, 0x10, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x09, 0x04, 0x12, 0x04, 0xed, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1b, 0x03, 0x00, 0x02, 0x09, 0x05, 0x12, 0x04, 0xed, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1b, 0x03, 0x00, 0x02, 0x09, 0x01, 0x12, 0x04, 0xed, 0x02, 0x30, 0x35, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x09, 0x03, 0x12, 0x04, 0xed, 0x02, 0x38, 0x3a, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0a, 0x12, 0x04, 0xee, 0x02, 0x10, 0x3f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xee, 0x02, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xee, 0x02, 0x19, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xee, 0x02, 0x30,
    0x39, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xee, 0x02,
    0x3c, 0x3e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0b, 0x12, 0x04, 0xef, 0x02,
    0x10, 0x46, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xef,
    0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0b, 0x05, 0x12, 0x04,
    0xef, 0x02, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0b, 0x01, 0x12,
    0x04, 0xef, 0x02, 0x30, 0x40, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0b, 0x03,
    0x12, 0x04, 0xef, 0x02, 0x43, 0x45, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0c,
    0x12, 0x04, 0xf0, 0x02, 0x10, 0x44, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0c,
    0x04, 0x12, 0x04, 0xf0, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02,
    0x0c, 0x05, 0x12, 0x04, 0xf0, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00,
    0x02, 0x0c, 0x01, 0x12, 0x04, 0xf0, 0x02, 0x30, 0x3e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03,
    0x00, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xf0, 0x02, 0x41, 0x43, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x0d, 0x12, 0x04, 0xf1, 0x02, 0x10, 0x41, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x0d, 0x04, 0x12, 0x04, 0xf1, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1b, 0x03, 0x00, 0x02, 0x0d, 0x05, 0x12, 0x04, 0xf1, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1b, 0x03, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xf1, 0x02, 0x30, 0x3b, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0d, 0x03, 0x12, 0x04, 0xf1, 0x02, 0x3e, 0x40, 0x0a, 0x1f,
    0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0e, 0x12, 0x04, 0xf2, 0x02, 0x10, 0x41, 0x22, 0x0f,
    0x20, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x5f, 0x74, 0x0d, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xf2, 0x02, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xf2, 0x02, 0x19,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xf2, 0x02,
    0x30, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xf2,
    0x02, 0x3e, 0x40, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0f, 0x12, 0x04, 0xf3,
    0x02, 0x10, 0x41, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0f, 0x04, 0x12, 0x04,
    0xf3, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0f, 0x05, 0x12,
    0x04, 0xf3, 0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0f, 0x01,
    0x12, 0x04, 0xf3, 0x02, 0x30, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02, 0x0f,
    0x03, 0x12, 0x04, 0xf3, 0x02, 0x3e, 0x40, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1b, 0x03, 0x00, 0x02,
    0x10, 0x12, 0x04, 0xf4, 0x02, 0x10, 0x40, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00, 0x02,
    0x10, 0x04, 0x12, 0x04, 0xf4, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03, 0x00,
    0x02, 0x10, 0x05, 0x12, 0x04, 0xf4, 0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b, 0x03,
    0x00, 0x02, 0x10, 0x01, 0x12, 0x04, 0xf4, 0x02, 0x30, 0x3a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1b,
    0x03, 0x00, 0x02, 0x10, 0x03, 0x12, 0x04, 0xf4, 0x02, 0x3d, 0x3f, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1b, 0x02, 0x00, 0x12, 0x04, 0xf7, 0x02, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xf7, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xf7, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xf7, 0x02, 0x16, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xf7, 0x02, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x01, 0x12, 0x04, 0xf8,
    0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf8, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x06, 0x12, 0x04, 0xf8, 0x02, 0x11,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf8, 0x02, 0x1d, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf8, 0x02, 0x26, 0x27, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06, 0xfb, 0x02, 0x00, 0xfe, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x1c, 0x01, 0x12, 0x04, 0xfb, 0x02, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c,
    0x02, 0x00, 0x12, 0x04, 0xfd, 0x02, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xfd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xfd, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xfd, 0x02, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xfd, 0x02, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1d, 0x12, 0x06, 0x80, 0x03, 0x00, 0x83,
    0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1d, 0x01, 0x12, 0x04, 0x80, 0x03, 0x08, 0x17, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x00, 0x12, 0x04, 0x82, 0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1d, 0x02, 0x00, 0x04, 0x12, 0x04, 0x82, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1d, 0x02, 0x00, 0x05, 0x12, 0x04, 0x82, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1d, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x82, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1e, 0x12,
    0x06, 0x85, 0x03, 0x00, 0x89, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1e, 0x01, 0x12, 0x04,
    0x85, 0x03, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x00, 0x12, 0x04, 0x87, 0x03,
    0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x04, 0x12, 0x04, 0x87, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x05, 0x12, 0x04, 0x87, 0x03, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x01, 0x12, 0x04, 0x87, 0x03, 0x16, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x03, 0x12, 0x04, 0x87, 0x03, 0x21, 0x22, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1e, 0x02, 0x01, 0x12, 0x04, 0x88, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x01, 0x04, 0x12, 0x04, 0x88, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x01, 0x06, 0x12, 0x04, 0x88, 0x03, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x88, 0x03, 0x1c, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x88, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1f, 0x12, 0x06,
    0x8b, 0x03, 0x00, 0x8e, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1f, 0x01, 0x12, 0x04, 0x8b,
    0x03, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1f, 0x02, 0x00, 0x12, 0x04, 0x8d, 0x03, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8d, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8d, 0x03, 0x11, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8d, 0x03, 0x1c, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8d, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x20, 0x12, 0x06, 0x90, 0x03, 0x00, 0x97, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x20, 0x01, 0x12, 0x04, 0x90, 0x03, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x00,
    0x12, 0x04, 0x92, 0x03, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x92, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x06, 0x12, 0x04,
    0x92, 0x03, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x01, 0x12, 0x04, 0x92,
    0x03, 0x1c, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x03, 0x12, 0x04, 0x92, 0x03,
    0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x01, 0x12, 0x04, 0x93, 0x03, 0x08, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x04, 0x12, 0x04, 0x93, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x05, 0x12, 0x04, 0x93, 0x03, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x01, 0x12, 0x04, 0x93, 0x03, 0x17, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x01, 0x03, 0x12, 0x04, 0x93, 0x03, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x20, 0x02, 0x02, 0x12, 0x04, 0x94, 0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20,
    0x02, 0x02, 0x04, 0x12, 0x04, 0x94, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x94, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02,
    0x01, 0x12, 0x04, 0x94, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x03,
    0x12, 0x04, 0x94, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x03, 0x12, 0x04,
    0x95, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x03, 0x04, 0x12, 0x04, 0x95,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x03, 0x05, 0x12, 0x04, 0x95, 0x03,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x03, 0x01, 0x12, 0x04, 0x95, 0x03, 0x17,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x03, 0x03, 0x12, 0x04, 0x95, 0x03, 0x25, 0x26,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x04, 0x12, 0x04, 0x96, 0x03, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x04, 0x04, 0x12, 0x04, 0x96, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x04, 0x05, 0x12, 0x04, 0x96, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x04, 0x01, 0x12, 0x04, 0x96, 0x03, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x20, 0x02, 0x04, 0x03, 0x12, 0x04, 0x96, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x04,
    0x12, 0x06, 0x99, 0x03, 0x00, 0x9e, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x04, 0x01, 0x12,
    0x04, 0x99, 0x03, 0x05, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x00, 0x12, 0x04, 0x9b,
    0x03, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9b, 0x03,
    0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00, 0x02, 0x12, 0x04, 0x9b, 0x03, 0x22,
    0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x01, 0x12, 0x04, 0x9c, 0x03, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9c, 0x03, 0x08, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x04, 0x02, 0x01, 0x02, 0x12, 0x04, 0x9c, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a,
    0x04, 0x05, 0x04, 0x02, 0x02, 0x12, 0x04, 0x9d, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x04, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9d, 0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04,
    0x02, 0x02, 0x02, 0x12, 0x04, 0x9d, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x21, 0x12,
    0x06, 0xa0, 0x03, 0x00, 0xa5, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x21, 0x01, 0x12, 0x04,
    0xa0, 0x03, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x00, 0x12, 0x04, 0xa2, 0x03,
    0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa2, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa2, 0x03, 0x11, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa2, 0x03, 0x29, 0x2d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa2, 0x03, 0x30, 0x31, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x21, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x21, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa3, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x21, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa3, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xa3, 0x03, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x02,
    0x12, 0x04, 0xa4, 0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xa4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x05, 0x12, 0x04,
    0xa4, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa4,
    0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa4, 0x03,
    0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x22, 0x12, 0x06, 0xa7, 0x03, 0x00, 0xab, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x22, 0x01, 0x12, 0x04, 0xa7, 0x03, 0x08, 0x1c, 0x0a, 0x22, 0x0a,
    0x04, 0x04, 0x22, 0x02, 0x00, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x22, 0x22, 0x14, 0x20, 0x51, 0x75,
    0x65, 0x72, 0x79, 0x43, 0x76, 0x61, 0x72, 0x43, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x5f, 0x74, 0x0d,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa9, 0x03, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa9, 0x03, 0x17, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa9, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x22, 0x02, 0x01, 0x12, 0x04, 0xaa, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x22, 0x02, 0x01, 0x04, 0x12, 0x04, 0xaa, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xaa, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xaa, 0x03, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xaa, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x23, 0x12, 0x06, 0xad,
    0x03, 0x00, 0xb1, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x23, 0x01, 0x12, 0x04, 0xad, 0x03,
    0x08, 0x14, 0x0a, 0x1c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x03, 0x08, 0x27,
    0x22, 0x0e, 0x20, 0x44, 0x49, 0x41, 0x4c, 0x4f, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x0d, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x04, 0x12, 0x04, 0xaf, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x05, 0x12, 0x04, 0xaf, 0x03, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x03, 0x17, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x23, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaf, 0x03, 0x25, 0x26, 0x0a, 0x2a, 0x0a, 0x04,
    0x04, 0x23, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x03, 0x08, 0x2b, 0x22, 0x1c, 0x20, 0x4b, 0x65, 0x79,
    0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x41, 0x73, 0x42, 0x69,
    0x6e, 0x61, 0x72, 0x79, 0x28, 0x29, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xb0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xb0, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xb0, 0x03, 0x17, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xb0, 0x03, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x24, 0x12, 0x06, 0xb3, 0x03, 0x00, 0xc6,
    0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x24, 0x01, 0x12, 0x04, 0xb3, 0x03, 0x08, 0x19, 0x0a,
    0x0e, 0x0a, 0x04, 0x04, 0x24, 0x03, 0x00, 0x12, 0x06, 0xb5, 0x03, 0x08, 0xc0, 0x03, 0x09, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x24, 0x03, 0x00, 0x01, 0x12, 0x04, 0xb5, 0x03, 0x10, 0x1a, 0x0a, 0x1f,
    0x0a, 0x06, 0x04, 0x24, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb7, 0x03, 0x10, 0x28, 0x22, 0x0f,
    0x20, 0x53, 0x65, 0x6e, 0x64, 0x50, 0x72, 0x6f, 0x70, 0x54, 0x79, 0x70, 0x65, 0x0d, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb7, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb7, 0x03, 0x19,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x03,
    0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb7,
    0x03, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x24, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb8,
    0x03, 0x10, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xb8, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xb8, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xb8, 0x03, 0x20, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xb8, 0x03, 0x2b, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x24, 0x03, 0x00, 0x02,
    0x02, 0x12, 0x04, 0xb9, 0x03, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xb9, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xb9, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb9, 0x03, 0x1f, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24,
    0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb9, 0x03, 0x27, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x24, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xba, 0x03, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x24, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xba, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x24, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xba, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xba, 0x03, 0x1f, 0x27, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xba, 0x03, 0x2a, 0x2b, 0x0a,
    0x45, 0x0a, 0x06, 0x04, 0x24, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xbb, 0x03, 0x10, 0x2c, 0x22,
    0x35, 0x20, 0x69, 0x66, 0x20, 0x70, 0x50, 0x72, 0x6f, 0x70, 0x2d, 0x3e, 0x6d, 0x5f, 0x54, 0x79,
    0x70, 0x65, 0x20, 0x3d, 0x3d, 0x20, 0x44, 0x50, 0x54, 0x5f, 0x44, 0x61, 0x74, 0x61, 0x54, 0x61,
    0x62, 0x6c, 0x65, 0x20, 0x7c, 0x7c, 0x20, 0x49, 0x73, 0x45, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65,
    0x50, 0x72, 0x6f, 0x70, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xbb, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02,
    0x04, 0x05, 0x12, 0x04, 0xbb, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xbb, 0x03, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03,
    0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xbb, 0x03, 0x2a, 0x2b, 0x0a, 0x35, 0x0a, 0x06, 0x04, 0x24,
    0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xbc, 0x03, 0x10, 0x30, 0x22, 0x25, 0x20, 0x65, 0x6c, 0x73,
    0x65, 0x20, 0x69, 0x66, 0x20, 0x70, 0x50, 0x72, 0x6f, 0x70, 0x2d, 0x3e, 0x6d, 0x5f, 0x54, 0x79,
    0x70, 0x65, 0x20, 0x3d, 0x3d, 0x20, 0x44, 0x50, 0x54, 0x5f, 0x41, 0x72, 0x72, 0x61, 0x79, 0x0d,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xbc, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xbc,
    0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04,
    0xbc, 0x03, 0x1f, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12,
    0x04, 0xbc, 0x03, 0x2e, 0x2f, 0x0a, 0x1b, 0x0a, 0x06, 0x04, 0x24, 0x03, 0x00, 0x02, 0x06, 0x12,
    0x04, 0xbd, 0x03, 0x10, 0x2d, 0x22, 0x0b, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x20, 0x2e, 0x2e, 0x2e,
    0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xbd,
    0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04,
    0xbd, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12,
    0x04, 0xbd, 0x03, 0x1f, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x06, 0x03,
    0x12, 0x04, 0xbd, 0x03, 0x2b, 0x2c, 0x0a, 0x18, 0x0a, 0x06, 0x04, 0x24, 0x03, 0x00, 0x02, 0x07,
    0x12, 0x04, 0xbe, 0x03, 0x10, 0x2e, 0x22, 0x08, 0x20, 0x09, 0x09, 0x2e, 0x2e, 0x2e, 0x0d, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0xbe, 0x03, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x07, 0x05, 0x12, 0x04, 0xbe, 0x03,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0xbe,
    0x03, 0x1f, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x07, 0x03, 0x12, 0x04,
    0xbe, 0x03, 0x2c, 0x2d, 0x0a, 0x17, 0x0a, 0x06, 0x04, 0x24, 0x03, 0x00, 0x02, 0x08, 0x12, 0x04,
    0xbf, 0x03, 0x10, 0x2c, 0x22, 0x07, 0x09, 0x09, 0x2e, 0x2e, 0x2e, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x08, 0x04, 0x12, 0x04, 0xbf, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x08, 0x05, 0x12, 0x04, 0xbf, 0x03, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04, 0xbf, 0x03, 0x1f, 0x27,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x24, 0x03, 0x00, 0x02, 0x08, 0x03, 0x12, 0x04, 0xbf, 0x03, 0x2a,
    0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x00, 0x12, 0x04, 0xc2, 0x03, 0x08, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc2, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc2, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x24, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc2, 0x03, 0x16, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x24, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc2, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x24, 0x02, 0x01, 0x12, 0x04, 0xc3, 0x03, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xc3, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xc3, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xc3, 0x03, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xc3, 0x03, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x02, 0x12, 0x04, 0xc4,
    0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc4, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc4, 0x03, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc4, 0x03, 0x16, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc4, 0x03, 0x26, 0x27, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x03, 0x12, 0x04, 0xc5, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x24, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x24, 0x02, 0x03, 0x06, 0x12, 0x04, 0xc5, 0x03, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x24, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x1c, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xc5, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x25, 0x12,
    0x06, 0xc8, 0x03, 0x00, 0xd9, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x25, 0x01, 0x12, 0x04,
    0xc8, 0x03, 0x08, 0x19, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x25, 0x03, 0x00, 0x12, 0x06, 0xca, 0x03,
    0x08, 0xd4, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x03, 0x00, 0x01, 0x12, 0x04, 0xca,
    0x03, 0x10, 0x15, 0x0a, 0x17, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xcc,
    0x03, 0x10, 0x28, 0x22, 0x07, 0x20, 0x74, 0x79, 0x70, 0x65, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcc, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcc, 0x03, 0x19, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcc, 0x03, 0x1f, 0x23, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcc, 0x03, 0x26, 0x27,
    0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x03, 0x10, 0x2f,
    0x22, 0x0e, 0x20, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x0d, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcd, 0x03, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcd, 0x03,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcd,
    0x03, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xcd, 0x03, 0x2d, 0x2e, 0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04,
    0xce, 0x03, 0x10, 0x2d, 0x22, 0x0e, 0x20, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x4c, 0x4f, 0x41,
    0x54, 0x20, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xce, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xce, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xce, 0x03, 0x1f, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xce, 0x03, 0x2b, 0x2c, 0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00,
    0x02, 0x03, 0x12, 0x04, 0xcf, 0x03, 0x10, 0x2c, 0x22, 0x0e, 0x20, 0x54, 0x59, 0x50, 0x45, 0x5f,
    0x4c, 0x4f, 0x4e, 0x47, 0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xcf, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03,
    0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xcf, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25,
    0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xcf, 0x03, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x25, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xcf, 0x03, 0x2a, 0x2b, 0x0a, 0x1e, 0x0a, 0x06,
    0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xd0, 0x03, 0x10, 0x2d, 0x22, 0x0e, 0x20, 0x54,
    0x59, 0x50, 0x45, 0x5f, 0x53, 0x48, 0x4f, 0x52, 0x54, 0x20, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd0, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xd0, 0x03, 0x19, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd0, 0x03, 0x1f, 0x28, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd0, 0x03, 0x2b, 0x2c,
    0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xd1, 0x03, 0x10, 0x2c,
    0x22, 0x0e, 0x20, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x42, 0x59, 0x54, 0x45, 0x20, 0x20, 0x0d, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xd1, 0x03, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xd1, 0x03,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd1,
    0x03, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04,
    0xd1, 0x03, 0x2a, 0x2b, 0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04,
    0xd2, 0x03, 0x10, 0x2b, 0x22, 0x0e, 0x20, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x42, 0x4f, 0x4f, 0x4c,
    0x20, 0x20, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12,
    0x04, 0xd2, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x06, 0x05,
    0x12, 0x04, 0xd2, 0x03, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x06,
    0x01, 0x12, 0x04, 0xd2, 0x03, 0x1e, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02,
    0x06, 0x03, 0x12, 0x04, 0xd2, 0x03, 0x29, 0x2a, 0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00,
    0x02, 0x07, 0x12, 0x04, 0xd3, 0x03, 0x10, 0x2f, 0x22, 0x0e, 0x20, 0x54, 0x59, 0x50, 0x45, 0x5f,
    0x55, 0x49, 0x4e, 0x54, 0x36, 0x34, 0x0d, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00,
    0x02, 0x07, 0x04, 0x12, 0x04, 0xd3, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03,
    0x00, 0x02, 0x07, 0x05, 0x12, 0x04, 0xd3, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25,
    0x03, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0xd3, 0x03, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x25, 0x03, 0x00, 0x02, 0x07, 0x03, 0x12, 0x04, 0xd3, 0x03, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x25, 0x02, 0x00, 0x12, 0x04, 0xd6, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xd6, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xd6, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xd6, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xd6, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x01, 0x12, 0x04,
    0xd7, 0x03, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd7,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd7, 0x03,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd7, 0x03, 0x17,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd7, 0x03, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x02, 0x12, 0x04, 0xd8, 0x03, 0x08, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x25, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd8, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x25, 0x02, 0x02, 0x06, 0x12, 0x04, 0xd8, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x25, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd8, 0x03, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x25, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd8, 0x03, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x26,
    0x12, 0x06, 0xdb, 0x03, 0x00, 0xeb, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x26, 0x01, 0x12,
    0x04, 0xdb, 0x03, 0x08, 0x1d, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x26, 0x03, 0x00, 0x12, 0x06, 0xdd,
    0x03, 0x08, 0xe1, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x03, 0x00, 0x01, 0x12, 0x04,
    0xdd, 0x03, 0x10, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x26, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04,
    0xdf, 0x03, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xdf, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x00, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xdf, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xdf, 0x03, 0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x00, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xdf, 0x03, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x26, 0x03, 0x00,
    0x02, 0x01, 0x12, 0x04, 0xe0, 0x03, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xe0, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe0, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe0, 0x03, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x26, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe0, 0x03, 0x27, 0x28, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x26, 0x03, 0x01, 0x12, 0x06, 0xe3, 0x03, 0x08, 0xe8, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x26, 0x03, 0x01, 0x01, 0x12, 0x04, 0xe3, 0x03, 0x10, 0x1c, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x26, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xe5, 0x03, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x26, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe5, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x26, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe5, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe5, 0x03, 0x1f, 0x26, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe5, 0x03, 0x29, 0x2a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x26, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x03, 0x10, 0x29, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe6, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe6, 0x03, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe6, 0x03,
    0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe6,
    0x03, 0x27, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x26, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xe7,
    0x03, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xe7, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x02, 0x06, 0x12,
    0x04, 0xe7, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xe7, 0x03, 0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x26, 0x03, 0x01, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xe7, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x26, 0x02, 0x00, 0x12,
    0x04, 0xea, 0x03, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xea, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x06, 0x12, 0x04, 0xea,
    0x03, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x01, 0x12, 0x04, 0xea, 0x03,
    0x1e, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x03, 0x12, 0x04, 0xea, 0x03, 0x2c,
    0x2d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x27, 0x12, 0x06, 0xed, 0x03, 0x00, 0xf6, 0x03, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x27, 0x01, 0x12, 0x04, 0xed, 0x03, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x27, 0x02, 0x00, 0x12, 0x04, 0xef, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xef, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xef, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xef, 0x03, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xef, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x01, 0x12, 0x04,
    0xf0, 0x03, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf0,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf0, 0x03,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf0, 0x03, 0x17,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf0, 0x03, 0x29, 0x2a,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x02, 0x12, 0x04, 0xf1, 0x03, 0x08, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf1, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x27, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf1, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x27, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf1, 0x03, 0x16, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x27, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf1, 0x03, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27,
    0x02, 0x03, 0x12, 0x04, 0xf2, 0x03, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xf2, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xf2, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xf2, 0x03, 0x16, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xf2, 0x03, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x04, 0x12, 0x04, 0xf3, 0x03,
    0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf3, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x05, 0x12, 0x04, 0xf3, 0x03, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x01, 0x12, 0x04, 0xf3, 0x03, 0x17, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x03, 0x12, 0x04, 0xf3, 0x03, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x27, 0x02, 0x05, 0x12, 0x04, 0xf4, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x27, 0x02, 0x05, 0x04, 0x12, 0x04, 0xf4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x27, 0x02, 0x05, 0x05, 0x12, 0x04, 0xf4, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xf4, 0x03, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xf4, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x06,
    0x12, 0x04, 0xf5, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x06, 0x04, 0x12,
    0x04, 0xf5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x06, 0x05, 0x12, 0x04,
    0xf5, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x06, 0x01, 0x12, 0x04, 0xf5,
    0x03, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x06, 0x03, 0x12, 0x04, 0xf5, 0x03,
    0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x28, 0x12, 0x06, 0xf8, 0x03, 0x00, 0xfd, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x28, 0x01, 0x12, 0x04, 0xf8, 0x03, 0x08, 0x1c, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x28, 0x02, 0x00, 0x12, 0x04, 0xfa, 0x03, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x28, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfa, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xfa, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xfa, 0x03, 0x16, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xfa, 0x03, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x01, 0x12,
    0x04, 0xfb, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xfb, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x05, 0x12, 0x04, 0xfb,
    0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfb, 0x03,
    0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x03, 0x12, 0x04, 0xfb, 0x03, 0x25,
    0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x02, 0x12, 0x04, 0xfc, 0x03, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x04, 0x12, 0x04, 0xfc, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x28, 0x02, 0x02, 0x05, 0x12, 0x04, 0xfc, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x28, 0x02, 0x02, 0x01, 0x12, 0x04, 0xfc, 0x03, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x28, 0x02, 0x02, 0x03, 0x12, 0x04, 0xfc, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x29, 0x12, 0x06, 0xff, 0x03, 0x00, 0x89, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x29, 0x01,
    0x12, 0x04, 0xff, 0x03, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x00, 0x12, 0x04,
    0x81, 0x04, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x04, 0x12, 0x04, 0x81,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x05, 0x12, 0x04, 0x81, 0x04,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x01, 0x12, 0x04, 0x81, 0x04, 0x18,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x03, 0x12, 0x04, 0x81, 0x04, 0x1f, 0x20,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x01, 0x12, 0x04, 0x82, 0x04, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x29, 0x02, 0x01, 0x04, 0x12, 0x04, 0x82, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x29, 0x02, 0x01, 0x05, 0x12, 0x04, 0x82, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x29, 0x02, 0x01, 0x01, 0x12, 0x04, 0x82, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x29, 0x02, 0x01, 0x03, 0x12, 0x04, 0x82, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29,
    0x02, 0x02, 0x12, 0x04, 0x83, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x83, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x83, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x83, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x83, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x03, 0x12, 0x04, 0x84, 0x04,
    0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03, 0x04, 0x12, 0x04, 0x84, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03, 0x05, 0x12, 0x04, 0x84, 0x04, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03, 0x01, 0x12, 0x04, 0x84, 0x04, 0x16, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03, 0x03, 0x12, 0x04, 0x84, 0x04, 0x2d, 0x2e, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x29, 0x02, 0x04, 0x12, 0x04, 0x85, 0x04, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x29, 0x02, 0x04, 0x04, 0x12, 0x04, 0x85, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x29, 0x02, 0x04, 0x05, 0x12, 0x04, 0x85, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29,
    0x02, 0x04, 0x01, 0x12, 0x04, 0x85, 0x04, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02,
    0x04, 0x03, 0x12, 0x04, 0x85, 0x04, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x05,
    0x12, 0x04, 0x86, 0x04, 0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x05, 0x04, 0x12,
    0x04, 0x86, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x05, 0x05, 0x12, 0x04,
    0x86, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x05, 0x01, 0x12, 0x04, 0x86,
    0x04, 0x17, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x05, 0x03, 0x12, 0x04, 0x86, 0x04,
    0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x06, 0x12, 0x04, 0x87, 0x04, 0x08, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x06, 0x04, 0x12, 0x04, 0x87, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x06, 0x05, 0x12, 0x04, 0x87, 0x04, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x29, 0x02, 0x06, 0x01, 0x12, 0x04, 0x87, 0x04, 0x17, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x29, 0x02, 0x06, 0x03, 0x12, 0x04, 0x87, 0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x29, 0x02, 0x07, 0x12, 0x04, 0x88, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29,
    0x02, 0x07, 0x04, 0x12, 0x04, 0x88, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02,
    0x07, 0x05, 0x12, 0x04, 0x88, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x07,
    0x01, 0x12, 0x04, 0x88, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x07, 0x03,
    0x12, 0x04, 0x88, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2a, 0x12, 0x06, 0x8b, 0x04,
    0x00, 0x90, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2a, 0x01, 0x12, 0x04, 0x8b, 0x04, 0x08,
    0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x00, 0x12, 0x04, 0x8d, 0x04, 0x08, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8d, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8d, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2a, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8d, 0x04, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2a, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8d, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x2a, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x04, 0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x8e, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x01,
    0x05, 0x12, 0x04, 0x8e, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x8e, 0x04, 0x17, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x8e, 0x04, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x02, 0x12, 0x04, 0x8f,
    0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8f, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8f, 0x04, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8f, 0x04, 0x17, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8f, 0x04, 0x25, 0x26, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x2b, 0x12, 0x06, 0x92, 0x04, 0x00, 0x96, 0x04, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x2b, 0x01, 0x12, 0x04, 0x92, 0x04, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b,
    0x02, 0x00, 0x12, 0x04, 0x94, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x94, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x05,
    0x12, 0x04, 0x94, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x94, 0x04, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x94, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x01, 0x12, 0x04, 0x95, 0x04,
    0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x04, 0x12, 0x04, 0x95, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x05, 0x12, 0x04, 0x95, 0x04, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x01, 0x12, 0x04, 0x95, 0x04, 0x17, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x03, 0x12, 0x04, 0x95, 0x04, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x2c, 0x12, 0x06, 0x98, 0x04, 0x00, 0x9f, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x2c, 0x01, 0x12, 0x04, 0x98, 0x04, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02,
    0x00, 0x12, 0x04, 0x9a, 0x04, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x9a, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x05, 0x12,
    0x04, 0x9a, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x01, 0x12, 0x04,
    0x9a, 0x04, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9a,
    0x04, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x04, 0x08,
    0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9b, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9b, 0x04, 0x11, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9b, 0x04, 0x16, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2c, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9b, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x2c, 0x02, 0x02, 0x12, 0x04, 0x9c, 0x04, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2c, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9c, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c,
    0x02, 0x02, 0x05, 0x12, 0x04, 0x9c, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x9c, 0x04, 0x19, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02,
    0x03, 0x12, 0x04, 0x9c, 0x04, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x03, 0x12,
    0x04, 0x9d, 0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x03, 0x04, 0x12, 0x04,
    0x9d, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x03, 0x05, 0x12, 0x04, 0x9d,
    0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9d, 0x04,
    0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9d, 0x04, 0x26,
    0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x04, 0x12, 0x04, 0x9e, 0x04, 0x08, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9e, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2c, 0x02, 0x04, 0x05, 0x12, 0x04, 0x9e, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2c, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9e, 0x04, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2c, 0x02, 0x04, 0x03, 0x12, 0x04, 0x9e, 0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x2d, 0x12, 0x06, 0xa1, 0x04, 0x00, 0xaa, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2d, 0x01,
    0x12, 0x04, 0xa1, 0x04, 0x08, 0x1e, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2d, 0x03, 0x00, 0x12, 0x06,
    0xa3, 0x04, 0x08, 0xa7, 0x04, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xa3, 0x04, 0x10, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2d, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xa5, 0x04, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2d, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xa5, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2d, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xa5, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2d, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xa5, 0x04, 0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2d, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa5, 0x04, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2d, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xa6, 0x04, 0x10, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2d, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa6, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2d,
    0x03, 0x00, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa6, 0x04, 0x19, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x2d, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa6, 0x04, 0x2b, 0x30, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x2d, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa6, 0x04, 0x33, 0x34, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x2d, 0x02, 0x00, 0x12, 0x04, 0xa9, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa9, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xa9, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xa9, 0x04, 0x19, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xa9, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2e, 0x12, 0x06, 0xac,
    0x04, 0x00, 0xb5, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2e, 0x01, 0x12, 0x04, 0xac, 0x04,
    0x08, 0x20, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2e, 0x03, 0x00, 0x12, 0x06, 0xae, 0x04, 0x08, 0xb2,
    0x04, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x03, 0x00, 0x01, 0x12, 0x04, 0xae, 0x04, 0x10,
    0x19, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb0, 0x04, 0x10,
    0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb0, 0x04,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb0,
    0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xb0, 0x04, 0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xb0, 0x04, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01, 0x12,
    0x04, 0xb1, 0x04, 0x10, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xb1, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xb1, 0x04, 0x19, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xb1, 0x04, 0x2d, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xb1, 0x04, 0x33, 0x34, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2e, 0x02,
    0x00, 0x12, 0x04, 0xb4, 0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xb4, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x06, 0x12,
    0x04, 0xb4, 0x04, 0x11, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xb4, 0x04, 0x1b, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb4,
    0x04, 0x26, 0x27,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto };

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data)
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CMsgVector {
    x: Option<f32>,
    y: Option<f32>,
    z: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CMsgVector {
    pub fn new() -> CMsgVector {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgVector {
        static mut instance: ::protobuf::lazy::Lazy<CMsgVector> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CMsgVector };
        unsafe {
            instance.get(|| {
                CMsgVector {
                    x: None,
                    y: None,
                    z: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_x(&mut self) {
        self.x = None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&'a mut self) -> &'a mut f32 {
        if self.x.is_none() {
            self.x = Some(0.);
        };
        self.x.as_mut().unwrap()
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or_else(|| 0.)
    }

    pub fn clear_y(&mut self) {
        self.y = None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&'a mut self) -> &'a mut f32 {
        if self.y.is_none() {
            self.y = Some(0.);
        };
        self.y.as_mut().unwrap()
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or_else(|| 0.)
    }

    pub fn clear_z(&mut self) {
        self.z = None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_z(&'a mut self) -> &'a mut f32 {
        if self.z.is_none() {
            self.z = Some(0.);
        };
        self.z.as_mut().unwrap()
    }

    pub fn get_z(&self) -> f32 {
        self.z.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CMsgVector {
    fn new() -> CMsgVector {
        CMsgVector::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.x = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.y = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.z = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.x.is_some() {
            my_size += 5;
        };
        if self.y.is_some() {
            my_size += 5;
        };
        if self.z.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.x {
            Some(ref v) => {
                os.write_float(1, *v);
            },
            None => {},
        };
        match self.y {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        match self.z {
            Some(ref v) => {
                os.write_float(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CMsgVector>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CMsgVector>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CMsgVector_x_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgVector>) });
                fields.push(unsafe { ::std::mem::transmute(&CMsgVector_y_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgVector>) });
                fields.push(unsafe { ::std::mem::transmute(&CMsgVector_z_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgVector>) });
                ::protobuf::reflect::MessageDescriptor::new::<CMsgVector>(
                    "CMsgVector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CMsgVector>()
    }
}

impl ::protobuf::Clear for CMsgVector {
    fn clear(&mut self) {
        self.clear_x();
        self.clear_y();
        self.clear_z();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CMsgVector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CMsgVector_x_acc_type;
static CMsgVector_x_acc: CMsgVector_x_acc_type = CMsgVector_x_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgVector> for CMsgVector_x_acc_type {
    fn name(&self) -> &'static str {
        "x"
    }

    fn has_field(&self, m: &CMsgVector) -> bool {
        m.has_x()
    }

    fn get_f32(&self, m: &CMsgVector) -> f32 {
        m.get_x()
    }
}

#[allow(non_camel_case_types)]
struct CMsgVector_y_acc_type;
static CMsgVector_y_acc: CMsgVector_y_acc_type = CMsgVector_y_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgVector> for CMsgVector_y_acc_type {
    fn name(&self) -> &'static str {
        "y"
    }

    fn has_field(&self, m: &CMsgVector) -> bool {
        m.has_y()
    }

    fn get_f32(&self, m: &CMsgVector) -> f32 {
        m.get_y()
    }
}

#[allow(non_camel_case_types)]
struct CMsgVector_z_acc_type;
static CMsgVector_z_acc: CMsgVector_z_acc_type = CMsgVector_z_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgVector> for CMsgVector_z_acc_type {
    fn name(&self) -> &'static str {
        "z"
    }

    fn has_field(&self, m: &CMsgVector) -> bool {
        m.has_z()
    }

    fn get_f32(&self, m: &CMsgVector) -> f32 {
        m.get_z()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CMsgVector2D {
    x: Option<f32>,
    y: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CMsgVector2D {
    pub fn new() -> CMsgVector2D {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgVector2D {
        static mut instance: ::protobuf::lazy::Lazy<CMsgVector2D> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CMsgVector2D };
        unsafe {
            instance.get(|| {
                CMsgVector2D {
                    x: None,
                    y: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_x(&mut self) {
        self.x = None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&'a mut self) -> &'a mut f32 {
        if self.x.is_none() {
            self.x = Some(0.);
        };
        self.x.as_mut().unwrap()
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or_else(|| 0.)
    }

    pub fn clear_y(&mut self) {
        self.y = None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&'a mut self) -> &'a mut f32 {
        if self.y.is_none() {
            self.y = Some(0.);
        };
        self.y.as_mut().unwrap()
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CMsgVector2D {
    fn new() -> CMsgVector2D {
        CMsgVector2D::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.x = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.y = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.x.is_some() {
            my_size += 5;
        };
        if self.y.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.x {
            Some(ref v) => {
                os.write_float(1, *v);
            },
            None => {},
        };
        match self.y {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CMsgVector2D>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CMsgVector2D>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CMsgVector2D_x_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgVector2D>) });
                fields.push(unsafe { ::std::mem::transmute(&CMsgVector2D_y_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgVector2D>) });
                ::protobuf::reflect::MessageDescriptor::new::<CMsgVector2D>(
                    "CMsgVector2D",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CMsgVector2D>()
    }
}

impl ::protobuf::Clear for CMsgVector2D {
    fn clear(&mut self) {
        self.clear_x();
        self.clear_y();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CMsgVector2D {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CMsgVector2D_x_acc_type;
static CMsgVector2D_x_acc: CMsgVector2D_x_acc_type = CMsgVector2D_x_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgVector2D> for CMsgVector2D_x_acc_type {
    fn name(&self) -> &'static str {
        "x"
    }

    fn has_field(&self, m: &CMsgVector2D) -> bool {
        m.has_x()
    }

    fn get_f32(&self, m: &CMsgVector2D) -> f32 {
        m.get_x()
    }
}

#[allow(non_camel_case_types)]
struct CMsgVector2D_y_acc_type;
static CMsgVector2D_y_acc: CMsgVector2D_y_acc_type = CMsgVector2D_y_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgVector2D> for CMsgVector2D_y_acc_type {
    fn name(&self) -> &'static str {
        "y"
    }

    fn has_field(&self, m: &CMsgVector2D) -> bool {
        m.has_y()
    }

    fn get_f32(&self, m: &CMsgVector2D) -> f32 {
        m.get_y()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CMsgQAngle {
    x: Option<f32>,
    y: Option<f32>,
    z: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CMsgQAngle {
    pub fn new() -> CMsgQAngle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgQAngle {
        static mut instance: ::protobuf::lazy::Lazy<CMsgQAngle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CMsgQAngle };
        unsafe {
            instance.get(|| {
                CMsgQAngle {
                    x: None,
                    y: None,
                    z: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_x(&mut self) {
        self.x = None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&'a mut self) -> &'a mut f32 {
        if self.x.is_none() {
            self.x = Some(0.);
        };
        self.x.as_mut().unwrap()
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or_else(|| 0.)
    }

    pub fn clear_y(&mut self) {
        self.y = None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&'a mut self) -> &'a mut f32 {
        if self.y.is_none() {
            self.y = Some(0.);
        };
        self.y.as_mut().unwrap()
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or_else(|| 0.)
    }

    pub fn clear_z(&mut self) {
        self.z = None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_z(&'a mut self) -> &'a mut f32 {
        if self.z.is_none() {
            self.z = Some(0.);
        };
        self.z.as_mut().unwrap()
    }

    pub fn get_z(&self) -> f32 {
        self.z.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CMsgQAngle {
    fn new() -> CMsgQAngle {
        CMsgQAngle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.x = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.y = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.z = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.x.is_some() {
            my_size += 5;
        };
        if self.y.is_some() {
            my_size += 5;
        };
        if self.z.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.x {
            Some(ref v) => {
                os.write_float(1, *v);
            },
            None => {},
        };
        match self.y {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        match self.z {
            Some(ref v) => {
                os.write_float(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CMsgQAngle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CMsgQAngle>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CMsgQAngle_x_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgQAngle>) });
                fields.push(unsafe { ::std::mem::transmute(&CMsgQAngle_y_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgQAngle>) });
                fields.push(unsafe { ::std::mem::transmute(&CMsgQAngle_z_acc as &'static ::protobuf::reflect::FieldAccessor<CMsgQAngle>) });
                ::protobuf::reflect::MessageDescriptor::new::<CMsgQAngle>(
                    "CMsgQAngle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CMsgQAngle>()
    }
}

impl ::protobuf::Clear for CMsgQAngle {
    fn clear(&mut self) {
        self.clear_x();
        self.clear_y();
        self.clear_z();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CMsgQAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CMsgQAngle_x_acc_type;
static CMsgQAngle_x_acc: CMsgQAngle_x_acc_type = CMsgQAngle_x_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgQAngle> for CMsgQAngle_x_acc_type {
    fn name(&self) -> &'static str {
        "x"
    }

    fn has_field(&self, m: &CMsgQAngle) -> bool {
        m.has_x()
    }

    fn get_f32(&self, m: &CMsgQAngle) -> f32 {
        m.get_x()
    }
}

#[allow(non_camel_case_types)]
struct CMsgQAngle_y_acc_type;
static CMsgQAngle_y_acc: CMsgQAngle_y_acc_type = CMsgQAngle_y_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgQAngle> for CMsgQAngle_y_acc_type {
    fn name(&self) -> &'static str {
        "y"
    }

    fn has_field(&self, m: &CMsgQAngle) -> bool {
        m.has_y()
    }

    fn get_f32(&self, m: &CMsgQAngle) -> f32 {
        m.get_y()
    }
}

#[allow(non_camel_case_types)]
struct CMsgQAngle_z_acc_type;
static CMsgQAngle_z_acc: CMsgQAngle_z_acc_type = CMsgQAngle_z_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsgQAngle> for CMsgQAngle_z_acc_type {
    fn name(&self) -> &'static str {
        "z"
    }

    fn has_field(&self, m: &CMsgQAngle) -> bool {
        m.has_z()
    }

    fn get_f32(&self, m: &CMsgQAngle) -> f32 {
        m.get_z()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CMsg_CVars {
    cvars: ::protobuf::RepeatedField<CMsg_CVars_CVar>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CMsg_CVars {
    pub fn new() -> CMsg_CVars {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsg_CVars {
        static mut instance: ::protobuf::lazy::Lazy<CMsg_CVars> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CMsg_CVars };
        unsafe {
            instance.get(|| {
                CMsg_CVars {
                    cvars: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_cvars(&mut self) {
        self.cvars.clear();
    }

    // Param is passed by value, moved
    pub fn set_cvars(&mut self, v: ::protobuf::RepeatedField<CMsg_CVars_CVar>) {
        self.cvars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cvars(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsg_CVars_CVar> {
        &mut self.cvars
    }

    pub fn get_cvars(&'a self) -> &'a [CMsg_CVars_CVar] {
        self.cvars.as_slice()
    }

    pub fn add_cvars(&mut self, v: CMsg_CVars_CVar) {
        self.cvars.push(v);
    }
}

impl ::protobuf::Message for CMsg_CVars {
    fn new() -> CMsg_CVars {
        CMsg_CVars::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.cvars.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.cvars.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.cvars.iter() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CMsg_CVars>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CMsg_CVars>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CMsg_CVars_cvars_acc as &'static ::protobuf::reflect::FieldAccessor<CMsg_CVars>) });
                ::protobuf::reflect::MessageDescriptor::new::<CMsg_CVars>(
                    "CMsg_CVars",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CMsg_CVars>()
    }
}

impl ::protobuf::Clear for CMsg_CVars {
    fn clear(&mut self) {
        self.clear_cvars();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CMsg_CVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CMsg_CVars_cvars_acc_type;
static CMsg_CVars_cvars_acc: CMsg_CVars_cvars_acc_type = CMsg_CVars_cvars_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsg_CVars> for CMsg_CVars_cvars_acc_type {
    fn name(&self) -> &'static str {
        "cvars"
    }

    fn len_field(&self, m: &CMsg_CVars) -> uint {
        m.get_cvars().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CMsg_CVars, index: uint) -> &'a ::protobuf::Message {
        &m.get_cvars()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CMsg_CVars_CVar {
    name: ::protobuf::SingularField<String>,
    value: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CMsg_CVars_CVar {
    pub fn new() -> CMsg_CVars_CVar {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsg_CVars_CVar {
        static mut instance: ::protobuf::lazy::Lazy<CMsg_CVars_CVar> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CMsg_CVars_CVar };
        unsafe {
            instance.get(|| {
                CMsg_CVars_CVar {
                    name: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&'a mut self) -> &'a mut String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    pub fn get_value(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsg_CVars_CVar {
    fn new() -> CMsg_CVars_CVar {
        CMsg_CVars_CVar::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.value.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.value.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CMsg_CVars_CVar>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CMsg_CVars_CVar>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CMsg_CVars_CVar_name_acc as &'static ::protobuf::reflect::FieldAccessor<CMsg_CVars_CVar>) });
                fields.push(unsafe { ::std::mem::transmute(&CMsg_CVars_CVar_value_acc as &'static ::protobuf::reflect::FieldAccessor<CMsg_CVars_CVar>) });
                ::protobuf::reflect::MessageDescriptor::new::<CMsg_CVars_CVar>(
                    "CMsg_CVars_CVar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CMsg_CVars_CVar>()
    }
}

impl ::protobuf::Clear for CMsg_CVars_CVar {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CMsg_CVars_CVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CMsg_CVars_CVar_name_acc_type;
static CMsg_CVars_CVar_name_acc: CMsg_CVars_CVar_name_acc_type = CMsg_CVars_CVar_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsg_CVars_CVar> for CMsg_CVars_CVar_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CMsg_CVars_CVar) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CMsg_CVars_CVar) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CMsg_CVars_CVar_value_acc_type;
static CMsg_CVars_CVar_value_acc: CMsg_CVars_CVar_value_acc_type = CMsg_CVars_CVar_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CMsg_CVars_CVar> for CMsg_CVars_CVar_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &CMsg_CVars_CVar) -> bool {
        m.has_value()
    }

    fn get_str<'a>(&self, m: &'a CMsg_CVars_CVar) -> &'a str {
        m.get_value()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_NOP {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_NOP {
    pub fn new() -> CNETMsg_NOP {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_NOP {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_NOP> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_NOP };
        unsafe {
            instance.get(|| {
                CNETMsg_NOP {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CNETMsg_NOP {
    fn new() -> CNETMsg_NOP {
        CNETMsg_NOP::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_NOP>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_NOP>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_NOP>(
                    "CNETMsg_NOP",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_NOP>()
    }
}

impl ::protobuf::Clear for CNETMsg_NOP {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_NOP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_Disconnect {
    text: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_Disconnect {
    pub fn new() -> CNETMsg_Disconnect {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_Disconnect {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_Disconnect> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_Disconnect };
        unsafe {
            instance.get(|| {
                CNETMsg_Disconnect {
                    text: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&'a mut self) -> &'a mut String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    pub fn get_text(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CNETMsg_Disconnect {
    fn new() -> CNETMsg_Disconnect {
        CNETMsg_Disconnect::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.text.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.text.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_Disconnect>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_Disconnect>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_Disconnect_text_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_Disconnect>) });
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_Disconnect>(
                    "CNETMsg_Disconnect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_Disconnect>()
    }
}

impl ::protobuf::Clear for CNETMsg_Disconnect {
    fn clear(&mut self) {
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_Disconnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CNETMsg_Disconnect_text_acc_type;
static CNETMsg_Disconnect_text_acc: CNETMsg_Disconnect_text_acc_type = CNETMsg_Disconnect_text_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_Disconnect> for CNETMsg_Disconnect_text_acc_type {
    fn name(&self) -> &'static str {
        "text"
    }

    fn has_field(&self, m: &CNETMsg_Disconnect) -> bool {
        m.has_text()
    }

    fn get_str<'a>(&self, m: &'a CNETMsg_Disconnect) -> &'a str {
        m.get_text()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_File {
    transfer_id: Option<i32>,
    file_name: ::protobuf::SingularField<String>,
    is_replay_demo_file: Option<bool>,
    deny: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_File {
    pub fn new() -> CNETMsg_File {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_File {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_File> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_File };
        unsafe {
            instance.get(|| {
                CNETMsg_File {
                    transfer_id: None,
                    file_name: ::protobuf::SingularField::none(),
                    is_replay_demo_file: None,
                    deny: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_transfer_id(&mut self) {
        self.transfer_id = None;
    }

    pub fn has_transfer_id(&self) -> bool {
        self.transfer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transfer_id(&mut self, v: i32) {
        self.transfer_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transfer_id(&'a mut self) -> &'a mut i32 {
        if self.transfer_id.is_none() {
            self.transfer_id = Some(0);
        };
        self.transfer_id.as_mut().unwrap()
    }

    pub fn get_transfer_id(&self) -> i32 {
        self.transfer_id.unwrap_or_else(|| 0)
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&'a mut self) -> &'a mut String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    pub fn get_file_name(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_is_replay_demo_file(&mut self) {
        self.is_replay_demo_file = None;
    }

    pub fn has_is_replay_demo_file(&self) -> bool {
        self.is_replay_demo_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay_demo_file(&mut self, v: bool) {
        self.is_replay_demo_file = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_replay_demo_file(&'a mut self) -> &'a mut bool {
        if self.is_replay_demo_file.is_none() {
            self.is_replay_demo_file = Some(false);
        };
        self.is_replay_demo_file.as_mut().unwrap()
    }

    pub fn get_is_replay_demo_file(&self) -> bool {
        self.is_replay_demo_file.unwrap_or_else(|| false)
    }

    pub fn clear_deny(&mut self) {
        self.deny = None;
    }

    pub fn has_deny(&self) -> bool {
        self.deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny(&mut self, v: bool) {
        self.deny = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny(&'a mut self) -> &'a mut bool {
        if self.deny.is_none() {
            self.deny = Some(false);
        };
        self.deny.as_mut().unwrap()
    }

    pub fn get_deny(&self) -> bool {
        self.deny.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CNETMsg_File {
    fn new() -> CNETMsg_File {
        CNETMsg_File::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.transfer_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.file_name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_replay_demo_file = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.deny = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.transfer_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        if self.is_replay_demo_file.is_some() {
            my_size += 2;
        };
        if self.deny.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.transfer_id {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.file_name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.is_replay_demo_file {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        match self.deny {
            Some(ref v) => {
                os.write_bool(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_File>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_File>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_File_transfer_id_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_File>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_File_file_name_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_File>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_File_is_replay_demo_file_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_File>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_File_deny_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_File>) });
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_File>(
                    "CNETMsg_File",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_File>()
    }
}

impl ::protobuf::Clear for CNETMsg_File {
    fn clear(&mut self) {
        self.clear_transfer_id();
        self.clear_file_name();
        self.clear_is_replay_demo_file();
        self.clear_deny();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CNETMsg_File_transfer_id_acc_type;
static CNETMsg_File_transfer_id_acc: CNETMsg_File_transfer_id_acc_type = CNETMsg_File_transfer_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_File> for CNETMsg_File_transfer_id_acc_type {
    fn name(&self) -> &'static str {
        "transfer_id"
    }

    fn has_field(&self, m: &CNETMsg_File) -> bool {
        m.has_transfer_id()
    }

    fn get_i32(&self, m: &CNETMsg_File) -> i32 {
        m.get_transfer_id()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_File_file_name_acc_type;
static CNETMsg_File_file_name_acc: CNETMsg_File_file_name_acc_type = CNETMsg_File_file_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_File> for CNETMsg_File_file_name_acc_type {
    fn name(&self) -> &'static str {
        "file_name"
    }

    fn has_field(&self, m: &CNETMsg_File) -> bool {
        m.has_file_name()
    }

    fn get_str<'a>(&self, m: &'a CNETMsg_File) -> &'a str {
        m.get_file_name()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_File_is_replay_demo_file_acc_type;
static CNETMsg_File_is_replay_demo_file_acc: CNETMsg_File_is_replay_demo_file_acc_type = CNETMsg_File_is_replay_demo_file_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_File> for CNETMsg_File_is_replay_demo_file_acc_type {
    fn name(&self) -> &'static str {
        "is_replay_demo_file"
    }

    fn has_field(&self, m: &CNETMsg_File) -> bool {
        m.has_is_replay_demo_file()
    }

    fn get_bool(&self, m: &CNETMsg_File) -> bool {
        m.get_is_replay_demo_file()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_File_deny_acc_type;
static CNETMsg_File_deny_acc: CNETMsg_File_deny_acc_type = CNETMsg_File_deny_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_File> for CNETMsg_File_deny_acc_type {
    fn name(&self) -> &'static str {
        "deny"
    }

    fn has_field(&self, m: &CNETMsg_File) -> bool {
        m.has_deny()
    }

    fn get_bool(&self, m: &CNETMsg_File) -> bool {
        m.get_deny()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_SplitScreenUser {
    slot: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_SplitScreenUser {
    pub fn new() -> CNETMsg_SplitScreenUser {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_SplitScreenUser {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_SplitScreenUser> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_SplitScreenUser };
        unsafe {
            instance.get(|| {
                CNETMsg_SplitScreenUser {
                    slot: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_slot(&mut self) {
        self.slot = None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot(&'a mut self) -> &'a mut i32 {
        if self.slot.is_none() {
            self.slot = Some(0);
        };
        self.slot.as_mut().unwrap()
    }

    pub fn get_slot(&self) -> i32 {
        self.slot.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CNETMsg_SplitScreenUser {
    fn new() -> CNETMsg_SplitScreenUser {
        CNETMsg_SplitScreenUser::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.slot = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.slot.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.slot {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_SplitScreenUser>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_SplitScreenUser>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_SplitScreenUser_slot_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_SplitScreenUser>) });
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_SplitScreenUser>(
                    "CNETMsg_SplitScreenUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_SplitScreenUser>()
    }
}

impl ::protobuf::Clear for CNETMsg_SplitScreenUser {
    fn clear(&mut self) {
        self.clear_slot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_SplitScreenUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CNETMsg_SplitScreenUser_slot_acc_type;
static CNETMsg_SplitScreenUser_slot_acc: CNETMsg_SplitScreenUser_slot_acc_type = CNETMsg_SplitScreenUser_slot_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_SplitScreenUser> for CNETMsg_SplitScreenUser_slot_acc_type {
    fn name(&self) -> &'static str {
        "slot"
    }

    fn has_field(&self, m: &CNETMsg_SplitScreenUser) -> bool {
        m.has_slot()
    }

    fn get_i32(&self, m: &CNETMsg_SplitScreenUser) -> i32 {
        m.get_slot()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_Tick {
    tick: Option<u32>,
    host_frametime: Option<u32>,
    host_frametime_std_deviation: Option<u32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_Tick {
    pub fn new() -> CNETMsg_Tick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_Tick {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_Tick> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_Tick };
        unsafe {
            instance.get(|| {
                CNETMsg_Tick {
                    tick: None,
                    host_frametime: None,
                    host_frametime_std_deviation: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_tick(&mut self) {
        self.tick = None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tick(&'a mut self) -> &'a mut u32 {
        if self.tick.is_none() {
            self.tick = Some(0);
        };
        self.tick.as_mut().unwrap()
    }

    pub fn get_tick(&self) -> u32 {
        self.tick.unwrap_or_else(|| 0)
    }

    pub fn clear_host_frametime(&mut self) {
        self.host_frametime = None;
    }

    pub fn has_host_frametime(&self) -> bool {
        self.host_frametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_frametime(&mut self, v: u32) {
        self.host_frametime = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_frametime(&'a mut self) -> &'a mut u32 {
        if self.host_frametime.is_none() {
            self.host_frametime = Some(0);
        };
        self.host_frametime.as_mut().unwrap()
    }

    pub fn get_host_frametime(&self) -> u32 {
        self.host_frametime.unwrap_or_else(|| 0)
    }

    pub fn clear_host_frametime_std_deviation(&mut self) {
        self.host_frametime_std_deviation = None;
    }

    pub fn has_host_frametime_std_deviation(&self) -> bool {
        self.host_frametime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_frametime_std_deviation(&mut self, v: u32) {
        self.host_frametime_std_deviation = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_frametime_std_deviation(&'a mut self) -> &'a mut u32 {
        if self.host_frametime_std_deviation.is_none() {
            self.host_frametime_std_deviation = Some(0);
        };
        self.host_frametime_std_deviation.as_mut().unwrap()
    }

    pub fn get_host_frametime_std_deviation(&self) -> u32 {
        self.host_frametime_std_deviation.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CNETMsg_Tick {
    fn new() -> CNETMsg_Tick {
        CNETMsg_Tick::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.tick = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.host_frametime = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.host_frametime_std_deviation = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.tick.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.host_frametime.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.host_frametime_std_deviation.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.tick {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.host_frametime {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.host_frametime_std_deviation {
            Some(ref v) => {
                os.write_uint32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_Tick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_Tick>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_Tick_tick_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_Tick>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_Tick_host_frametime_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_Tick>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_Tick_host_frametime_std_deviation_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_Tick>) });
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_Tick>(
                    "CNETMsg_Tick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_Tick>()
    }
}

impl ::protobuf::Clear for CNETMsg_Tick {
    fn clear(&mut self) {
        self.clear_tick();
        self.clear_host_frametime();
        self.clear_host_frametime_std_deviation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_Tick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CNETMsg_Tick_tick_acc_type;
static CNETMsg_Tick_tick_acc: CNETMsg_Tick_tick_acc_type = CNETMsg_Tick_tick_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_Tick> for CNETMsg_Tick_tick_acc_type {
    fn name(&self) -> &'static str {
        "tick"
    }

    fn has_field(&self, m: &CNETMsg_Tick) -> bool {
        m.has_tick()
    }

    fn get_u32(&self, m: &CNETMsg_Tick) -> u32 {
        m.get_tick()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_Tick_host_frametime_acc_type;
static CNETMsg_Tick_host_frametime_acc: CNETMsg_Tick_host_frametime_acc_type = CNETMsg_Tick_host_frametime_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_Tick> for CNETMsg_Tick_host_frametime_acc_type {
    fn name(&self) -> &'static str {
        "host_frametime"
    }

    fn has_field(&self, m: &CNETMsg_Tick) -> bool {
        m.has_host_frametime()
    }

    fn get_u32(&self, m: &CNETMsg_Tick) -> u32 {
        m.get_host_frametime()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_Tick_host_frametime_std_deviation_acc_type;
static CNETMsg_Tick_host_frametime_std_deviation_acc: CNETMsg_Tick_host_frametime_std_deviation_acc_type = CNETMsg_Tick_host_frametime_std_deviation_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_Tick> for CNETMsg_Tick_host_frametime_std_deviation_acc_type {
    fn name(&self) -> &'static str {
        "host_frametime_std_deviation"
    }

    fn has_field(&self, m: &CNETMsg_Tick) -> bool {
        m.has_host_frametime_std_deviation()
    }

    fn get_u32(&self, m: &CNETMsg_Tick) -> u32 {
        m.get_host_frametime_std_deviation()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_StringCmd {
    command: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_StringCmd {
    pub fn new() -> CNETMsg_StringCmd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_StringCmd {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_StringCmd> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_StringCmd };
        unsafe {
            instance.get(|| {
                CNETMsg_StringCmd {
                    command: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: String) {
        self.command = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&'a mut self) -> &'a mut String {
        if self.command.is_none() {
            self.command.set_default();
        };
        self.command.as_mut().unwrap()
    }

    pub fn get_command(&'a self) -> &'a str {
        match self.command.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CNETMsg_StringCmd {
    fn new() -> CNETMsg_StringCmd {
        CNETMsg_StringCmd::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.command.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.command.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.command.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_StringCmd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_StringCmd>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_StringCmd_command_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_StringCmd>) });
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_StringCmd>(
                    "CNETMsg_StringCmd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_StringCmd>()
    }
}

impl ::protobuf::Clear for CNETMsg_StringCmd {
    fn clear(&mut self) {
        self.clear_command();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_StringCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CNETMsg_StringCmd_command_acc_type;
static CNETMsg_StringCmd_command_acc: CNETMsg_StringCmd_command_acc_type = CNETMsg_StringCmd_command_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_StringCmd> for CNETMsg_StringCmd_command_acc_type {
    fn name(&self) -> &'static str {
        "command"
    }

    fn has_field(&self, m: &CNETMsg_StringCmd) -> bool {
        m.has_command()
    }

    fn get_str<'a>(&self, m: &'a CNETMsg_StringCmd) -> &'a str {
        m.get_command()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_SetConVar {
    convars: ::protobuf::SingularPtrField<CMsg_CVars>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_SetConVar {
    pub fn new() -> CNETMsg_SetConVar {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_SetConVar {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_SetConVar> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_SetConVar };
        unsafe {
            instance.get(|| {
                CNETMsg_SetConVar {
                    convars: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_convars(&mut self) {
        self.convars.clear();
    }

    pub fn has_convars(&self) -> bool {
        self.convars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convars(&mut self, v: CMsg_CVars) {
        self.convars = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convars(&'a mut self) -> &'a mut CMsg_CVars {
        if self.convars.is_none() {
            self.convars.set_default();
        };
        self.convars.as_mut().unwrap()
    }

    pub fn get_convars(&'a self) -> &'a CMsg_CVars {
        self.convars.as_ref().unwrap_or_else(|| CMsg_CVars::default_instance())
    }
}

impl ::protobuf::Message for CNETMsg_SetConVar {
    fn new() -> CNETMsg_SetConVar {
        CNETMsg_SetConVar::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.convars.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.convars.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.convars.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_SetConVar>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_SetConVar>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_SetConVar_convars_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_SetConVar>) });
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_SetConVar>(
                    "CNETMsg_SetConVar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_SetConVar>()
    }
}

impl ::protobuf::Clear for CNETMsg_SetConVar {
    fn clear(&mut self) {
        self.clear_convars();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_SetConVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CNETMsg_SetConVar_convars_acc_type;
static CNETMsg_SetConVar_convars_acc: CNETMsg_SetConVar_convars_acc_type = CNETMsg_SetConVar_convars_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_SetConVar> for CNETMsg_SetConVar_convars_acc_type {
    fn name(&self) -> &'static str {
        "convars"
    }

    fn has_field(&self, m: &CNETMsg_SetConVar) -> bool {
        m.has_convars()
    }

    fn get_message<'a>(&self, m: &'a CNETMsg_SetConVar) -> &'a ::protobuf::Message {
        m.get_convars() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CNETMsg_SignonState {
    signon_state: Option<u32>,
    spawn_count: Option<u32>,
    num_server_players: Option<u32>,
    players_networkids: ::protobuf::RepeatedField<String>,
    map_name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CNETMsg_SignonState {
    pub fn new() -> CNETMsg_SignonState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNETMsg_SignonState {
        static mut instance: ::protobuf::lazy::Lazy<CNETMsg_SignonState> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CNETMsg_SignonState };
        unsafe {
            instance.get(|| {
                CNETMsg_SignonState {
                    signon_state: None,
                    spawn_count: None,
                    num_server_players: None,
                    players_networkids: ::protobuf::RepeatedField::new(),
                    map_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_signon_state(&mut self) {
        self.signon_state = None;
    }

    pub fn has_signon_state(&self) -> bool {
        self.signon_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signon_state(&mut self, v: u32) {
        self.signon_state = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signon_state(&'a mut self) -> &'a mut u32 {
        if self.signon_state.is_none() {
            self.signon_state = Some(0);
        };
        self.signon_state.as_mut().unwrap()
    }

    pub fn get_signon_state(&self) -> u32 {
        self.signon_state.unwrap_or_else(|| 0)
    }

    pub fn clear_spawn_count(&mut self) {
        self.spawn_count = None;
    }

    pub fn has_spawn_count(&self) -> bool {
        self.spawn_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_count(&mut self, v: u32) {
        self.spawn_count = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spawn_count(&'a mut self) -> &'a mut u32 {
        if self.spawn_count.is_none() {
            self.spawn_count = Some(0);
        };
        self.spawn_count.as_mut().unwrap()
    }

    pub fn get_spawn_count(&self) -> u32 {
        self.spawn_count.unwrap_or_else(|| 0)
    }

    pub fn clear_num_server_players(&mut self) {
        self.num_server_players = None;
    }

    pub fn has_num_server_players(&self) -> bool {
        self.num_server_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_server_players(&mut self, v: u32) {
        self.num_server_players = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_server_players(&'a mut self) -> &'a mut u32 {
        if self.num_server_players.is_none() {
            self.num_server_players = Some(0);
        };
        self.num_server_players.as_mut().unwrap()
    }

    pub fn get_num_server_players(&self) -> u32 {
        self.num_server_players.unwrap_or_else(|| 0)
    }

    pub fn clear_players_networkids(&mut self) {
        self.players_networkids.clear();
    }

    // Param is passed by value, moved
    pub fn set_players_networkids(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.players_networkids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players_networkids(&'a mut self) -> &'a mut ::protobuf::RepeatedField<String> {
        &mut self.players_networkids
    }

    pub fn get_players_networkids(&'a self) -> &'a [String] {
        self.players_networkids.as_slice()
    }

    pub fn add_players_networkids(&mut self, v: String) {
        self.players_networkids.push(v);
    }

    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&'a mut self) -> &'a mut String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        };
        self.map_name.as_mut().unwrap()
    }

    pub fn get_map_name(&'a self) -> &'a str {
        match self.map_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CNETMsg_SignonState {
    fn new() -> CNETMsg_SignonState {
        CNETMsg_SignonState::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.signon_state = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.spawn_count = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.num_server_players = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.players_networkids.push_default();
                    is.read_string_into(tmp)
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.map_name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.signon_state.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.spawn_count.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_server_players.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.players_networkids.iter() {
            my_size += ::protobuf::rt::string_size(4, value.as_slice());
        };
        for value in self.map_name.iter() {
            my_size += ::protobuf::rt::string_size(5, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.signon_state {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.spawn_count {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.num_server_players {
            Some(ref v) => {
                os.write_uint32(3, *v);
            },
            None => {},
        };
        for v in self.players_networkids.iter() {
            os.write_string(4, v.as_slice());
        };
        match self.map_name.as_ref() {
            Some(ref v) => {
                os.write_string(5, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CNETMsg_SignonState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_SignonState_signon_state_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_SignonState_spawn_count_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_SignonState_num_server_players_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_SignonState_players_networkids_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState>) });
                fields.push(unsafe { ::std::mem::transmute(&CNETMsg_SignonState_map_name_acc as &'static ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState>) });
                ::protobuf::reflect::MessageDescriptor::new::<CNETMsg_SignonState>(
                    "CNETMsg_SignonState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CNETMsg_SignonState>()
    }
}

impl ::protobuf::Clear for CNETMsg_SignonState {
    fn clear(&mut self) {
        self.clear_signon_state();
        self.clear_spawn_count();
        self.clear_num_server_players();
        self.clear_players_networkids();
        self.clear_map_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CNETMsg_SignonState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CNETMsg_SignonState_signon_state_acc_type;
static CNETMsg_SignonState_signon_state_acc: CNETMsg_SignonState_signon_state_acc_type = CNETMsg_SignonState_signon_state_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState> for CNETMsg_SignonState_signon_state_acc_type {
    fn name(&self) -> &'static str {
        "signon_state"
    }

    fn has_field(&self, m: &CNETMsg_SignonState) -> bool {
        m.has_signon_state()
    }

    fn get_u32(&self, m: &CNETMsg_SignonState) -> u32 {
        m.get_signon_state()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_SignonState_spawn_count_acc_type;
static CNETMsg_SignonState_spawn_count_acc: CNETMsg_SignonState_spawn_count_acc_type = CNETMsg_SignonState_spawn_count_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState> for CNETMsg_SignonState_spawn_count_acc_type {
    fn name(&self) -> &'static str {
        "spawn_count"
    }

    fn has_field(&self, m: &CNETMsg_SignonState) -> bool {
        m.has_spawn_count()
    }

    fn get_u32(&self, m: &CNETMsg_SignonState) -> u32 {
        m.get_spawn_count()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_SignonState_num_server_players_acc_type;
static CNETMsg_SignonState_num_server_players_acc: CNETMsg_SignonState_num_server_players_acc_type = CNETMsg_SignonState_num_server_players_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState> for CNETMsg_SignonState_num_server_players_acc_type {
    fn name(&self) -> &'static str {
        "num_server_players"
    }

    fn has_field(&self, m: &CNETMsg_SignonState) -> bool {
        m.has_num_server_players()
    }

    fn get_u32(&self, m: &CNETMsg_SignonState) -> u32 {
        m.get_num_server_players()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_SignonState_players_networkids_acc_type;
static CNETMsg_SignonState_players_networkids_acc: CNETMsg_SignonState_players_networkids_acc_type = CNETMsg_SignonState_players_networkids_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState> for CNETMsg_SignonState_players_networkids_acc_type {
    fn name(&self) -> &'static str {
        "players_networkids"
    }

    fn len_field(&self, m: &CNETMsg_SignonState) -> uint {
        m.get_players_networkids().len()
    }

    fn get_rep_str<'a>(&self, m: &'a CNETMsg_SignonState) -> &'a [String] {
        m.get_players_networkids()
    }
}

#[allow(non_camel_case_types)]
struct CNETMsg_SignonState_map_name_acc_type;
static CNETMsg_SignonState_map_name_acc: CNETMsg_SignonState_map_name_acc_type = CNETMsg_SignonState_map_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CNETMsg_SignonState> for CNETMsg_SignonState_map_name_acc_type {
    fn name(&self) -> &'static str {
        "map_name"
    }

    fn has_field(&self, m: &CNETMsg_SignonState) -> bool {
        m.has_map_name()
    }

    fn get_str<'a>(&self, m: &'a CNETMsg_SignonState) -> &'a str {
        m.get_map_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_ClientInfo {
    send_table_crc: Option<u32>,
    server_count: Option<u32>,
    is_hltv: Option<bool>,
    is_replay: Option<bool>,
    friends_id: Option<u32>,
    friends_name: ::protobuf::SingularField<String>,
    custom_files: Vec<u32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_ClientInfo {
    pub fn new() -> CCLCMsg_ClientInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_ClientInfo {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_ClientInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_ClientInfo };
        unsafe {
            instance.get(|| {
                CCLCMsg_ClientInfo {
                    send_table_crc: None,
                    server_count: None,
                    is_hltv: None,
                    is_replay: None,
                    friends_id: None,
                    friends_name: ::protobuf::SingularField::none(),
                    custom_files: Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_send_table_crc(&mut self) {
        self.send_table_crc = None;
    }

    pub fn has_send_table_crc(&self) -> bool {
        self.send_table_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_table_crc(&mut self, v: u32) {
        self.send_table_crc = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send_table_crc(&'a mut self) -> &'a mut u32 {
        if self.send_table_crc.is_none() {
            self.send_table_crc = Some(0);
        };
        self.send_table_crc.as_mut().unwrap()
    }

    pub fn get_send_table_crc(&self) -> u32 {
        self.send_table_crc.unwrap_or_else(|| 0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: u32) {
        self.server_count = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_count(&'a mut self) -> &'a mut u32 {
        if self.server_count.is_none() {
            self.server_count = Some(0);
        };
        self.server_count.as_mut().unwrap()
    }

    pub fn get_server_count(&self) -> u32 {
        self.server_count.unwrap_or_else(|| 0)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_hltv(&'a mut self) -> &'a mut bool {
        if self.is_hltv.is_none() {
            self.is_hltv = Some(false);
        };
        self.is_hltv.as_mut().unwrap()
    }

    pub fn get_is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or_else(|| false)
    }

    pub fn clear_is_replay(&mut self) {
        self.is_replay = None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_replay(&'a mut self) -> &'a mut bool {
        if self.is_replay.is_none() {
            self.is_replay = Some(false);
        };
        self.is_replay.as_mut().unwrap()
    }

    pub fn get_is_replay(&self) -> bool {
        self.is_replay.unwrap_or_else(|| false)
    }

    pub fn clear_friends_id(&mut self) {
        self.friends_id = None;
    }

    pub fn has_friends_id(&self) -> bool {
        self.friends_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_id(&mut self, v: u32) {
        self.friends_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friends_id(&'a mut self) -> &'a mut u32 {
        if self.friends_id.is_none() {
            self.friends_id = Some(0);
        };
        self.friends_id.as_mut().unwrap()
    }

    pub fn get_friends_id(&self) -> u32 {
        self.friends_id.unwrap_or_else(|| 0)
    }

    pub fn clear_friends_name(&mut self) {
        self.friends_name.clear();
    }

    pub fn has_friends_name(&self) -> bool {
        self.friends_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_name(&mut self, v: String) {
        self.friends_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friends_name(&'a mut self) -> &'a mut String {
        if self.friends_name.is_none() {
            self.friends_name.set_default();
        };
        self.friends_name.as_mut().unwrap()
    }

    pub fn get_friends_name(&'a self) -> &'a str {
        match self.friends_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_custom_files(&mut self) {
        self.custom_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_files(&mut self, v: Vec<u32>) {
        self.custom_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_files(&'a mut self) -> &'a mut Vec<u32> {
        &mut self.custom_files
    }

    pub fn get_custom_files(&'a self) -> &'a [u32] {
        self.custom_files.as_slice()
    }

    pub fn add_custom_files(&mut self, v: u32) {
        self.custom_files.push(v);
    }
}

impl ::protobuf::Message for CCLCMsg_ClientInfo {
    fn new() -> CCLCMsg_ClientInfo {
        CCLCMsg_ClientInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.send_table_crc = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.server_count = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_hltv = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_replay = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.friends_id = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.friends_name.set_default();
                    is.read_string_into(tmp)
                },
                7 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = is.read_raw_varint32();
                        let old_limit = is.push_limit(len);
                        while !is.eof() {
                            self.custom_files.push(is.read_fixed32());
                        }
                        is.pop_limit(old_limit);
                    } else {
                        assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                        self.custom_files.push(is.read_fixed32());
                    }
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.send_table_crc.is_some() {
            my_size += 5;
        };
        for value in self.server_count.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_hltv.is_some() {
            my_size += 2;
        };
        if self.is_replay.is_some() {
            my_size += 2;
        };
        for value in self.friends_id.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.friends_name.iter() {
            my_size += ::protobuf::rt::string_size(6, value.as_slice());
        };
        my_size += 5 * self.custom_files.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.send_table_crc {
            Some(ref v) => {
                os.write_fixed32(1, *v);
            },
            None => {},
        };
        match self.server_count {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.is_hltv {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        match self.is_replay {
            Some(ref v) => {
                os.write_bool(4, *v);
            },
            None => {},
        };
        match self.friends_id {
            Some(ref v) => {
                os.write_uint32(5, *v);
            },
            None => {},
        };
        match self.friends_name.as_ref() {
            Some(ref v) => {
                os.write_string(6, v.as_slice());
            },
            None => {},
        };
        for v in self.custom_files.iter() {
            os.write_fixed32(7, *v);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_ClientInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientInfo_send_table_crc_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientInfo_server_count_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientInfo_is_hltv_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientInfo_is_replay_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientInfo_friends_id_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientInfo_friends_name_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientInfo_custom_files_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_ClientInfo>(
                    "CCLCMsg_ClientInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_ClientInfo>()
    }
}

impl ::protobuf::Clear for CCLCMsg_ClientInfo {
    fn clear(&mut self) {
        self.clear_send_table_crc();
        self.clear_server_count();
        self.clear_is_hltv();
        self.clear_is_replay();
        self.clear_friends_id();
        self.clear_friends_name();
        self.clear_custom_files();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_ClientInfo_send_table_crc_acc_type;
static CCLCMsg_ClientInfo_send_table_crc_acc: CCLCMsg_ClientInfo_send_table_crc_acc_type = CCLCMsg_ClientInfo_send_table_crc_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo> for CCLCMsg_ClientInfo_send_table_crc_acc_type {
    fn name(&self) -> &'static str {
        "send_table_crc"
    }

    fn has_field(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.has_send_table_crc()
    }

    fn get_u32(&self, m: &CCLCMsg_ClientInfo) -> u32 {
        m.get_send_table_crc()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_ClientInfo_server_count_acc_type;
static CCLCMsg_ClientInfo_server_count_acc: CCLCMsg_ClientInfo_server_count_acc_type = CCLCMsg_ClientInfo_server_count_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo> for CCLCMsg_ClientInfo_server_count_acc_type {
    fn name(&self) -> &'static str {
        "server_count"
    }

    fn has_field(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.has_server_count()
    }

    fn get_u32(&self, m: &CCLCMsg_ClientInfo) -> u32 {
        m.get_server_count()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_ClientInfo_is_hltv_acc_type;
static CCLCMsg_ClientInfo_is_hltv_acc: CCLCMsg_ClientInfo_is_hltv_acc_type = CCLCMsg_ClientInfo_is_hltv_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo> for CCLCMsg_ClientInfo_is_hltv_acc_type {
    fn name(&self) -> &'static str {
        "is_hltv"
    }

    fn has_field(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.has_is_hltv()
    }

    fn get_bool(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.get_is_hltv()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_ClientInfo_is_replay_acc_type;
static CCLCMsg_ClientInfo_is_replay_acc: CCLCMsg_ClientInfo_is_replay_acc_type = CCLCMsg_ClientInfo_is_replay_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo> for CCLCMsg_ClientInfo_is_replay_acc_type {
    fn name(&self) -> &'static str {
        "is_replay"
    }

    fn has_field(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.has_is_replay()
    }

    fn get_bool(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.get_is_replay()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_ClientInfo_friends_id_acc_type;
static CCLCMsg_ClientInfo_friends_id_acc: CCLCMsg_ClientInfo_friends_id_acc_type = CCLCMsg_ClientInfo_friends_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo> for CCLCMsg_ClientInfo_friends_id_acc_type {
    fn name(&self) -> &'static str {
        "friends_id"
    }

    fn has_field(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.has_friends_id()
    }

    fn get_u32(&self, m: &CCLCMsg_ClientInfo) -> u32 {
        m.get_friends_id()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_ClientInfo_friends_name_acc_type;
static CCLCMsg_ClientInfo_friends_name_acc: CCLCMsg_ClientInfo_friends_name_acc_type = CCLCMsg_ClientInfo_friends_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo> for CCLCMsg_ClientInfo_friends_name_acc_type {
    fn name(&self) -> &'static str {
        "friends_name"
    }

    fn has_field(&self, m: &CCLCMsg_ClientInfo) -> bool {
        m.has_friends_name()
    }

    fn get_str<'a>(&self, m: &'a CCLCMsg_ClientInfo) -> &'a str {
        m.get_friends_name()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_ClientInfo_custom_files_acc_type;
static CCLCMsg_ClientInfo_custom_files_acc: CCLCMsg_ClientInfo_custom_files_acc_type = CCLCMsg_ClientInfo_custom_files_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientInfo> for CCLCMsg_ClientInfo_custom_files_acc_type {
    fn name(&self) -> &'static str {
        "custom_files"
    }

    fn len_field(&self, m: &CCLCMsg_ClientInfo) -> uint {
        m.get_custom_files().len()
    }

    fn get_rep_u32<'a>(&self, m: &'a CCLCMsg_ClientInfo) -> &'a [u32] {
        m.get_custom_files()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_Move {
    num_backup_commands: Option<u32>,
    num_new_commands: Option<u32>,
    data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_Move {
    pub fn new() -> CCLCMsg_Move {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_Move {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_Move> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_Move };
        unsafe {
            instance.get(|| {
                CCLCMsg_Move {
                    num_backup_commands: None,
                    num_new_commands: None,
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_num_backup_commands(&mut self) {
        self.num_backup_commands = None;
    }

    pub fn has_num_backup_commands(&self) -> bool {
        self.num_backup_commands.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_backup_commands(&mut self, v: u32) {
        self.num_backup_commands = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_backup_commands(&'a mut self) -> &'a mut u32 {
        if self.num_backup_commands.is_none() {
            self.num_backup_commands = Some(0);
        };
        self.num_backup_commands.as_mut().unwrap()
    }

    pub fn get_num_backup_commands(&self) -> u32 {
        self.num_backup_commands.unwrap_or_else(|| 0)
    }

    pub fn clear_num_new_commands(&mut self) {
        self.num_new_commands = None;
    }

    pub fn has_num_new_commands(&self) -> bool {
        self.num_new_commands.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_new_commands(&mut self, v: u32) {
        self.num_new_commands = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_new_commands(&'a mut self) -> &'a mut u32 {
        if self.num_new_commands.is_none() {
            self.num_new_commands = Some(0);
        };
        self.num_new_commands.as_mut().unwrap()
    }

    pub fn get_num_new_commands(&self) -> u32 {
        self.num_new_commands.unwrap_or_else(|| 0)
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CCLCMsg_Move {
    fn new() -> CCLCMsg_Move {
        CCLCMsg_Move::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.num_backup_commands = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.num_new_commands = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.num_backup_commands.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_new_commands.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.num_backup_commands {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.num_new_commands {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_Move>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_Move>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_Move_num_backup_commands_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_Move>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_Move_num_new_commands_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_Move>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_Move_data_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_Move>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_Move>(
                    "CCLCMsg_Move",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_Move>()
    }
}

impl ::protobuf::Clear for CCLCMsg_Move {
    fn clear(&mut self) {
        self.clear_num_backup_commands();
        self.clear_num_new_commands();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_Move {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_Move_num_backup_commands_acc_type;
static CCLCMsg_Move_num_backup_commands_acc: CCLCMsg_Move_num_backup_commands_acc_type = CCLCMsg_Move_num_backup_commands_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_Move> for CCLCMsg_Move_num_backup_commands_acc_type {
    fn name(&self) -> &'static str {
        "num_backup_commands"
    }

    fn has_field(&self, m: &CCLCMsg_Move) -> bool {
        m.has_num_backup_commands()
    }

    fn get_u32(&self, m: &CCLCMsg_Move) -> u32 {
        m.get_num_backup_commands()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_Move_num_new_commands_acc_type;
static CCLCMsg_Move_num_new_commands_acc: CCLCMsg_Move_num_new_commands_acc_type = CCLCMsg_Move_num_new_commands_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_Move> for CCLCMsg_Move_num_new_commands_acc_type {
    fn name(&self) -> &'static str {
        "num_new_commands"
    }

    fn has_field(&self, m: &CCLCMsg_Move) -> bool {
        m.has_num_new_commands()
    }

    fn get_u32(&self, m: &CCLCMsg_Move) -> u32 {
        m.get_num_new_commands()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_Move_data_acc_type;
static CCLCMsg_Move_data_acc: CCLCMsg_Move_data_acc_type = CCLCMsg_Move_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_Move> for CCLCMsg_Move_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CCLCMsg_Move) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CCLCMsg_Move) -> &'a [u8] {
        m.get_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_VoiceData {
    data: ::protobuf::SingularField<Vec<u8>>,
    xuid: Option<u64>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_VoiceData {
    pub fn new() -> CCLCMsg_VoiceData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_VoiceData {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_VoiceData> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_VoiceData };
        unsafe {
            instance.get(|| {
                CCLCMsg_VoiceData {
                    data: ::protobuf::SingularField::none(),
                    xuid: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xuid(&'a mut self) -> &'a mut u64 {
        if self.xuid.is_none() {
            self.xuid = Some(0);
        };
        self.xuid.as_mut().unwrap()
    }

    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CCLCMsg_VoiceData {
    fn new() -> CCLCMsg_VoiceData {
        CCLCMsg_VoiceData::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed64, wire_type);
                    let tmp = is.read_fixed64();
                    self.xuid = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(1, value.as_slice());
        };
        if self.xuid.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(1, v.as_slice());
            },
            None => {},
        };
        match self.xuid {
            Some(ref v) => {
                os.write_fixed64(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_VoiceData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_VoiceData>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_VoiceData_data_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_VoiceData>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_VoiceData_xuid_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_VoiceData>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_VoiceData>(
                    "CCLCMsg_VoiceData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_VoiceData>()
    }
}

impl ::protobuf::Clear for CCLCMsg_VoiceData {
    fn clear(&mut self) {
        self.clear_data();
        self.clear_xuid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_VoiceData_data_acc_type;
static CCLCMsg_VoiceData_data_acc: CCLCMsg_VoiceData_data_acc_type = CCLCMsg_VoiceData_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_VoiceData> for CCLCMsg_VoiceData_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CCLCMsg_VoiceData) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CCLCMsg_VoiceData) -> &'a [u8] {
        m.get_data()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_VoiceData_xuid_acc_type;
static CCLCMsg_VoiceData_xuid_acc: CCLCMsg_VoiceData_xuid_acc_type = CCLCMsg_VoiceData_xuid_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_VoiceData> for CCLCMsg_VoiceData_xuid_acc_type {
    fn name(&self) -> &'static str {
        "xuid"
    }

    fn has_field(&self, m: &CCLCMsg_VoiceData) -> bool {
        m.has_xuid()
    }

    fn get_u64(&self, m: &CCLCMsg_VoiceData) -> u64 {
        m.get_xuid()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_BaselineAck {
    baseline_tick: Option<i32>,
    baseline_nr: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_BaselineAck {
    pub fn new() -> CCLCMsg_BaselineAck {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_BaselineAck {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_BaselineAck> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_BaselineAck };
        unsafe {
            instance.get(|| {
                CCLCMsg_BaselineAck {
                    baseline_tick: None,
                    baseline_nr: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_baseline_tick(&mut self) {
        self.baseline_tick = None;
    }

    pub fn has_baseline_tick(&self) -> bool {
        self.baseline_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_tick(&mut self, v: i32) {
        self.baseline_tick = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseline_tick(&'a mut self) -> &'a mut i32 {
        if self.baseline_tick.is_none() {
            self.baseline_tick = Some(0);
        };
        self.baseline_tick.as_mut().unwrap()
    }

    pub fn get_baseline_tick(&self) -> i32 {
        self.baseline_tick.unwrap_or_else(|| 0)
    }

    pub fn clear_baseline_nr(&mut self) {
        self.baseline_nr = None;
    }

    pub fn has_baseline_nr(&self) -> bool {
        self.baseline_nr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_nr(&mut self, v: i32) {
        self.baseline_nr = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseline_nr(&'a mut self) -> &'a mut i32 {
        if self.baseline_nr.is_none() {
            self.baseline_nr = Some(0);
        };
        self.baseline_nr.as_mut().unwrap()
    }

    pub fn get_baseline_nr(&self) -> i32 {
        self.baseline_nr.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CCLCMsg_BaselineAck {
    fn new() -> CCLCMsg_BaselineAck {
        CCLCMsg_BaselineAck::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.baseline_tick = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.baseline_nr = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.baseline_tick.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.baseline_nr.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.baseline_tick {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.baseline_nr {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_BaselineAck>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_BaselineAck>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_BaselineAck_baseline_tick_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_BaselineAck>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_BaselineAck_baseline_nr_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_BaselineAck>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_BaselineAck>(
                    "CCLCMsg_BaselineAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_BaselineAck>()
    }
}

impl ::protobuf::Clear for CCLCMsg_BaselineAck {
    fn clear(&mut self) {
        self.clear_baseline_tick();
        self.clear_baseline_nr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_BaselineAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_BaselineAck_baseline_tick_acc_type;
static CCLCMsg_BaselineAck_baseline_tick_acc: CCLCMsg_BaselineAck_baseline_tick_acc_type = CCLCMsg_BaselineAck_baseline_tick_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_BaselineAck> for CCLCMsg_BaselineAck_baseline_tick_acc_type {
    fn name(&self) -> &'static str {
        "baseline_tick"
    }

    fn has_field(&self, m: &CCLCMsg_BaselineAck) -> bool {
        m.has_baseline_tick()
    }

    fn get_i32(&self, m: &CCLCMsg_BaselineAck) -> i32 {
        m.get_baseline_tick()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_BaselineAck_baseline_nr_acc_type;
static CCLCMsg_BaselineAck_baseline_nr_acc: CCLCMsg_BaselineAck_baseline_nr_acc_type = CCLCMsg_BaselineAck_baseline_nr_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_BaselineAck> for CCLCMsg_BaselineAck_baseline_nr_acc_type {
    fn name(&self) -> &'static str {
        "baseline_nr"
    }

    fn has_field(&self, m: &CCLCMsg_BaselineAck) -> bool {
        m.has_baseline_nr()
    }

    fn get_i32(&self, m: &CCLCMsg_BaselineAck) -> i32 {
        m.get_baseline_nr()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_ListenEvents {
    event_mask: Vec<u32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_ListenEvents {
    pub fn new() -> CCLCMsg_ListenEvents {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_ListenEvents {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_ListenEvents> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_ListenEvents };
        unsafe {
            instance.get(|| {
                CCLCMsg_ListenEvents {
                    event_mask: Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_event_mask(&mut self) {
        self.event_mask.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_mask(&mut self, v: Vec<u32>) {
        self.event_mask = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_mask(&'a mut self) -> &'a mut Vec<u32> {
        &mut self.event_mask
    }

    pub fn get_event_mask(&'a self) -> &'a [u32] {
        self.event_mask.as_slice()
    }

    pub fn add_event_mask(&mut self, v: u32) {
        self.event_mask.push(v);
    }
}

impl ::protobuf::Message for CCLCMsg_ListenEvents {
    fn new() -> CCLCMsg_ListenEvents {
        CCLCMsg_ListenEvents::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = is.read_raw_varint32();
                        let old_limit = is.push_limit(len);
                        while !is.eof() {
                            self.event_mask.push(is.read_fixed32());
                        }
                        is.pop_limit(old_limit);
                    } else {
                        assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                        self.event_mask.push(is.read_fixed32());
                    }
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += 5 * self.event_mask.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.event_mask.iter() {
            os.write_fixed32(1, *v);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_ListenEvents>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ListenEvents>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ListenEvents_event_mask_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ListenEvents>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_ListenEvents>(
                    "CCLCMsg_ListenEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_ListenEvents>()
    }
}

impl ::protobuf::Clear for CCLCMsg_ListenEvents {
    fn clear(&mut self) {
        self.clear_event_mask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_ListenEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_ListenEvents_event_mask_acc_type;
static CCLCMsg_ListenEvents_event_mask_acc: CCLCMsg_ListenEvents_event_mask_acc_type = CCLCMsg_ListenEvents_event_mask_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ListenEvents> for CCLCMsg_ListenEvents_event_mask_acc_type {
    fn name(&self) -> &'static str {
        "event_mask"
    }

    fn len_field(&self, m: &CCLCMsg_ListenEvents) -> uint {
        m.get_event_mask().len()
    }

    fn get_rep_u32<'a>(&self, m: &'a CCLCMsg_ListenEvents) -> &'a [u32] {
        m.get_event_mask()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_RespondCvarValue {
    cookie: Option<i32>,
    status_code: Option<i32>,
    name: ::protobuf::SingularField<String>,
    value: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_RespondCvarValue {
    pub fn new() -> CCLCMsg_RespondCvarValue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_RespondCvarValue {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_RespondCvarValue> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_RespondCvarValue };
        unsafe {
            instance.get(|| {
                CCLCMsg_RespondCvarValue {
                    cookie: None,
                    status_code: None,
                    name: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&'a mut self) -> &'a mut i32 {
        if self.cookie.is_none() {
            self.cookie = Some(0);
        };
        self.cookie.as_mut().unwrap()
    }

    pub fn get_cookie(&self) -> i32 {
        self.cookie.unwrap_or_else(|| 0)
    }

    pub fn clear_status_code(&mut self) {
        self.status_code = None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_code(&'a mut self) -> &'a mut i32 {
        if self.status_code.is_none() {
            self.status_code = Some(0);
        };
        self.status_code.as_mut().unwrap()
    }

    pub fn get_status_code(&self) -> i32 {
        self.status_code.unwrap_or_else(|| 0)
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&'a mut self) -> &'a mut String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    pub fn get_value(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CCLCMsg_RespondCvarValue {
    fn new() -> CCLCMsg_RespondCvarValue {
        CCLCMsg_RespondCvarValue::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.cookie = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.status_code = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.value.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.cookie.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.status_code.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(4, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.cookie {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.status_code {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        match self.value.as_ref() {
            Some(ref v) => {
                os.write_string(4, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_RespondCvarValue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_RespondCvarValue_cookie_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_RespondCvarValue_status_code_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_RespondCvarValue_name_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_RespondCvarValue_value_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_RespondCvarValue>(
                    "CCLCMsg_RespondCvarValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_RespondCvarValue>()
    }
}

impl ::protobuf::Clear for CCLCMsg_RespondCvarValue {
    fn clear(&mut self) {
        self.clear_cookie();
        self.clear_status_code();
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_RespondCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_RespondCvarValue_cookie_acc_type;
static CCLCMsg_RespondCvarValue_cookie_acc: CCLCMsg_RespondCvarValue_cookie_acc_type = CCLCMsg_RespondCvarValue_cookie_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue> for CCLCMsg_RespondCvarValue_cookie_acc_type {
    fn name(&self) -> &'static str {
        "cookie"
    }

    fn has_field(&self, m: &CCLCMsg_RespondCvarValue) -> bool {
        m.has_cookie()
    }

    fn get_i32(&self, m: &CCLCMsg_RespondCvarValue) -> i32 {
        m.get_cookie()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_RespondCvarValue_status_code_acc_type;
static CCLCMsg_RespondCvarValue_status_code_acc: CCLCMsg_RespondCvarValue_status_code_acc_type = CCLCMsg_RespondCvarValue_status_code_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue> for CCLCMsg_RespondCvarValue_status_code_acc_type {
    fn name(&self) -> &'static str {
        "status_code"
    }

    fn has_field(&self, m: &CCLCMsg_RespondCvarValue) -> bool {
        m.has_status_code()
    }

    fn get_i32(&self, m: &CCLCMsg_RespondCvarValue) -> i32 {
        m.get_status_code()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_RespondCvarValue_name_acc_type;
static CCLCMsg_RespondCvarValue_name_acc: CCLCMsg_RespondCvarValue_name_acc_type = CCLCMsg_RespondCvarValue_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue> for CCLCMsg_RespondCvarValue_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CCLCMsg_RespondCvarValue) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CCLCMsg_RespondCvarValue) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_RespondCvarValue_value_acc_type;
static CCLCMsg_RespondCvarValue_value_acc: CCLCMsg_RespondCvarValue_value_acc_type = CCLCMsg_RespondCvarValue_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_RespondCvarValue> for CCLCMsg_RespondCvarValue_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &CCLCMsg_RespondCvarValue) -> bool {
        m.has_value()
    }

    fn get_str<'a>(&self, m: &'a CCLCMsg_RespondCvarValue) -> &'a str {
        m.get_value()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_FileCRCCheck {
    code_path: Option<i32>,
    path: ::protobuf::SingularField<String>,
    code_filename: Option<i32>,
    filename: ::protobuf::SingularField<String>,
    crc: Option<u32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_FileCRCCheck {
    pub fn new() -> CCLCMsg_FileCRCCheck {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_FileCRCCheck {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_FileCRCCheck> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_FileCRCCheck };
        unsafe {
            instance.get(|| {
                CCLCMsg_FileCRCCheck {
                    code_path: None,
                    path: ::protobuf::SingularField::none(),
                    code_filename: None,
                    filename: ::protobuf::SingularField::none(),
                    crc: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_code_path(&mut self) {
        self.code_path = None;
    }

    pub fn has_code_path(&self) -> bool {
        self.code_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_path(&mut self, v: i32) {
        self.code_path = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_path(&'a mut self) -> &'a mut i32 {
        if self.code_path.is_none() {
            self.code_path = Some(0);
        };
        self.code_path.as_mut().unwrap()
    }

    pub fn get_code_path(&self) -> i32 {
        self.code_path.unwrap_or_else(|| 0)
    }

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&'a mut self) -> &'a mut String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    pub fn get_path(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_code_filename(&mut self) {
        self.code_filename = None;
    }

    pub fn has_code_filename(&self) -> bool {
        self.code_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_filename(&mut self, v: i32) {
        self.code_filename = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_filename(&'a mut self) -> &'a mut i32 {
        if self.code_filename.is_none() {
            self.code_filename = Some(0);
        };
        self.code_filename.as_mut().unwrap()
    }

    pub fn get_code_filename(&self) -> i32 {
        self.code_filename.unwrap_or_else(|| 0)
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&'a mut self) -> &'a mut String {
        if self.filename.is_none() {
            self.filename.set_default();
        };
        self.filename.as_mut().unwrap()
    }

    pub fn get_filename(&'a self) -> &'a str {
        match self.filename.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_crc(&mut self) {
        self.crc = None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crc(&'a mut self) -> &'a mut u32 {
        if self.crc.is_none() {
            self.crc = Some(0);
        };
        self.crc.as_mut().unwrap()
    }

    pub fn get_crc(&self) -> u32 {
        self.crc.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CCLCMsg_FileCRCCheck {
    fn new() -> CCLCMsg_FileCRCCheck {
        CCLCMsg_FileCRCCheck::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.code_path = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.path.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.code_filename = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.filename.set_default();
                    is.read_string_into(tmp)
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.crc = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.code_path.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.code_filename.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filename.iter() {
            my_size += ::protobuf::rt::string_size(4, value.as_slice());
        };
        if self.crc.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.code_path {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.path.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.code_filename {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.filename.as_ref() {
            Some(ref v) => {
                os.write_string(4, v.as_slice());
            },
            None => {},
        };
        match self.crc {
            Some(ref v) => {
                os.write_fixed32(5, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_FileCRCCheck>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_FileCRCCheck_code_path_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_FileCRCCheck_path_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_FileCRCCheck_code_filename_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_FileCRCCheck_filename_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_FileCRCCheck_crc_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_FileCRCCheck>(
                    "CCLCMsg_FileCRCCheck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_FileCRCCheck>()
    }
}

impl ::protobuf::Clear for CCLCMsg_FileCRCCheck {
    fn clear(&mut self) {
        self.clear_code_path();
        self.clear_path();
        self.clear_code_filename();
        self.clear_filename();
        self.clear_crc();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_FileCRCCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_FileCRCCheck_code_path_acc_type;
static CCLCMsg_FileCRCCheck_code_path_acc: CCLCMsg_FileCRCCheck_code_path_acc_type = CCLCMsg_FileCRCCheck_code_path_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck> for CCLCMsg_FileCRCCheck_code_path_acc_type {
    fn name(&self) -> &'static str {
        "code_path"
    }

    fn has_field(&self, m: &CCLCMsg_FileCRCCheck) -> bool {
        m.has_code_path()
    }

    fn get_i32(&self, m: &CCLCMsg_FileCRCCheck) -> i32 {
        m.get_code_path()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_FileCRCCheck_path_acc_type;
static CCLCMsg_FileCRCCheck_path_acc: CCLCMsg_FileCRCCheck_path_acc_type = CCLCMsg_FileCRCCheck_path_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck> for CCLCMsg_FileCRCCheck_path_acc_type {
    fn name(&self) -> &'static str {
        "path"
    }

    fn has_field(&self, m: &CCLCMsg_FileCRCCheck) -> bool {
        m.has_path()
    }

    fn get_str<'a>(&self, m: &'a CCLCMsg_FileCRCCheck) -> &'a str {
        m.get_path()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_FileCRCCheck_code_filename_acc_type;
static CCLCMsg_FileCRCCheck_code_filename_acc: CCLCMsg_FileCRCCheck_code_filename_acc_type = CCLCMsg_FileCRCCheck_code_filename_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck> for CCLCMsg_FileCRCCheck_code_filename_acc_type {
    fn name(&self) -> &'static str {
        "code_filename"
    }

    fn has_field(&self, m: &CCLCMsg_FileCRCCheck) -> bool {
        m.has_code_filename()
    }

    fn get_i32(&self, m: &CCLCMsg_FileCRCCheck) -> i32 {
        m.get_code_filename()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_FileCRCCheck_filename_acc_type;
static CCLCMsg_FileCRCCheck_filename_acc: CCLCMsg_FileCRCCheck_filename_acc_type = CCLCMsg_FileCRCCheck_filename_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck> for CCLCMsg_FileCRCCheck_filename_acc_type {
    fn name(&self) -> &'static str {
        "filename"
    }

    fn has_field(&self, m: &CCLCMsg_FileCRCCheck) -> bool {
        m.has_filename()
    }

    fn get_str<'a>(&self, m: &'a CCLCMsg_FileCRCCheck) -> &'a str {
        m.get_filename()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_FileCRCCheck_crc_acc_type;
static CCLCMsg_FileCRCCheck_crc_acc: CCLCMsg_FileCRCCheck_crc_acc_type = CCLCMsg_FileCRCCheck_crc_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_FileCRCCheck> for CCLCMsg_FileCRCCheck_crc_acc_type {
    fn name(&self) -> &'static str {
        "crc"
    }

    fn has_field(&self, m: &CCLCMsg_FileCRCCheck) -> bool {
        m.has_crc()
    }

    fn get_u32(&self, m: &CCLCMsg_FileCRCCheck) -> u32 {
        m.get_crc()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_LoadingProgress {
    progress: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_LoadingProgress {
    pub fn new() -> CCLCMsg_LoadingProgress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_LoadingProgress {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_LoadingProgress> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_LoadingProgress };
        unsafe {
            instance.get(|| {
                CCLCMsg_LoadingProgress {
                    progress: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_progress(&mut self) {
        self.progress = None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&'a mut self) -> &'a mut i32 {
        if self.progress.is_none() {
            self.progress = Some(0);
        };
        self.progress.as_mut().unwrap()
    }

    pub fn get_progress(&self) -> i32 {
        self.progress.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CCLCMsg_LoadingProgress {
    fn new() -> CCLCMsg_LoadingProgress {
        CCLCMsg_LoadingProgress::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.progress = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.progress.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.progress {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_LoadingProgress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_LoadingProgress>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_LoadingProgress_progress_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_LoadingProgress>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_LoadingProgress>(
                    "CCLCMsg_LoadingProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_LoadingProgress>()
    }
}

impl ::protobuf::Clear for CCLCMsg_LoadingProgress {
    fn clear(&mut self) {
        self.clear_progress();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_LoadingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_LoadingProgress_progress_acc_type;
static CCLCMsg_LoadingProgress_progress_acc: CCLCMsg_LoadingProgress_progress_acc_type = CCLCMsg_LoadingProgress_progress_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_LoadingProgress> for CCLCMsg_LoadingProgress_progress_acc_type {
    fn name(&self) -> &'static str {
        "progress"
    }

    fn has_field(&self, m: &CCLCMsg_LoadingProgress) -> bool {
        m.has_progress()
    }

    fn get_i32(&self, m: &CCLCMsg_LoadingProgress) -> i32 {
        m.get_progress()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_SplitPlayerConnect {
    convars: ::protobuf::SingularPtrField<CMsg_CVars>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_SplitPlayerConnect {
    pub fn new() -> CCLCMsg_SplitPlayerConnect {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_SplitPlayerConnect {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_SplitPlayerConnect> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_SplitPlayerConnect };
        unsafe {
            instance.get(|| {
                CCLCMsg_SplitPlayerConnect {
                    convars: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_convars(&mut self) {
        self.convars.clear();
    }

    pub fn has_convars(&self) -> bool {
        self.convars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convars(&mut self, v: CMsg_CVars) {
        self.convars = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convars(&'a mut self) -> &'a mut CMsg_CVars {
        if self.convars.is_none() {
            self.convars.set_default();
        };
        self.convars.as_mut().unwrap()
    }

    pub fn get_convars(&'a self) -> &'a CMsg_CVars {
        self.convars.as_ref().unwrap_or_else(|| CMsg_CVars::default_instance())
    }
}

impl ::protobuf::Message for CCLCMsg_SplitPlayerConnect {
    fn new() -> CCLCMsg_SplitPlayerConnect {
        CCLCMsg_SplitPlayerConnect::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.convars.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.convars.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.convars.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_SplitPlayerConnect>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_SplitPlayerConnect>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_SplitPlayerConnect_convars_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_SplitPlayerConnect>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_SplitPlayerConnect>(
                    "CCLCMsg_SplitPlayerConnect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_SplitPlayerConnect>()
    }
}

impl ::protobuf::Clear for CCLCMsg_SplitPlayerConnect {
    fn clear(&mut self) {
        self.clear_convars();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_SplitPlayerConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_SplitPlayerConnect_convars_acc_type;
static CCLCMsg_SplitPlayerConnect_convars_acc: CCLCMsg_SplitPlayerConnect_convars_acc_type = CCLCMsg_SplitPlayerConnect_convars_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_SplitPlayerConnect> for CCLCMsg_SplitPlayerConnect_convars_acc_type {
    fn name(&self) -> &'static str {
        "convars"
    }

    fn has_field(&self, m: &CCLCMsg_SplitPlayerConnect) -> bool {
        m.has_convars()
    }

    fn get_message<'a>(&self, m: &'a CCLCMsg_SplitPlayerConnect) -> &'a ::protobuf::Message {
        m.get_convars() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CCLCMsg_ClientMessage {
    msg_type: Option<i32>,
    data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CCLCMsg_ClientMessage {
    pub fn new() -> CCLCMsg_ClientMessage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCLCMsg_ClientMessage {
        static mut instance: ::protobuf::lazy::Lazy<CCLCMsg_ClientMessage> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CCLCMsg_ClientMessage };
        unsafe {
            instance.get(|| {
                CCLCMsg_ClientMessage {
                    msg_type: None,
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_type(&'a mut self) -> &'a mut i32 {
        if self.msg_type.is_none() {
            self.msg_type = Some(0);
        };
        self.msg_type.as_mut().unwrap()
    }

    pub fn get_msg_type(&self) -> i32 {
        self.msg_type.unwrap_or_else(|| 0)
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CCLCMsg_ClientMessage {
    fn new() -> CCLCMsg_ClientMessage {
        CCLCMsg_ClientMessage::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.msg_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.msg_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.msg_type {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CCLCMsg_ClientMessage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientMessage>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientMessage_msg_type_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientMessage>) });
                fields.push(unsafe { ::std::mem::transmute(&CCLCMsg_ClientMessage_data_acc as &'static ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientMessage>) });
                ::protobuf::reflect::MessageDescriptor::new::<CCLCMsg_ClientMessage>(
                    "CCLCMsg_ClientMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CCLCMsg_ClientMessage>()
    }
}

impl ::protobuf::Clear for CCLCMsg_ClientMessage {
    fn clear(&mut self) {
        self.clear_msg_type();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CCLCMsg_ClientMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CCLCMsg_ClientMessage_msg_type_acc_type;
static CCLCMsg_ClientMessage_msg_type_acc: CCLCMsg_ClientMessage_msg_type_acc_type = CCLCMsg_ClientMessage_msg_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientMessage> for CCLCMsg_ClientMessage_msg_type_acc_type {
    fn name(&self) -> &'static str {
        "msg_type"
    }

    fn has_field(&self, m: &CCLCMsg_ClientMessage) -> bool {
        m.has_msg_type()
    }

    fn get_i32(&self, m: &CCLCMsg_ClientMessage) -> i32 {
        m.get_msg_type()
    }
}

#[allow(non_camel_case_types)]
struct CCLCMsg_ClientMessage_data_acc_type;
static CCLCMsg_ClientMessage_data_acc: CCLCMsg_ClientMessage_data_acc_type = CCLCMsg_ClientMessage_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CCLCMsg_ClientMessage> for CCLCMsg_ClientMessage_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CCLCMsg_ClientMessage) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CCLCMsg_ClientMessage) -> &'a [u8] {
        m.get_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_ServerInfo {
    protocol: Option<i32>,
    server_count: Option<i32>,
    is_dedicated: Option<bool>,
    is_hltv: Option<bool>,
    is_replay: Option<bool>,
    c_os: Option<i32>,
    map_crc: Option<u32>,
    client_crc: Option<u32>,
    string_table_crc: Option<u32>,
    max_clients: Option<i32>,
    max_classes: Option<i32>,
    player_slot: Option<i32>,
    tick_interval: Option<f32>,
    game_dir: ::protobuf::SingularField<String>,
    map_name: ::protobuf::SingularField<String>,
    sky_name: ::protobuf::SingularField<String>,
    host_name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_ServerInfo {
    pub fn new() -> CSVCMsg_ServerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_ServerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_ServerInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_ServerInfo };
        unsafe {
            instance.get(|| {
                CSVCMsg_ServerInfo {
                    protocol: None,
                    server_count: None,
                    is_dedicated: None,
                    is_hltv: None,
                    is_replay: None,
                    c_os: None,
                    map_crc: None,
                    client_crc: None,
                    string_table_crc: None,
                    max_clients: None,
                    max_classes: None,
                    player_slot: None,
                    tick_interval: None,
                    game_dir: ::protobuf::SingularField::none(),
                    map_name: ::protobuf::SingularField::none(),
                    sky_name: ::protobuf::SingularField::none(),
                    host_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: i32) {
        self.protocol = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&'a mut self) -> &'a mut i32 {
        if self.protocol.is_none() {
            self.protocol = Some(0);
        };
        self.protocol.as_mut().unwrap()
    }

    pub fn get_protocol(&self) -> i32 {
        self.protocol.unwrap_or_else(|| 0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: i32) {
        self.server_count = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_count(&'a mut self) -> &'a mut i32 {
        if self.server_count.is_none() {
            self.server_count = Some(0);
        };
        self.server_count.as_mut().unwrap()
    }

    pub fn get_server_count(&self) -> i32 {
        self.server_count.unwrap_or_else(|| 0)
    }

    pub fn clear_is_dedicated(&mut self) {
        self.is_dedicated = None;
    }

    pub fn has_is_dedicated(&self) -> bool {
        self.is_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dedicated(&mut self, v: bool) {
        self.is_dedicated = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_dedicated(&'a mut self) -> &'a mut bool {
        if self.is_dedicated.is_none() {
            self.is_dedicated = Some(false);
        };
        self.is_dedicated.as_mut().unwrap()
    }

    pub fn get_is_dedicated(&self) -> bool {
        self.is_dedicated.unwrap_or_else(|| false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_hltv(&'a mut self) -> &'a mut bool {
        if self.is_hltv.is_none() {
            self.is_hltv = Some(false);
        };
        self.is_hltv.as_mut().unwrap()
    }

    pub fn get_is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or_else(|| false)
    }

    pub fn clear_is_replay(&mut self) {
        self.is_replay = None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_replay(&'a mut self) -> &'a mut bool {
        if self.is_replay.is_none() {
            self.is_replay = Some(false);
        };
        self.is_replay.as_mut().unwrap()
    }

    pub fn get_is_replay(&self) -> bool {
        self.is_replay.unwrap_or_else(|| false)
    }

    pub fn clear_c_os(&mut self) {
        self.c_os = None;
    }

    pub fn has_c_os(&self) -> bool {
        self.c_os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c_os(&mut self, v: i32) {
        self.c_os = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c_os(&'a mut self) -> &'a mut i32 {
        if self.c_os.is_none() {
            self.c_os = Some(0);
        };
        self.c_os.as_mut().unwrap()
    }

    pub fn get_c_os(&self) -> i32 {
        self.c_os.unwrap_or_else(|| 0)
    }

    pub fn clear_map_crc(&mut self) {
        self.map_crc = None;
    }

    pub fn has_map_crc(&self) -> bool {
        self.map_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_crc(&mut self, v: u32) {
        self.map_crc = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_crc(&'a mut self) -> &'a mut u32 {
        if self.map_crc.is_none() {
            self.map_crc = Some(0);
        };
        self.map_crc.as_mut().unwrap()
    }

    pub fn get_map_crc(&self) -> u32 {
        self.map_crc.unwrap_or_else(|| 0)
    }

    pub fn clear_client_crc(&mut self) {
        self.client_crc = None;
    }

    pub fn has_client_crc(&self) -> bool {
        self.client_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_crc(&mut self, v: u32) {
        self.client_crc = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_crc(&'a mut self) -> &'a mut u32 {
        if self.client_crc.is_none() {
            self.client_crc = Some(0);
        };
        self.client_crc.as_mut().unwrap()
    }

    pub fn get_client_crc(&self) -> u32 {
        self.client_crc.unwrap_or_else(|| 0)
    }

    pub fn clear_string_table_crc(&mut self) {
        self.string_table_crc = None;
    }

    pub fn has_string_table_crc(&self) -> bool {
        self.string_table_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_table_crc(&mut self, v: u32) {
        self.string_table_crc = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_table_crc(&'a mut self) -> &'a mut u32 {
        if self.string_table_crc.is_none() {
            self.string_table_crc = Some(0);
        };
        self.string_table_crc.as_mut().unwrap()
    }

    pub fn get_string_table_crc(&self) -> u32 {
        self.string_table_crc.unwrap_or_else(|| 0)
    }

    pub fn clear_max_clients(&mut self) {
        self.max_clients = None;
    }

    pub fn has_max_clients(&self) -> bool {
        self.max_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_clients(&mut self, v: i32) {
        self.max_clients = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_clients(&'a mut self) -> &'a mut i32 {
        if self.max_clients.is_none() {
            self.max_clients = Some(0);
        };
        self.max_clients.as_mut().unwrap()
    }

    pub fn get_max_clients(&self) -> i32 {
        self.max_clients.unwrap_or_else(|| 0)
    }

    pub fn clear_max_classes(&mut self) {
        self.max_classes = None;
    }

    pub fn has_max_classes(&self) -> bool {
        self.max_classes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_classes(&mut self, v: i32) {
        self.max_classes = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_classes(&'a mut self) -> &'a mut i32 {
        if self.max_classes.is_none() {
            self.max_classes = Some(0);
        };
        self.max_classes.as_mut().unwrap()
    }

    pub fn get_max_classes(&self) -> i32 {
        self.max_classes.unwrap_or_else(|| 0)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_slot(&'a mut self) -> &'a mut i32 {
        if self.player_slot.is_none() {
            self.player_slot = Some(0);
        };
        self.player_slot.as_mut().unwrap()
    }

    pub fn get_player_slot(&self) -> i32 {
        self.player_slot.unwrap_or_else(|| 0)
    }

    pub fn clear_tick_interval(&mut self) {
        self.tick_interval = None;
    }

    pub fn has_tick_interval(&self) -> bool {
        self.tick_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_interval(&mut self, v: f32) {
        self.tick_interval = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tick_interval(&'a mut self) -> &'a mut f32 {
        if self.tick_interval.is_none() {
            self.tick_interval = Some(0.);
        };
        self.tick_interval.as_mut().unwrap()
    }

    pub fn get_tick_interval(&self) -> f32 {
        self.tick_interval.unwrap_or_else(|| 0.)
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir.clear();
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: String) {
        self.game_dir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&'a mut self) -> &'a mut String {
        if self.game_dir.is_none() {
            self.game_dir.set_default();
        };
        self.game_dir.as_mut().unwrap()
    }

    pub fn get_game_dir(&'a self) -> &'a str {
        match self.game_dir.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&'a mut self) -> &'a mut String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        };
        self.map_name.as_mut().unwrap()
    }

    pub fn get_map_name(&'a self) -> &'a str {
        match self.map_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_sky_name(&mut self) {
        self.sky_name.clear();
    }

    pub fn has_sky_name(&self) -> bool {
        self.sky_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sky_name(&mut self, v: String) {
        self.sky_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sky_name(&'a mut self) -> &'a mut String {
        if self.sky_name.is_none() {
            self.sky_name.set_default();
        };
        self.sky_name.as_mut().unwrap()
    }

    pub fn get_sky_name(&'a self) -> &'a str {
        match self.sky_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name.clear();
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: String) {
        self.host_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&'a mut self) -> &'a mut String {
        if self.host_name.is_none() {
            self.host_name.set_default();
        };
        self.host_name.as_mut().unwrap()
    }

    pub fn get_host_name(&'a self) -> &'a str {
        match self.host_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CSVCMsg_ServerInfo {
    fn new() -> CSVCMsg_ServerInfo {
        CSVCMsg_ServerInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.protocol = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.server_count = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_dedicated = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_hltv = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_replay = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.c_os = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.map_crc = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.client_crc = Some(tmp);
                },
                9 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.string_table_crc = Some(tmp);
                },
                10 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.max_clients = Some(tmp);
                },
                11 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.max_classes = Some(tmp);
                },
                12 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.player_slot = Some(tmp);
                },
                13 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.tick_interval = Some(tmp);
                },
                14 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.game_dir.set_default();
                    is.read_string_into(tmp)
                },
                15 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.map_name.set_default();
                    is.read_string_into(tmp)
                },
                16 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.sky_name.set_default();
                    is.read_string_into(tmp)
                },
                17 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.host_name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.protocol.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.server_count.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_dedicated.is_some() {
            my_size += 2;
        };
        if self.is_hltv.is_some() {
            my_size += 2;
        };
        if self.is_replay.is_some() {
            my_size += 2;
        };
        for value in self.c_os.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.map_crc.is_some() {
            my_size += 5;
        };
        if self.client_crc.is_some() {
            my_size += 5;
        };
        if self.string_table_crc.is_some() {
            my_size += 5;
        };
        for value in self.max_clients.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.max_classes.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.player_slot.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.tick_interval.is_some() {
            my_size += 5;
        };
        for value in self.game_dir.iter() {
            my_size += ::protobuf::rt::string_size(14, value.as_slice());
        };
        for value in self.map_name.iter() {
            my_size += ::protobuf::rt::string_size(15, value.as_slice());
        };
        for value in self.sky_name.iter() {
            my_size += ::protobuf::rt::string_size(16, value.as_slice());
        };
        for value in self.host_name.iter() {
            my_size += ::protobuf::rt::string_size(17, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.protocol {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.server_count {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.is_dedicated {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        match self.is_hltv {
            Some(ref v) => {
                os.write_bool(4, *v);
            },
            None => {},
        };
        match self.is_replay {
            Some(ref v) => {
                os.write_bool(5, *v);
            },
            None => {},
        };
        match self.c_os {
            Some(ref v) => {
                os.write_int32(6, *v);
            },
            None => {},
        };
        match self.map_crc {
            Some(ref v) => {
                os.write_fixed32(7, *v);
            },
            None => {},
        };
        match self.client_crc {
            Some(ref v) => {
                os.write_fixed32(8, *v);
            },
            None => {},
        };
        match self.string_table_crc {
            Some(ref v) => {
                os.write_fixed32(9, *v);
            },
            None => {},
        };
        match self.max_clients {
            Some(ref v) => {
                os.write_int32(10, *v);
            },
            None => {},
        };
        match self.max_classes {
            Some(ref v) => {
                os.write_int32(11, *v);
            },
            None => {},
        };
        match self.player_slot {
            Some(ref v) => {
                os.write_int32(12, *v);
            },
            None => {},
        };
        match self.tick_interval {
            Some(ref v) => {
                os.write_float(13, *v);
            },
            None => {},
        };
        match self.game_dir.as_ref() {
            Some(ref v) => {
                os.write_string(14, v.as_slice());
            },
            None => {},
        };
        match self.map_name.as_ref() {
            Some(ref v) => {
                os.write_string(15, v.as_slice());
            },
            None => {},
        };
        match self.sky_name.as_ref() {
            Some(ref v) => {
                os.write_string(16, v.as_slice());
            },
            None => {},
        };
        match self.host_name.as_ref() {
            Some(ref v) => {
                os.write_string(17, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_ServerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_protocol_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_server_count_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_is_dedicated_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_is_hltv_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_is_replay_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_c_os_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_map_crc_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_client_crc_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_string_table_crc_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_max_clients_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_max_classes_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_player_slot_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_tick_interval_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_game_dir_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_map_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_sky_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ServerInfo_host_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_ServerInfo>(
                    "CSVCMsg_ServerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_ServerInfo>()
    }
}

impl ::protobuf::Clear for CSVCMsg_ServerInfo {
    fn clear(&mut self) {
        self.clear_protocol();
        self.clear_server_count();
        self.clear_is_dedicated();
        self.clear_is_hltv();
        self.clear_is_replay();
        self.clear_c_os();
        self.clear_map_crc();
        self.clear_client_crc();
        self.clear_string_table_crc();
        self.clear_max_clients();
        self.clear_max_classes();
        self.clear_player_slot();
        self.clear_tick_interval();
        self.clear_game_dir();
        self.clear_map_name();
        self.clear_sky_name();
        self.clear_host_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_protocol_acc_type;
static CSVCMsg_ServerInfo_protocol_acc: CSVCMsg_ServerInfo_protocol_acc_type = CSVCMsg_ServerInfo_protocol_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_protocol_acc_type {
    fn name(&self) -> &'static str {
        "protocol"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_protocol()
    }

    fn get_i32(&self, m: &CSVCMsg_ServerInfo) -> i32 {
        m.get_protocol()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_server_count_acc_type;
static CSVCMsg_ServerInfo_server_count_acc: CSVCMsg_ServerInfo_server_count_acc_type = CSVCMsg_ServerInfo_server_count_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_server_count_acc_type {
    fn name(&self) -> &'static str {
        "server_count"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_server_count()
    }

    fn get_i32(&self, m: &CSVCMsg_ServerInfo) -> i32 {
        m.get_server_count()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_is_dedicated_acc_type;
static CSVCMsg_ServerInfo_is_dedicated_acc: CSVCMsg_ServerInfo_is_dedicated_acc_type = CSVCMsg_ServerInfo_is_dedicated_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_is_dedicated_acc_type {
    fn name(&self) -> &'static str {
        "is_dedicated"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_is_dedicated()
    }

    fn get_bool(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.get_is_dedicated()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_is_hltv_acc_type;
static CSVCMsg_ServerInfo_is_hltv_acc: CSVCMsg_ServerInfo_is_hltv_acc_type = CSVCMsg_ServerInfo_is_hltv_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_is_hltv_acc_type {
    fn name(&self) -> &'static str {
        "is_hltv"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_is_hltv()
    }

    fn get_bool(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.get_is_hltv()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_is_replay_acc_type;
static CSVCMsg_ServerInfo_is_replay_acc: CSVCMsg_ServerInfo_is_replay_acc_type = CSVCMsg_ServerInfo_is_replay_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_is_replay_acc_type {
    fn name(&self) -> &'static str {
        "is_replay"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_is_replay()
    }

    fn get_bool(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.get_is_replay()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_c_os_acc_type;
static CSVCMsg_ServerInfo_c_os_acc: CSVCMsg_ServerInfo_c_os_acc_type = CSVCMsg_ServerInfo_c_os_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_c_os_acc_type {
    fn name(&self) -> &'static str {
        "c_os"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_c_os()
    }

    fn get_i32(&self, m: &CSVCMsg_ServerInfo) -> i32 {
        m.get_c_os()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_map_crc_acc_type;
static CSVCMsg_ServerInfo_map_crc_acc: CSVCMsg_ServerInfo_map_crc_acc_type = CSVCMsg_ServerInfo_map_crc_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_map_crc_acc_type {
    fn name(&self) -> &'static str {
        "map_crc"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_map_crc()
    }

    fn get_u32(&self, m: &CSVCMsg_ServerInfo) -> u32 {
        m.get_map_crc()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_client_crc_acc_type;
static CSVCMsg_ServerInfo_client_crc_acc: CSVCMsg_ServerInfo_client_crc_acc_type = CSVCMsg_ServerInfo_client_crc_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_client_crc_acc_type {
    fn name(&self) -> &'static str {
        "client_crc"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_client_crc()
    }

    fn get_u32(&self, m: &CSVCMsg_ServerInfo) -> u32 {
        m.get_client_crc()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_string_table_crc_acc_type;
static CSVCMsg_ServerInfo_string_table_crc_acc: CSVCMsg_ServerInfo_string_table_crc_acc_type = CSVCMsg_ServerInfo_string_table_crc_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_string_table_crc_acc_type {
    fn name(&self) -> &'static str {
        "string_table_crc"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_string_table_crc()
    }

    fn get_u32(&self, m: &CSVCMsg_ServerInfo) -> u32 {
        m.get_string_table_crc()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_max_clients_acc_type;
static CSVCMsg_ServerInfo_max_clients_acc: CSVCMsg_ServerInfo_max_clients_acc_type = CSVCMsg_ServerInfo_max_clients_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_max_clients_acc_type {
    fn name(&self) -> &'static str {
        "max_clients"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_max_clients()
    }

    fn get_i32(&self, m: &CSVCMsg_ServerInfo) -> i32 {
        m.get_max_clients()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_max_classes_acc_type;
static CSVCMsg_ServerInfo_max_classes_acc: CSVCMsg_ServerInfo_max_classes_acc_type = CSVCMsg_ServerInfo_max_classes_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_max_classes_acc_type {
    fn name(&self) -> &'static str {
        "max_classes"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_max_classes()
    }

    fn get_i32(&self, m: &CSVCMsg_ServerInfo) -> i32 {
        m.get_max_classes()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_player_slot_acc_type;
static CSVCMsg_ServerInfo_player_slot_acc: CSVCMsg_ServerInfo_player_slot_acc_type = CSVCMsg_ServerInfo_player_slot_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_player_slot_acc_type {
    fn name(&self) -> &'static str {
        "player_slot"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_player_slot()
    }

    fn get_i32(&self, m: &CSVCMsg_ServerInfo) -> i32 {
        m.get_player_slot()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_tick_interval_acc_type;
static CSVCMsg_ServerInfo_tick_interval_acc: CSVCMsg_ServerInfo_tick_interval_acc_type = CSVCMsg_ServerInfo_tick_interval_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_tick_interval_acc_type {
    fn name(&self) -> &'static str {
        "tick_interval"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_tick_interval()
    }

    fn get_f32(&self, m: &CSVCMsg_ServerInfo) -> f32 {
        m.get_tick_interval()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_game_dir_acc_type;
static CSVCMsg_ServerInfo_game_dir_acc: CSVCMsg_ServerInfo_game_dir_acc_type = CSVCMsg_ServerInfo_game_dir_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_game_dir_acc_type {
    fn name(&self) -> &'static str {
        "game_dir"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_game_dir()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_ServerInfo) -> &'a str {
        m.get_game_dir()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_map_name_acc_type;
static CSVCMsg_ServerInfo_map_name_acc: CSVCMsg_ServerInfo_map_name_acc_type = CSVCMsg_ServerInfo_map_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_map_name_acc_type {
    fn name(&self) -> &'static str {
        "map_name"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_map_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_ServerInfo) -> &'a str {
        m.get_map_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_sky_name_acc_type;
static CSVCMsg_ServerInfo_sky_name_acc: CSVCMsg_ServerInfo_sky_name_acc_type = CSVCMsg_ServerInfo_sky_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_sky_name_acc_type {
    fn name(&self) -> &'static str {
        "sky_name"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_sky_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_ServerInfo) -> &'a str {
        m.get_sky_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ServerInfo_host_name_acc_type;
static CSVCMsg_ServerInfo_host_name_acc: CSVCMsg_ServerInfo_host_name_acc_type = CSVCMsg_ServerInfo_host_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ServerInfo> for CSVCMsg_ServerInfo_host_name_acc_type {
    fn name(&self) -> &'static str {
        "host_name"
    }

    fn has_field(&self, m: &CSVCMsg_ServerInfo) -> bool {
        m.has_host_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_ServerInfo) -> &'a str {
        m.get_host_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_ClassInfo {
    create_on_client: Option<bool>,
    classes: ::protobuf::RepeatedField<CSVCMsg_ClassInfo_class_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_ClassInfo {
    pub fn new() -> CSVCMsg_ClassInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_ClassInfo {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_ClassInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_ClassInfo };
        unsafe {
            instance.get(|| {
                CSVCMsg_ClassInfo {
                    create_on_client: None,
                    classes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_create_on_client(&mut self) {
        self.create_on_client = None;
    }

    pub fn has_create_on_client(&self) -> bool {
        self.create_on_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_on_client(&mut self, v: bool) {
        self.create_on_client = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_on_client(&'a mut self) -> &'a mut bool {
        if self.create_on_client.is_none() {
            self.create_on_client = Some(false);
        };
        self.create_on_client.as_mut().unwrap()
    }

    pub fn get_create_on_client(&self) -> bool {
        self.create_on_client.unwrap_or_else(|| false)
    }

    pub fn clear_classes(&mut self) {
        self.classes.clear();
    }

    // Param is passed by value, moved
    pub fn set_classes(&mut self, v: ::protobuf::RepeatedField<CSVCMsg_ClassInfo_class_t>) {
        self.classes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_classes(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsg_ClassInfo_class_t> {
        &mut self.classes
    }

    pub fn get_classes(&'a self) -> &'a [CSVCMsg_ClassInfo_class_t] {
        self.classes.as_slice()
    }

    pub fn add_classes(&mut self, v: CSVCMsg_ClassInfo_class_t) {
        self.classes.push(v);
    }
}

impl ::protobuf::Message for CSVCMsg_ClassInfo {
    fn new() -> CSVCMsg_ClassInfo {
        CSVCMsg_ClassInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.create_on_client = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.classes.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.create_on_client.is_some() {
            my_size += 2;
        };
        for value in self.classes.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.create_on_client {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        for v in self.classes.iter() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_ClassInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ClassInfo_create_on_client_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ClassInfo_classes_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_ClassInfo>(
                    "CSVCMsg_ClassInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_ClassInfo>()
    }
}

impl ::protobuf::Clear for CSVCMsg_ClassInfo {
    fn clear(&mut self) {
        self.clear_create_on_client();
        self.clear_classes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_ClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_ClassInfo_create_on_client_acc_type;
static CSVCMsg_ClassInfo_create_on_client_acc: CSVCMsg_ClassInfo_create_on_client_acc_type = CSVCMsg_ClassInfo_create_on_client_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo> for CSVCMsg_ClassInfo_create_on_client_acc_type {
    fn name(&self) -> &'static str {
        "create_on_client"
    }

    fn has_field(&self, m: &CSVCMsg_ClassInfo) -> bool {
        m.has_create_on_client()
    }

    fn get_bool(&self, m: &CSVCMsg_ClassInfo) -> bool {
        m.get_create_on_client()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ClassInfo_classes_acc_type;
static CSVCMsg_ClassInfo_classes_acc: CSVCMsg_ClassInfo_classes_acc_type = CSVCMsg_ClassInfo_classes_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo> for CSVCMsg_ClassInfo_classes_acc_type {
    fn name(&self) -> &'static str {
        "classes"
    }

    fn len_field(&self, m: &CSVCMsg_ClassInfo) -> uint {
        m.get_classes().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsg_ClassInfo, index: uint) -> &'a ::protobuf::Message {
        &m.get_classes()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_ClassInfo_class_t {
    class_id: Option<i32>,
    data_table_name: ::protobuf::SingularField<String>,
    class_name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_ClassInfo_class_t {
    pub fn new() -> CSVCMsg_ClassInfo_class_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_ClassInfo_class_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_ClassInfo_class_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_ClassInfo_class_t };
        unsafe {
            instance.get(|| {
                CSVCMsg_ClassInfo_class_t {
                    class_id: None,
                    data_table_name: ::protobuf::SingularField::none(),
                    class_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: i32) {
        self.class_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_id(&'a mut self) -> &'a mut i32 {
        if self.class_id.is_none() {
            self.class_id = Some(0);
        };
        self.class_id.as_mut().unwrap()
    }

    pub fn get_class_id(&self) -> i32 {
        self.class_id.unwrap_or_else(|| 0)
    }

    pub fn clear_data_table_name(&mut self) {
        self.data_table_name.clear();
    }

    pub fn has_data_table_name(&self) -> bool {
        self.data_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_table_name(&mut self, v: String) {
        self.data_table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_table_name(&'a mut self) -> &'a mut String {
        if self.data_table_name.is_none() {
            self.data_table_name.set_default();
        };
        self.data_table_name.as_mut().unwrap()
    }

    pub fn get_data_table_name(&'a self) -> &'a str {
        match self.data_table_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_class_name(&mut self) {
        self.class_name.clear();
    }

    pub fn has_class_name(&self) -> bool {
        self.class_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: String) {
        self.class_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&'a mut self) -> &'a mut String {
        if self.class_name.is_none() {
            self.class_name.set_default();
        };
        self.class_name.as_mut().unwrap()
    }

    pub fn get_class_name(&'a self) -> &'a str {
        match self.class_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CSVCMsg_ClassInfo_class_t {
    fn new() -> CSVCMsg_ClassInfo_class_t {
        CSVCMsg_ClassInfo_class_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.class_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data_table_name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.class_name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.class_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data_table_name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.class_name.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.class_id {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.data_table_name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.class_name.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_ClassInfo_class_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo_class_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ClassInfo_class_t_class_id_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo_class_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ClassInfo_class_t_data_table_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo_class_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_ClassInfo_class_t_class_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo_class_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_ClassInfo_class_t>(
                    "CSVCMsg_ClassInfo_class_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_ClassInfo_class_t>()
    }
}

impl ::protobuf::Clear for CSVCMsg_ClassInfo_class_t {
    fn clear(&mut self) {
        self.clear_class_id();
        self.clear_data_table_name();
        self.clear_class_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_ClassInfo_class_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_ClassInfo_class_t_class_id_acc_type;
static CSVCMsg_ClassInfo_class_t_class_id_acc: CSVCMsg_ClassInfo_class_t_class_id_acc_type = CSVCMsg_ClassInfo_class_t_class_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo_class_t> for CSVCMsg_ClassInfo_class_t_class_id_acc_type {
    fn name(&self) -> &'static str {
        "class_id"
    }

    fn has_field(&self, m: &CSVCMsg_ClassInfo_class_t) -> bool {
        m.has_class_id()
    }

    fn get_i32(&self, m: &CSVCMsg_ClassInfo_class_t) -> i32 {
        m.get_class_id()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ClassInfo_class_t_data_table_name_acc_type;
static CSVCMsg_ClassInfo_class_t_data_table_name_acc: CSVCMsg_ClassInfo_class_t_data_table_name_acc_type = CSVCMsg_ClassInfo_class_t_data_table_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo_class_t> for CSVCMsg_ClassInfo_class_t_data_table_name_acc_type {
    fn name(&self) -> &'static str {
        "data_table_name"
    }

    fn has_field(&self, m: &CSVCMsg_ClassInfo_class_t) -> bool {
        m.has_data_table_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_ClassInfo_class_t) -> &'a str {
        m.get_data_table_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_ClassInfo_class_t_class_name_acc_type;
static CSVCMsg_ClassInfo_class_t_class_name_acc: CSVCMsg_ClassInfo_class_t_class_name_acc_type = CSVCMsg_ClassInfo_class_t_class_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_ClassInfo_class_t> for CSVCMsg_ClassInfo_class_t_class_name_acc_type {
    fn name(&self) -> &'static str {
        "class_name"
    }

    fn has_field(&self, m: &CSVCMsg_ClassInfo_class_t) -> bool {
        m.has_class_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_ClassInfo_class_t) -> &'a str {
        m.get_class_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_SetPause {
    paused: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_SetPause {
    pub fn new() -> CSVCMsg_SetPause {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_SetPause {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_SetPause> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_SetPause };
        unsafe {
            instance.get(|| {
                CSVCMsg_SetPause {
                    paused: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_paused(&mut self) {
        self.paused = None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paused(&'a mut self) -> &'a mut bool {
        if self.paused.is_none() {
            self.paused = Some(false);
        };
        self.paused.as_mut().unwrap()
    }

    pub fn get_paused(&self) -> bool {
        self.paused.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CSVCMsg_SetPause {
    fn new() -> CSVCMsg_SetPause {
        CSVCMsg_SetPause::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.paused = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.paused.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.paused {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_SetPause>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SetPause>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SetPause_paused_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SetPause>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_SetPause>(
                    "CSVCMsg_SetPause",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_SetPause>()
    }
}

impl ::protobuf::Clear for CSVCMsg_SetPause {
    fn clear(&mut self) {
        self.clear_paused();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_SetPause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_SetPause_paused_acc_type;
static CSVCMsg_SetPause_paused_acc: CSVCMsg_SetPause_paused_acc_type = CSVCMsg_SetPause_paused_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SetPause> for CSVCMsg_SetPause_paused_acc_type {
    fn name(&self) -> &'static str {
        "paused"
    }

    fn has_field(&self, m: &CSVCMsg_SetPause) -> bool {
        m.has_paused()
    }

    fn get_bool(&self, m: &CSVCMsg_SetPause) -> bool {
        m.get_paused()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_VoiceInit {
    quality: Option<i32>,
    codec: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_VoiceInit {
    pub fn new() -> CSVCMsg_VoiceInit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_VoiceInit {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_VoiceInit> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_VoiceInit };
        unsafe {
            instance.get(|| {
                CSVCMsg_VoiceInit {
                    quality: None,
                    codec: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_quality(&mut self) {
        self.quality = None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality(&'a mut self) -> &'a mut i32 {
        if self.quality.is_none() {
            self.quality = Some(0);
        };
        self.quality.as_mut().unwrap()
    }

    pub fn get_quality(&self) -> i32 {
        self.quality.unwrap_or_else(|| 0)
    }

    pub fn clear_codec(&mut self) {
        self.codec.clear();
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: String) {
        self.codec = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&'a mut self) -> &'a mut String {
        if self.codec.is_none() {
            self.codec.set_default();
        };
        self.codec.as_mut().unwrap()
    }

    pub fn get_codec(&'a self) -> &'a str {
        match self.codec.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceInit {
    fn new() -> CSVCMsg_VoiceInit {
        CSVCMsg_VoiceInit::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.quality = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.codec.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.quality.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.codec.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.quality {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.codec.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_VoiceInit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceInit>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_VoiceInit_quality_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceInit>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_VoiceInit_codec_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceInit>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_VoiceInit>(
                    "CSVCMsg_VoiceInit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_VoiceInit>()
    }
}

impl ::protobuf::Clear for CSVCMsg_VoiceInit {
    fn clear(&mut self) {
        self.clear_quality();
        self.clear_codec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_VoiceInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_VoiceInit_quality_acc_type;
static CSVCMsg_VoiceInit_quality_acc: CSVCMsg_VoiceInit_quality_acc_type = CSVCMsg_VoiceInit_quality_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceInit> for CSVCMsg_VoiceInit_quality_acc_type {
    fn name(&self) -> &'static str {
        "quality"
    }

    fn has_field(&self, m: &CSVCMsg_VoiceInit) -> bool {
        m.has_quality()
    }

    fn get_i32(&self, m: &CSVCMsg_VoiceInit) -> i32 {
        m.get_quality()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_VoiceInit_codec_acc_type;
static CSVCMsg_VoiceInit_codec_acc: CSVCMsg_VoiceInit_codec_acc_type = CSVCMsg_VoiceInit_codec_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceInit> for CSVCMsg_VoiceInit_codec_acc_type {
    fn name(&self) -> &'static str {
        "codec"
    }

    fn has_field(&self, m: &CSVCMsg_VoiceInit) -> bool {
        m.has_codec()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_VoiceInit) -> &'a str {
        m.get_codec()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_Print {
    text: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_Print {
    pub fn new() -> CSVCMsg_Print {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_Print {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_Print> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_Print };
        unsafe {
            instance.get(|| {
                CSVCMsg_Print {
                    text: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&'a mut self) -> &'a mut String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    pub fn get_text(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CSVCMsg_Print {
    fn new() -> CSVCMsg_Print {
        CSVCMsg_Print::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.text.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.text.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_Print>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Print>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Print_text_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Print>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_Print>(
                    "CSVCMsg_Print",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_Print>()
    }
}

impl ::protobuf::Clear for CSVCMsg_Print {
    fn clear(&mut self) {
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_Print {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_Print_text_acc_type;
static CSVCMsg_Print_text_acc: CSVCMsg_Print_text_acc_type = CSVCMsg_Print_text_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Print> for CSVCMsg_Print_text_acc_type {
    fn name(&self) -> &'static str {
        "text"
    }

    fn has_field(&self, m: &CSVCMsg_Print) -> bool {
        m.has_text()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_Print) -> &'a str {
        m.get_text()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_Sounds {
    reliable_sound: Option<bool>,
    sounds: ::protobuf::RepeatedField<CSVCMsg_Sounds_sounddata_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_Sounds {
    pub fn new() -> CSVCMsg_Sounds {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_Sounds {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_Sounds> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_Sounds };
        unsafe {
            instance.get(|| {
                CSVCMsg_Sounds {
                    reliable_sound: None,
                    sounds: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_reliable_sound(&mut self) {
        self.reliable_sound = None;
    }

    pub fn has_reliable_sound(&self) -> bool {
        self.reliable_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_sound(&mut self, v: bool) {
        self.reliable_sound = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reliable_sound(&'a mut self) -> &'a mut bool {
        if self.reliable_sound.is_none() {
            self.reliable_sound = Some(false);
        };
        self.reliable_sound.as_mut().unwrap()
    }

    pub fn get_reliable_sound(&self) -> bool {
        self.reliable_sound.unwrap_or_else(|| false)
    }

    pub fn clear_sounds(&mut self) {
        self.sounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_sounds(&mut self, v: ::protobuf::RepeatedField<CSVCMsg_Sounds_sounddata_t>) {
        self.sounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sounds(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsg_Sounds_sounddata_t> {
        &mut self.sounds
    }

    pub fn get_sounds(&'a self) -> &'a [CSVCMsg_Sounds_sounddata_t] {
        self.sounds.as_slice()
    }

    pub fn add_sounds(&mut self, v: CSVCMsg_Sounds_sounddata_t) {
        self.sounds.push(v);
    }
}

impl ::protobuf::Message for CSVCMsg_Sounds {
    fn new() -> CSVCMsg_Sounds {
        CSVCMsg_Sounds::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.reliable_sound = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.sounds.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.reliable_sound.is_some() {
            my_size += 2;
        };
        for value in self.sounds.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.reliable_sound {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        for v in self.sounds.iter() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_Sounds>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_reliable_sound_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounds_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_Sounds>(
                    "CSVCMsg_Sounds",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_Sounds>()
    }
}

impl ::protobuf::Clear for CSVCMsg_Sounds {
    fn clear(&mut self) {
        self.clear_reliable_sound();
        self.clear_sounds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_Sounds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_reliable_sound_acc_type;
static CSVCMsg_Sounds_reliable_sound_acc: CSVCMsg_Sounds_reliable_sound_acc_type = CSVCMsg_Sounds_reliable_sound_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds> for CSVCMsg_Sounds_reliable_sound_acc_type {
    fn name(&self) -> &'static str {
        "reliable_sound"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds) -> bool {
        m.has_reliable_sound()
    }

    fn get_bool(&self, m: &CSVCMsg_Sounds) -> bool {
        m.get_reliable_sound()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounds_acc_type;
static CSVCMsg_Sounds_sounds_acc: CSVCMsg_Sounds_sounds_acc_type = CSVCMsg_Sounds_sounds_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds> for CSVCMsg_Sounds_sounds_acc_type {
    fn name(&self) -> &'static str {
        "sounds"
    }

    fn len_field(&self, m: &CSVCMsg_Sounds) -> uint {
        m.get_sounds().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsg_Sounds, index: uint) -> &'a ::protobuf::Message {
        &m.get_sounds()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_Sounds_sounddata_t {
    origin_x: Option<i32>,
    origin_y: Option<i32>,
    origin_z: Option<i32>,
    volume: Option<u32>,
    delay_value: Option<f32>,
    sequence_number: Option<i32>,
    entity_index: Option<i32>,
    channel: Option<i32>,
    pitch: Option<i32>,
    flags: Option<i32>,
    sound_num: Option<u32>,
    sound_num_handle: Option<u32>,
    speaker_entity: Option<i32>,
    random_seed: Option<i32>,
    sound_level: Option<i32>,
    is_sentence: Option<bool>,
    is_ambient: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_Sounds_sounddata_t {
    pub fn new() -> CSVCMsg_Sounds_sounddata_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_Sounds_sounddata_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_Sounds_sounddata_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_Sounds_sounddata_t };
        unsafe {
            instance.get(|| {
                CSVCMsg_Sounds_sounddata_t {
                    origin_x: None,
                    origin_y: None,
                    origin_z: None,
                    volume: None,
                    delay_value: None,
                    sequence_number: None,
                    entity_index: None,
                    channel: None,
                    pitch: None,
                    flags: None,
                    sound_num: None,
                    sound_num_handle: None,
                    speaker_entity: None,
                    random_seed: None,
                    sound_level: None,
                    is_sentence: None,
                    is_ambient: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_origin_x(&mut self) {
        self.origin_x = None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: i32) {
        self.origin_x = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_x(&'a mut self) -> &'a mut i32 {
        if self.origin_x.is_none() {
            self.origin_x = Some(0);
        };
        self.origin_x.as_mut().unwrap()
    }

    pub fn get_origin_x(&self) -> i32 {
        self.origin_x.unwrap_or_else(|| 0)
    }

    pub fn clear_origin_y(&mut self) {
        self.origin_y = None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: i32) {
        self.origin_y = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_y(&'a mut self) -> &'a mut i32 {
        if self.origin_y.is_none() {
            self.origin_y = Some(0);
        };
        self.origin_y.as_mut().unwrap()
    }

    pub fn get_origin_y(&self) -> i32 {
        self.origin_y.unwrap_or_else(|| 0)
    }

    pub fn clear_origin_z(&mut self) {
        self.origin_z = None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: i32) {
        self.origin_z = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_z(&'a mut self) -> &'a mut i32 {
        if self.origin_z.is_none() {
            self.origin_z = Some(0);
        };
        self.origin_z.as_mut().unwrap()
    }

    pub fn get_origin_z(&self) -> i32 {
        self.origin_z.unwrap_or_else(|| 0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: u32) {
        self.volume = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&'a mut self) -> &'a mut u32 {
        if self.volume.is_none() {
            self.volume = Some(0);
        };
        self.volume.as_mut().unwrap()
    }

    pub fn get_volume(&self) -> u32 {
        self.volume.unwrap_or_else(|| 0)
    }

    pub fn clear_delay_value(&mut self) {
        self.delay_value = None;
    }

    pub fn has_delay_value(&self) -> bool {
        self.delay_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_value(&mut self, v: f32) {
        self.delay_value = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delay_value(&'a mut self) -> &'a mut f32 {
        if self.delay_value.is_none() {
            self.delay_value = Some(0.);
        };
        self.delay_value.as_mut().unwrap()
    }

    pub fn get_delay_value(&self) -> f32 {
        self.delay_value.unwrap_or_else(|| 0.)
    }

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_number(&'a mut self) -> &'a mut i32 {
        if self.sequence_number.is_none() {
            self.sequence_number = Some(0);
        };
        self.sequence_number.as_mut().unwrap()
    }

    pub fn get_sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or_else(|| 0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_index(&'a mut self) -> &'a mut i32 {
        if self.entity_index.is_none() {
            self.entity_index = Some(0);
        };
        self.entity_index.as_mut().unwrap()
    }

    pub fn get_entity_index(&self) -> i32 {
        self.entity_index.unwrap_or_else(|| 0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&'a mut self) -> &'a mut i32 {
        if self.channel.is_none() {
            self.channel = Some(0);
        };
        self.channel.as_mut().unwrap()
    }

    pub fn get_channel(&self) -> i32 {
        self.channel.unwrap_or_else(|| 0)
    }

    pub fn clear_pitch(&mut self) {
        self.pitch = None;
    }

    pub fn has_pitch(&self) -> bool {
        self.pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: i32) {
        self.pitch = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pitch(&'a mut self) -> &'a mut i32 {
        if self.pitch.is_none() {
            self.pitch = Some(0);
        };
        self.pitch.as_mut().unwrap()
    }

    pub fn get_pitch(&self) -> i32 {
        self.pitch.unwrap_or_else(|| 0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&'a mut self) -> &'a mut i32 {
        if self.flags.is_none() {
            self.flags = Some(0);
        };
        self.flags.as_mut().unwrap()
    }

    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or_else(|| 0)
    }

    pub fn clear_sound_num(&mut self) {
        self.sound_num = None;
    }

    pub fn has_sound_num(&self) -> bool {
        self.sound_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_num(&mut self, v: u32) {
        self.sound_num = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound_num(&'a mut self) -> &'a mut u32 {
        if self.sound_num.is_none() {
            self.sound_num = Some(0);
        };
        self.sound_num.as_mut().unwrap()
    }

    pub fn get_sound_num(&self) -> u32 {
        self.sound_num.unwrap_or_else(|| 0)
    }

    pub fn clear_sound_num_handle(&mut self) {
        self.sound_num_handle = None;
    }

    pub fn has_sound_num_handle(&self) -> bool {
        self.sound_num_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_num_handle(&mut self, v: u32) {
        self.sound_num_handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound_num_handle(&'a mut self) -> &'a mut u32 {
        if self.sound_num_handle.is_none() {
            self.sound_num_handle = Some(0);
        };
        self.sound_num_handle.as_mut().unwrap()
    }

    pub fn get_sound_num_handle(&self) -> u32 {
        self.sound_num_handle.unwrap_or_else(|| 0)
    }

    pub fn clear_speaker_entity(&mut self) {
        self.speaker_entity = None;
    }

    pub fn has_speaker_entity(&self) -> bool {
        self.speaker_entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speaker_entity(&mut self, v: i32) {
        self.speaker_entity = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speaker_entity(&'a mut self) -> &'a mut i32 {
        if self.speaker_entity.is_none() {
            self.speaker_entity = Some(0);
        };
        self.speaker_entity.as_mut().unwrap()
    }

    pub fn get_speaker_entity(&self) -> i32 {
        self.speaker_entity.unwrap_or_else(|| 0)
    }

    pub fn clear_random_seed(&mut self) {
        self.random_seed = None;
    }

    pub fn has_random_seed(&self) -> bool {
        self.random_seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_seed(&mut self, v: i32) {
        self.random_seed = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_random_seed(&'a mut self) -> &'a mut i32 {
        if self.random_seed.is_none() {
            self.random_seed = Some(0);
        };
        self.random_seed.as_mut().unwrap()
    }

    pub fn get_random_seed(&self) -> i32 {
        self.random_seed.unwrap_or_else(|| 0)
    }

    pub fn clear_sound_level(&mut self) {
        self.sound_level = None;
    }

    pub fn has_sound_level(&self) -> bool {
        self.sound_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_level(&mut self, v: i32) {
        self.sound_level = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound_level(&'a mut self) -> &'a mut i32 {
        if self.sound_level.is_none() {
            self.sound_level = Some(0);
        };
        self.sound_level.as_mut().unwrap()
    }

    pub fn get_sound_level(&self) -> i32 {
        self.sound_level.unwrap_or_else(|| 0)
    }

    pub fn clear_is_sentence(&mut self) {
        self.is_sentence = None;
    }

    pub fn has_is_sentence(&self) -> bool {
        self.is_sentence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_sentence(&mut self, v: bool) {
        self.is_sentence = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_sentence(&'a mut self) -> &'a mut bool {
        if self.is_sentence.is_none() {
            self.is_sentence = Some(false);
        };
        self.is_sentence.as_mut().unwrap()
    }

    pub fn get_is_sentence(&self) -> bool {
        self.is_sentence.unwrap_or_else(|| false)
    }

    pub fn clear_is_ambient(&mut self) {
        self.is_ambient = None;
    }

    pub fn has_is_ambient(&self) -> bool {
        self.is_ambient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ambient(&mut self, v: bool) {
        self.is_ambient = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_ambient(&'a mut self) -> &'a mut bool {
        if self.is_ambient.is_none() {
            self.is_ambient = Some(false);
        };
        self.is_ambient.as_mut().unwrap()
    }

    pub fn get_is_ambient(&self) -> bool {
        self.is_ambient.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CSVCMsg_Sounds_sounddata_t {
    fn new() -> CSVCMsg_Sounds_sounddata_t {
        CSVCMsg_Sounds_sounddata_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.origin_x = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.origin_y = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.origin_z = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.volume = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.delay_value = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.sequence_number = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_index = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.channel = Some(tmp);
                },
                9 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.pitch = Some(tmp);
                },
                10 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.flags = Some(tmp);
                },
                11 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.sound_num = Some(tmp);
                },
                12 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.sound_num_handle = Some(tmp);
                },
                13 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.speaker_entity = Some(tmp);
                },
                14 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.random_seed = Some(tmp);
                },
                15 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.sound_level = Some(tmp);
                },
                16 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_sentence = Some(tmp);
                },
                17 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_ambient = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.origin_x.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.origin_y.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.origin_z.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.volume.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.delay_value.is_some() {
            my_size += 5;
        };
        for value in self.sequence_number.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entity_index.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.pitch.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.flags.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sound_num.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.sound_num_handle.is_some() {
            my_size += 5;
        };
        for value in self.speaker_entity.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.random_seed.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sound_level.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_sentence.is_some() {
            my_size += 3;
        };
        if self.is_ambient.is_some() {
            my_size += 3;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.origin_x {
            Some(ref v) => {
                os.write_sint32(1, *v);
            },
            None => {},
        };
        match self.origin_y {
            Some(ref v) => {
                os.write_sint32(2, *v);
            },
            None => {},
        };
        match self.origin_z {
            Some(ref v) => {
                os.write_sint32(3, *v);
            },
            None => {},
        };
        match self.volume {
            Some(ref v) => {
                os.write_uint32(4, *v);
            },
            None => {},
        };
        match self.delay_value {
            Some(ref v) => {
                os.write_float(5, *v);
            },
            None => {},
        };
        match self.sequence_number {
            Some(ref v) => {
                os.write_int32(6, *v);
            },
            None => {},
        };
        match self.entity_index {
            Some(ref v) => {
                os.write_int32(7, *v);
            },
            None => {},
        };
        match self.channel {
            Some(ref v) => {
                os.write_int32(8, *v);
            },
            None => {},
        };
        match self.pitch {
            Some(ref v) => {
                os.write_int32(9, *v);
            },
            None => {},
        };
        match self.flags {
            Some(ref v) => {
                os.write_int32(10, *v);
            },
            None => {},
        };
        match self.sound_num {
            Some(ref v) => {
                os.write_uint32(11, *v);
            },
            None => {},
        };
        match self.sound_num_handle {
            Some(ref v) => {
                os.write_fixed32(12, *v);
            },
            None => {},
        };
        match self.speaker_entity {
            Some(ref v) => {
                os.write_int32(13, *v);
            },
            None => {},
        };
        match self.random_seed {
            Some(ref v) => {
                os.write_int32(14, *v);
            },
            None => {},
        };
        match self.sound_level {
            Some(ref v) => {
                os.write_int32(15, *v);
            },
            None => {},
        };
        match self.is_sentence {
            Some(ref v) => {
                os.write_bool(16, *v);
            },
            None => {},
        };
        match self.is_ambient {
            Some(ref v) => {
                os.write_bool(17, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_Sounds_sounddata_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_origin_x_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_origin_y_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_origin_z_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_volume_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_delay_value_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_sequence_number_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_entity_index_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_channel_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_pitch_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_flags_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_sound_num_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_sound_num_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_speaker_entity_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_random_seed_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_sound_level_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_is_sentence_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Sounds_sounddata_t_is_ambient_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_Sounds_sounddata_t>(
                    "CSVCMsg_Sounds_sounddata_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_Sounds_sounddata_t>()
    }
}

impl ::protobuf::Clear for CSVCMsg_Sounds_sounddata_t {
    fn clear(&mut self) {
        self.clear_origin_x();
        self.clear_origin_y();
        self.clear_origin_z();
        self.clear_volume();
        self.clear_delay_value();
        self.clear_sequence_number();
        self.clear_entity_index();
        self.clear_channel();
        self.clear_pitch();
        self.clear_flags();
        self.clear_sound_num();
        self.clear_sound_num_handle();
        self.clear_speaker_entity();
        self.clear_random_seed();
        self.clear_sound_level();
        self.clear_is_sentence();
        self.clear_is_ambient();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_Sounds_sounddata_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_origin_x_acc_type;
static CSVCMsg_Sounds_sounddata_t_origin_x_acc: CSVCMsg_Sounds_sounddata_t_origin_x_acc_type = CSVCMsg_Sounds_sounddata_t_origin_x_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_origin_x_acc_type {
    fn name(&self) -> &'static str {
        "origin_x"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_origin_x()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_origin_x()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_origin_y_acc_type;
static CSVCMsg_Sounds_sounddata_t_origin_y_acc: CSVCMsg_Sounds_sounddata_t_origin_y_acc_type = CSVCMsg_Sounds_sounddata_t_origin_y_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_origin_y_acc_type {
    fn name(&self) -> &'static str {
        "origin_y"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_origin_y()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_origin_y()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_origin_z_acc_type;
static CSVCMsg_Sounds_sounddata_t_origin_z_acc: CSVCMsg_Sounds_sounddata_t_origin_z_acc_type = CSVCMsg_Sounds_sounddata_t_origin_z_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_origin_z_acc_type {
    fn name(&self) -> &'static str {
        "origin_z"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_origin_z()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_origin_z()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_volume_acc_type;
static CSVCMsg_Sounds_sounddata_t_volume_acc: CSVCMsg_Sounds_sounddata_t_volume_acc_type = CSVCMsg_Sounds_sounddata_t_volume_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_volume_acc_type {
    fn name(&self) -> &'static str {
        "volume"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_volume()
    }

    fn get_u32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> u32 {
        m.get_volume()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_delay_value_acc_type;
static CSVCMsg_Sounds_sounddata_t_delay_value_acc: CSVCMsg_Sounds_sounddata_t_delay_value_acc_type = CSVCMsg_Sounds_sounddata_t_delay_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_delay_value_acc_type {
    fn name(&self) -> &'static str {
        "delay_value"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_delay_value()
    }

    fn get_f32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> f32 {
        m.get_delay_value()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_sequence_number_acc_type;
static CSVCMsg_Sounds_sounddata_t_sequence_number_acc: CSVCMsg_Sounds_sounddata_t_sequence_number_acc_type = CSVCMsg_Sounds_sounddata_t_sequence_number_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_sequence_number_acc_type {
    fn name(&self) -> &'static str {
        "sequence_number"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_sequence_number()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_sequence_number()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_entity_index_acc_type;
static CSVCMsg_Sounds_sounddata_t_entity_index_acc: CSVCMsg_Sounds_sounddata_t_entity_index_acc_type = CSVCMsg_Sounds_sounddata_t_entity_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_entity_index_acc_type {
    fn name(&self) -> &'static str {
        "entity_index"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_entity_index()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_entity_index()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_channel_acc_type;
static CSVCMsg_Sounds_sounddata_t_channel_acc: CSVCMsg_Sounds_sounddata_t_channel_acc_type = CSVCMsg_Sounds_sounddata_t_channel_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_channel_acc_type {
    fn name(&self) -> &'static str {
        "channel"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_channel()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_channel()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_pitch_acc_type;
static CSVCMsg_Sounds_sounddata_t_pitch_acc: CSVCMsg_Sounds_sounddata_t_pitch_acc_type = CSVCMsg_Sounds_sounddata_t_pitch_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_pitch_acc_type {
    fn name(&self) -> &'static str {
        "pitch"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_pitch()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_pitch()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_flags_acc_type;
static CSVCMsg_Sounds_sounddata_t_flags_acc: CSVCMsg_Sounds_sounddata_t_flags_acc_type = CSVCMsg_Sounds_sounddata_t_flags_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_flags_acc_type {
    fn name(&self) -> &'static str {
        "flags"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_flags()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_flags()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_sound_num_acc_type;
static CSVCMsg_Sounds_sounddata_t_sound_num_acc: CSVCMsg_Sounds_sounddata_t_sound_num_acc_type = CSVCMsg_Sounds_sounddata_t_sound_num_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_sound_num_acc_type {
    fn name(&self) -> &'static str {
        "sound_num"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_sound_num()
    }

    fn get_u32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> u32 {
        m.get_sound_num()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_sound_num_handle_acc_type;
static CSVCMsg_Sounds_sounddata_t_sound_num_handle_acc: CSVCMsg_Sounds_sounddata_t_sound_num_handle_acc_type = CSVCMsg_Sounds_sounddata_t_sound_num_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_sound_num_handle_acc_type {
    fn name(&self) -> &'static str {
        "sound_num_handle"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_sound_num_handle()
    }

    fn get_u32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> u32 {
        m.get_sound_num_handle()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_speaker_entity_acc_type;
static CSVCMsg_Sounds_sounddata_t_speaker_entity_acc: CSVCMsg_Sounds_sounddata_t_speaker_entity_acc_type = CSVCMsg_Sounds_sounddata_t_speaker_entity_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_speaker_entity_acc_type {
    fn name(&self) -> &'static str {
        "speaker_entity"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_speaker_entity()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_speaker_entity()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_random_seed_acc_type;
static CSVCMsg_Sounds_sounddata_t_random_seed_acc: CSVCMsg_Sounds_sounddata_t_random_seed_acc_type = CSVCMsg_Sounds_sounddata_t_random_seed_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_random_seed_acc_type {
    fn name(&self) -> &'static str {
        "random_seed"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_random_seed()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_random_seed()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_sound_level_acc_type;
static CSVCMsg_Sounds_sounddata_t_sound_level_acc: CSVCMsg_Sounds_sounddata_t_sound_level_acc_type = CSVCMsg_Sounds_sounddata_t_sound_level_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_sound_level_acc_type {
    fn name(&self) -> &'static str {
        "sound_level"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_sound_level()
    }

    fn get_i32(&self, m: &CSVCMsg_Sounds_sounddata_t) -> i32 {
        m.get_sound_level()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_is_sentence_acc_type;
static CSVCMsg_Sounds_sounddata_t_is_sentence_acc: CSVCMsg_Sounds_sounddata_t_is_sentence_acc_type = CSVCMsg_Sounds_sounddata_t_is_sentence_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_is_sentence_acc_type {
    fn name(&self) -> &'static str {
        "is_sentence"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_is_sentence()
    }

    fn get_bool(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.get_is_sentence()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Sounds_sounddata_t_is_ambient_acc_type;
static CSVCMsg_Sounds_sounddata_t_is_ambient_acc: CSVCMsg_Sounds_sounddata_t_is_ambient_acc_type = CSVCMsg_Sounds_sounddata_t_is_ambient_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Sounds_sounddata_t> for CSVCMsg_Sounds_sounddata_t_is_ambient_acc_type {
    fn name(&self) -> &'static str {
        "is_ambient"
    }

    fn has_field(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.has_is_ambient()
    }

    fn get_bool(&self, m: &CSVCMsg_Sounds_sounddata_t) -> bool {
        m.get_is_ambient()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_Prefetch {
    sound_index: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_Prefetch {
    pub fn new() -> CSVCMsg_Prefetch {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_Prefetch {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_Prefetch> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_Prefetch };
        unsafe {
            instance.get(|| {
                CSVCMsg_Prefetch {
                    sound_index: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_sound_index(&mut self) {
        self.sound_index = None;
    }

    pub fn has_sound_index(&self) -> bool {
        self.sound_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_index(&mut self, v: i32) {
        self.sound_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound_index(&'a mut self) -> &'a mut i32 {
        if self.sound_index.is_none() {
            self.sound_index = Some(0);
        };
        self.sound_index.as_mut().unwrap()
    }

    pub fn get_sound_index(&self) -> i32 {
        self.sound_index.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CSVCMsg_Prefetch {
    fn new() -> CSVCMsg_Prefetch {
        CSVCMsg_Prefetch::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.sound_index = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.sound_index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.sound_index {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_Prefetch>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Prefetch>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Prefetch_sound_index_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Prefetch>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_Prefetch>(
                    "CSVCMsg_Prefetch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_Prefetch>()
    }
}

impl ::protobuf::Clear for CSVCMsg_Prefetch {
    fn clear(&mut self) {
        self.clear_sound_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_Prefetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_Prefetch_sound_index_acc_type;
static CSVCMsg_Prefetch_sound_index_acc: CSVCMsg_Prefetch_sound_index_acc_type = CSVCMsg_Prefetch_sound_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Prefetch> for CSVCMsg_Prefetch_sound_index_acc_type {
    fn name(&self) -> &'static str {
        "sound_index"
    }

    fn has_field(&self, m: &CSVCMsg_Prefetch) -> bool {
        m.has_sound_index()
    }

    fn get_i32(&self, m: &CSVCMsg_Prefetch) -> i32 {
        m.get_sound_index()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_SetView {
    entity_index: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_SetView {
    pub fn new() -> CSVCMsg_SetView {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_SetView {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_SetView> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_SetView };
        unsafe {
            instance.get(|| {
                CSVCMsg_SetView {
                    entity_index: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_index(&'a mut self) -> &'a mut i32 {
        if self.entity_index.is_none() {
            self.entity_index = Some(0);
        };
        self.entity_index.as_mut().unwrap()
    }

    pub fn get_entity_index(&self) -> i32 {
        self.entity_index.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CSVCMsg_SetView {
    fn new() -> CSVCMsg_SetView {
        CSVCMsg_SetView::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_index = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.entity_index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.entity_index {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_SetView>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SetView>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SetView_entity_index_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SetView>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_SetView>(
                    "CSVCMsg_SetView",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_SetView>()
    }
}

impl ::protobuf::Clear for CSVCMsg_SetView {
    fn clear(&mut self) {
        self.clear_entity_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_SetView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_SetView_entity_index_acc_type;
static CSVCMsg_SetView_entity_index_acc: CSVCMsg_SetView_entity_index_acc_type = CSVCMsg_SetView_entity_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SetView> for CSVCMsg_SetView_entity_index_acc_type {
    fn name(&self) -> &'static str {
        "entity_index"
    }

    fn has_field(&self, m: &CSVCMsg_SetView) -> bool {
        m.has_entity_index()
    }

    fn get_i32(&self, m: &CSVCMsg_SetView) -> i32 {
        m.get_entity_index()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_FixAngle {
    relative: Option<bool>,
    angle: ::protobuf::SingularPtrField<CMsgQAngle>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_FixAngle {
    pub fn new() -> CSVCMsg_FixAngle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_FixAngle {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_FixAngle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_FixAngle };
        unsafe {
            instance.get(|| {
                CSVCMsg_FixAngle {
                    relative: None,
                    angle: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_relative(&mut self) {
        self.relative = None;
    }

    pub fn has_relative(&self) -> bool {
        self.relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative(&mut self, v: bool) {
        self.relative = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relative(&'a mut self) -> &'a mut bool {
        if self.relative.is_none() {
            self.relative = Some(false);
        };
        self.relative.as_mut().unwrap()
    }

    pub fn get_relative(&self) -> bool {
        self.relative.unwrap_or_else(|| false)
    }

    pub fn clear_angle(&mut self) {
        self.angle.clear();
    }

    pub fn has_angle(&self) -> bool {
        self.angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_angle(&mut self, v: CMsgQAngle) {
        self.angle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_angle(&'a mut self) -> &'a mut CMsgQAngle {
        if self.angle.is_none() {
            self.angle.set_default();
        };
        self.angle.as_mut().unwrap()
    }

    pub fn get_angle(&'a self) -> &'a CMsgQAngle {
        self.angle.as_ref().unwrap_or_else(|| CMsgQAngle::default_instance())
    }
}

impl ::protobuf::Message for CSVCMsg_FixAngle {
    fn new() -> CSVCMsg_FixAngle {
        CSVCMsg_FixAngle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.relative = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.angle.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.relative.is_some() {
            my_size += 2;
        };
        for value in self.angle.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.relative {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        match self.angle.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_FixAngle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_FixAngle>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_FixAngle_relative_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_FixAngle>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_FixAngle_angle_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_FixAngle>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_FixAngle>(
                    "CSVCMsg_FixAngle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_FixAngle>()
    }
}

impl ::protobuf::Clear for CSVCMsg_FixAngle {
    fn clear(&mut self) {
        self.clear_relative();
        self.clear_angle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_FixAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_FixAngle_relative_acc_type;
static CSVCMsg_FixAngle_relative_acc: CSVCMsg_FixAngle_relative_acc_type = CSVCMsg_FixAngle_relative_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_FixAngle> for CSVCMsg_FixAngle_relative_acc_type {
    fn name(&self) -> &'static str {
        "relative"
    }

    fn has_field(&self, m: &CSVCMsg_FixAngle) -> bool {
        m.has_relative()
    }

    fn get_bool(&self, m: &CSVCMsg_FixAngle) -> bool {
        m.get_relative()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_FixAngle_angle_acc_type;
static CSVCMsg_FixAngle_angle_acc: CSVCMsg_FixAngle_angle_acc_type = CSVCMsg_FixAngle_angle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_FixAngle> for CSVCMsg_FixAngle_angle_acc_type {
    fn name(&self) -> &'static str {
        "angle"
    }

    fn has_field(&self, m: &CSVCMsg_FixAngle) -> bool {
        m.has_angle()
    }

    fn get_message<'a>(&self, m: &'a CSVCMsg_FixAngle) -> &'a ::protobuf::Message {
        m.get_angle() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_CrosshairAngle {
    angle: ::protobuf::SingularPtrField<CMsgQAngle>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_CrosshairAngle {
    pub fn new() -> CSVCMsg_CrosshairAngle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_CrosshairAngle {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_CrosshairAngle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_CrosshairAngle };
        unsafe {
            instance.get(|| {
                CSVCMsg_CrosshairAngle {
                    angle: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_angle(&mut self) {
        self.angle.clear();
    }

    pub fn has_angle(&self) -> bool {
        self.angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_angle(&mut self, v: CMsgQAngle) {
        self.angle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_angle(&'a mut self) -> &'a mut CMsgQAngle {
        if self.angle.is_none() {
            self.angle.set_default();
        };
        self.angle.as_mut().unwrap()
    }

    pub fn get_angle(&'a self) -> &'a CMsgQAngle {
        self.angle.as_ref().unwrap_or_else(|| CMsgQAngle::default_instance())
    }
}

impl ::protobuf::Message for CSVCMsg_CrosshairAngle {
    fn new() -> CSVCMsg_CrosshairAngle {
        CSVCMsg_CrosshairAngle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.angle.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.angle.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.angle.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_CrosshairAngle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CrosshairAngle>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CrosshairAngle_angle_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CrosshairAngle>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_CrosshairAngle>(
                    "CSVCMsg_CrosshairAngle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_CrosshairAngle>()
    }
}

impl ::protobuf::Clear for CSVCMsg_CrosshairAngle {
    fn clear(&mut self) {
        self.clear_angle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_CrosshairAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_CrosshairAngle_angle_acc_type;
static CSVCMsg_CrosshairAngle_angle_acc: CSVCMsg_CrosshairAngle_angle_acc_type = CSVCMsg_CrosshairAngle_angle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CrosshairAngle> for CSVCMsg_CrosshairAngle_angle_acc_type {
    fn name(&self) -> &'static str {
        "angle"
    }

    fn has_field(&self, m: &CSVCMsg_CrosshairAngle) -> bool {
        m.has_angle()
    }

    fn get_message<'a>(&self, m: &'a CSVCMsg_CrosshairAngle) -> &'a ::protobuf::Message {
        m.get_angle() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_BSPDecal {
    pos: ::protobuf::SingularPtrField<CMsgVector>,
    decal_texture_index: Option<i32>,
    entity_index: Option<i32>,
    model_index: Option<i32>,
    low_priority: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_BSPDecal {
    pub fn new() -> CSVCMsg_BSPDecal {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_BSPDecal {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_BSPDecal> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_BSPDecal };
        unsafe {
            instance.get(|| {
                CSVCMsg_BSPDecal {
                    pos: ::protobuf::SingularPtrField::none(),
                    decal_texture_index: None,
                    entity_index: None,
                    model_index: None,
                    low_priority: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: CMsgVector) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&'a mut self) -> &'a mut CMsgVector {
        if self.pos.is_none() {
            self.pos.set_default();
        };
        self.pos.as_mut().unwrap()
    }

    pub fn get_pos(&'a self) -> &'a CMsgVector {
        self.pos.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }

    pub fn clear_decal_texture_index(&mut self) {
        self.decal_texture_index = None;
    }

    pub fn has_decal_texture_index(&self) -> bool {
        self.decal_texture_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decal_texture_index(&mut self, v: i32) {
        self.decal_texture_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decal_texture_index(&'a mut self) -> &'a mut i32 {
        if self.decal_texture_index.is_none() {
            self.decal_texture_index = Some(0);
        };
        self.decal_texture_index.as_mut().unwrap()
    }

    pub fn get_decal_texture_index(&self) -> i32 {
        self.decal_texture_index.unwrap_or_else(|| 0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_index(&'a mut self) -> &'a mut i32 {
        if self.entity_index.is_none() {
            self.entity_index = Some(0);
        };
        self.entity_index.as_mut().unwrap()
    }

    pub fn get_entity_index(&self) -> i32 {
        self.entity_index.unwrap_or_else(|| 0)
    }

    pub fn clear_model_index(&mut self) {
        self.model_index = None;
    }

    pub fn has_model_index(&self) -> bool {
        self.model_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_index(&mut self, v: i32) {
        self.model_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_index(&'a mut self) -> &'a mut i32 {
        if self.model_index.is_none() {
            self.model_index = Some(0);
        };
        self.model_index.as_mut().unwrap()
    }

    pub fn get_model_index(&self) -> i32 {
        self.model_index.unwrap_or_else(|| 0)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_low_priority(&'a mut self) -> &'a mut bool {
        if self.low_priority.is_none() {
            self.low_priority = Some(false);
        };
        self.low_priority.as_mut().unwrap()
    }

    pub fn get_low_priority(&self) -> bool {
        self.low_priority.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CSVCMsg_BSPDecal {
    fn new() -> CSVCMsg_BSPDecal {
        CSVCMsg_BSPDecal::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.pos.set_default();
                    is.merge_message(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.decal_texture_index = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_index = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.model_index = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.low_priority = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.pos.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.decal_texture_index.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entity_index.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.model_index.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.low_priority.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.pos.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.decal_texture_index {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.entity_index {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.model_index {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.low_priority {
            Some(ref v) => {
                os.write_bool(5, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_BSPDecal>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_BSPDecal_pos_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_BSPDecal_decal_texture_index_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_BSPDecal_entity_index_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_BSPDecal_model_index_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_BSPDecal_low_priority_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_BSPDecal>(
                    "CSVCMsg_BSPDecal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_BSPDecal>()
    }
}

impl ::protobuf::Clear for CSVCMsg_BSPDecal {
    fn clear(&mut self) {
        self.clear_pos();
        self.clear_decal_texture_index();
        self.clear_entity_index();
        self.clear_model_index();
        self.clear_low_priority();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_BSPDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_BSPDecal_pos_acc_type;
static CSVCMsg_BSPDecal_pos_acc: CSVCMsg_BSPDecal_pos_acc_type = CSVCMsg_BSPDecal_pos_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal> for CSVCMsg_BSPDecal_pos_acc_type {
    fn name(&self) -> &'static str {
        "pos"
    }

    fn has_field(&self, m: &CSVCMsg_BSPDecal) -> bool {
        m.has_pos()
    }

    fn get_message<'a>(&self, m: &'a CSVCMsg_BSPDecal) -> &'a ::protobuf::Message {
        m.get_pos() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_BSPDecal_decal_texture_index_acc_type;
static CSVCMsg_BSPDecal_decal_texture_index_acc: CSVCMsg_BSPDecal_decal_texture_index_acc_type = CSVCMsg_BSPDecal_decal_texture_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal> for CSVCMsg_BSPDecal_decal_texture_index_acc_type {
    fn name(&self) -> &'static str {
        "decal_texture_index"
    }

    fn has_field(&self, m: &CSVCMsg_BSPDecal) -> bool {
        m.has_decal_texture_index()
    }

    fn get_i32(&self, m: &CSVCMsg_BSPDecal) -> i32 {
        m.get_decal_texture_index()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_BSPDecal_entity_index_acc_type;
static CSVCMsg_BSPDecal_entity_index_acc: CSVCMsg_BSPDecal_entity_index_acc_type = CSVCMsg_BSPDecal_entity_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal> for CSVCMsg_BSPDecal_entity_index_acc_type {
    fn name(&self) -> &'static str {
        "entity_index"
    }

    fn has_field(&self, m: &CSVCMsg_BSPDecal) -> bool {
        m.has_entity_index()
    }

    fn get_i32(&self, m: &CSVCMsg_BSPDecal) -> i32 {
        m.get_entity_index()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_BSPDecal_model_index_acc_type;
static CSVCMsg_BSPDecal_model_index_acc: CSVCMsg_BSPDecal_model_index_acc_type = CSVCMsg_BSPDecal_model_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal> for CSVCMsg_BSPDecal_model_index_acc_type {
    fn name(&self) -> &'static str {
        "model_index"
    }

    fn has_field(&self, m: &CSVCMsg_BSPDecal) -> bool {
        m.has_model_index()
    }

    fn get_i32(&self, m: &CSVCMsg_BSPDecal) -> i32 {
        m.get_model_index()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_BSPDecal_low_priority_acc_type;
static CSVCMsg_BSPDecal_low_priority_acc: CSVCMsg_BSPDecal_low_priority_acc_type = CSVCMsg_BSPDecal_low_priority_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_BSPDecal> for CSVCMsg_BSPDecal_low_priority_acc_type {
    fn name(&self) -> &'static str {
        "low_priority"
    }

    fn has_field(&self, m: &CSVCMsg_BSPDecal) -> bool {
        m.has_low_priority()
    }

    fn get_bool(&self, m: &CSVCMsg_BSPDecal) -> bool {
        m.get_low_priority()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_SplitScreen {
    field_type: Option<ESplitScreenMessageType>,
    slot: Option<i32>,
    player_index: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_SplitScreen {
    pub fn new() -> CSVCMsg_SplitScreen {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_SplitScreen {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_SplitScreen> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_SplitScreen };
        unsafe {
            instance.get(|| {
                CSVCMsg_SplitScreen {
                    field_type: None,
                    slot: None,
                    player_index: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ESplitScreenMessageType) {
        self.field_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&'a mut self) -> &'a mut ESplitScreenMessageType {
        if self.field_type.is_none() {
            self.field_type = Some(ESplitScreenMessageType::new(0));
        };
        self.field_type.as_mut().unwrap()
    }

    pub fn get_field_type(&self) -> ESplitScreenMessageType {
        self.field_type.unwrap_or_else(|| ESplitScreenMessageType::new(0))
    }

    pub fn clear_slot(&mut self) {
        self.slot = None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot(&'a mut self) -> &'a mut i32 {
        if self.slot.is_none() {
            self.slot = Some(0);
        };
        self.slot.as_mut().unwrap()
    }

    pub fn get_slot(&self) -> i32 {
        self.slot.unwrap_or_else(|| 0)
    }

    pub fn clear_player_index(&mut self) {
        self.player_index = None;
    }

    pub fn has_player_index(&self) -> bool {
        self.player_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_index(&mut self, v: i32) {
        self.player_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_index(&'a mut self) -> &'a mut i32 {
        if self.player_index.is_none() {
            self.player_index = Some(0);
        };
        self.player_index.as_mut().unwrap()
    }

    pub fn get_player_index(&self) -> i32 {
        self.player_index.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CSVCMsg_SplitScreen {
    fn new() -> CSVCMsg_SplitScreen {
        CSVCMsg_SplitScreen::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = ESplitScreenMessageType::new(is.read_int32());
                    self.field_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.slot = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.player_index = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.slot.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.player_index.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.field_type {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        match self.slot {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.player_index {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_SplitScreen>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SplitScreen>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SplitScreen_field_type_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SplitScreen>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SplitScreen_slot_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SplitScreen>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SplitScreen_player_index_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SplitScreen>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_SplitScreen>(
                    "CSVCMsg_SplitScreen",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_SplitScreen>()
    }
}

impl ::protobuf::Clear for CSVCMsg_SplitScreen {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_slot();
        self.clear_player_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_SplitScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_SplitScreen_field_type_acc_type;
static CSVCMsg_SplitScreen_field_type_acc: CSVCMsg_SplitScreen_field_type_acc_type = CSVCMsg_SplitScreen_field_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SplitScreen> for CSVCMsg_SplitScreen_field_type_acc_type {
    fn name(&self) -> &'static str {
        "field_type"
    }

    fn has_field(&self, m: &CSVCMsg_SplitScreen) -> bool {
        m.has_field_type()
    }

    fn get_enum<'a>(&self, m: &CSVCMsg_SplitScreen) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_field_type().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SplitScreen_slot_acc_type;
static CSVCMsg_SplitScreen_slot_acc: CSVCMsg_SplitScreen_slot_acc_type = CSVCMsg_SplitScreen_slot_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SplitScreen> for CSVCMsg_SplitScreen_slot_acc_type {
    fn name(&self) -> &'static str {
        "slot"
    }

    fn has_field(&self, m: &CSVCMsg_SplitScreen) -> bool {
        m.has_slot()
    }

    fn get_i32(&self, m: &CSVCMsg_SplitScreen) -> i32 {
        m.get_slot()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SplitScreen_player_index_acc_type;
static CSVCMsg_SplitScreen_player_index_acc: CSVCMsg_SplitScreen_player_index_acc_type = CSVCMsg_SplitScreen_player_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SplitScreen> for CSVCMsg_SplitScreen_player_index_acc_type {
    fn name(&self) -> &'static str {
        "player_index"
    }

    fn has_field(&self, m: &CSVCMsg_SplitScreen) -> bool {
        m.has_player_index()
    }

    fn get_i32(&self, m: &CSVCMsg_SplitScreen) -> i32 {
        m.get_player_index()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_GetCvarValue {
    cookie: Option<i32>,
    cvar_name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_GetCvarValue {
    pub fn new() -> CSVCMsg_GetCvarValue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_GetCvarValue {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_GetCvarValue> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_GetCvarValue };
        unsafe {
            instance.get(|| {
                CSVCMsg_GetCvarValue {
                    cookie: None,
                    cvar_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&'a mut self) -> &'a mut i32 {
        if self.cookie.is_none() {
            self.cookie = Some(0);
        };
        self.cookie.as_mut().unwrap()
    }

    pub fn get_cookie(&self) -> i32 {
        self.cookie.unwrap_or_else(|| 0)
    }

    pub fn clear_cvar_name(&mut self) {
        self.cvar_name.clear();
    }

    pub fn has_cvar_name(&self) -> bool {
        self.cvar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cvar_name(&mut self, v: String) {
        self.cvar_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cvar_name(&'a mut self) -> &'a mut String {
        if self.cvar_name.is_none() {
            self.cvar_name.set_default();
        };
        self.cvar_name.as_mut().unwrap()
    }

    pub fn get_cvar_name(&'a self) -> &'a str {
        match self.cvar_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CSVCMsg_GetCvarValue {
    fn new() -> CSVCMsg_GetCvarValue {
        CSVCMsg_GetCvarValue::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.cookie = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.cvar_name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.cookie.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cvar_name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.cookie {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.cvar_name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_GetCvarValue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GetCvarValue>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GetCvarValue_cookie_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GetCvarValue>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GetCvarValue_cvar_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GetCvarValue>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_GetCvarValue>(
                    "CSVCMsg_GetCvarValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_GetCvarValue>()
    }
}

impl ::protobuf::Clear for CSVCMsg_GetCvarValue {
    fn clear(&mut self) {
        self.clear_cookie();
        self.clear_cvar_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_GetCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_GetCvarValue_cookie_acc_type;
static CSVCMsg_GetCvarValue_cookie_acc: CSVCMsg_GetCvarValue_cookie_acc_type = CSVCMsg_GetCvarValue_cookie_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GetCvarValue> for CSVCMsg_GetCvarValue_cookie_acc_type {
    fn name(&self) -> &'static str {
        "cookie"
    }

    fn has_field(&self, m: &CSVCMsg_GetCvarValue) -> bool {
        m.has_cookie()
    }

    fn get_i32(&self, m: &CSVCMsg_GetCvarValue) -> i32 {
        m.get_cookie()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GetCvarValue_cvar_name_acc_type;
static CSVCMsg_GetCvarValue_cvar_name_acc: CSVCMsg_GetCvarValue_cvar_name_acc_type = CSVCMsg_GetCvarValue_cvar_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GetCvarValue> for CSVCMsg_GetCvarValue_cvar_name_acc_type {
    fn name(&self) -> &'static str {
        "cvar_name"
    }

    fn has_field(&self, m: &CSVCMsg_GetCvarValue) -> bool {
        m.has_cvar_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_GetCvarValue) -> &'a str {
        m.get_cvar_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_Menu {
    dialog_type: Option<i32>,
    menu_key_values: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_Menu {
    pub fn new() -> CSVCMsg_Menu {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_Menu {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_Menu> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_Menu };
        unsafe {
            instance.get(|| {
                CSVCMsg_Menu {
                    dialog_type: None,
                    menu_key_values: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_dialog_type(&mut self) {
        self.dialog_type = None;
    }

    pub fn has_dialog_type(&self) -> bool {
        self.dialog_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_type(&mut self, v: i32) {
        self.dialog_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dialog_type(&'a mut self) -> &'a mut i32 {
        if self.dialog_type.is_none() {
            self.dialog_type = Some(0);
        };
        self.dialog_type.as_mut().unwrap()
    }

    pub fn get_dialog_type(&self) -> i32 {
        self.dialog_type.unwrap_or_else(|| 0)
    }

    pub fn clear_menu_key_values(&mut self) {
        self.menu_key_values.clear();
    }

    pub fn has_menu_key_values(&self) -> bool {
        self.menu_key_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_key_values(&mut self, v: Vec<u8>) {
        self.menu_key_values = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_key_values(&'a mut self) -> &'a mut Vec<u8> {
        if self.menu_key_values.is_none() {
            self.menu_key_values.set_default();
        };
        self.menu_key_values.as_mut().unwrap()
    }

    pub fn get_menu_key_values(&'a self) -> &'a [u8] {
        match self.menu_key_values.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CSVCMsg_Menu {
    fn new() -> CSVCMsg_Menu {
        CSVCMsg_Menu::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.dialog_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.menu_key_values.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.dialog_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.menu_key_values.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.dialog_type {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.menu_key_values.as_ref() {
            Some(ref v) => {
                os.write_bytes(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_Menu>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Menu>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Menu_dialog_type_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Menu>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_Menu_menu_key_values_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_Menu>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_Menu>(
                    "CSVCMsg_Menu",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_Menu>()
    }
}

impl ::protobuf::Clear for CSVCMsg_Menu {
    fn clear(&mut self) {
        self.clear_dialog_type();
        self.clear_menu_key_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_Menu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_Menu_dialog_type_acc_type;
static CSVCMsg_Menu_dialog_type_acc: CSVCMsg_Menu_dialog_type_acc_type = CSVCMsg_Menu_dialog_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Menu> for CSVCMsg_Menu_dialog_type_acc_type {
    fn name(&self) -> &'static str {
        "dialog_type"
    }

    fn has_field(&self, m: &CSVCMsg_Menu) -> bool {
        m.has_dialog_type()
    }

    fn get_i32(&self, m: &CSVCMsg_Menu) -> i32 {
        m.get_dialog_type()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_Menu_menu_key_values_acc_type;
static CSVCMsg_Menu_menu_key_values_acc: CSVCMsg_Menu_menu_key_values_acc_type = CSVCMsg_Menu_menu_key_values_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_Menu> for CSVCMsg_Menu_menu_key_values_acc_type {
    fn name(&self) -> &'static str {
        "menu_key_values"
    }

    fn has_field(&self, m: &CSVCMsg_Menu) -> bool {
        m.has_menu_key_values()
    }

    fn get_bytes<'a>(&self, m: &'a CSVCMsg_Menu) -> &'a [u8] {
        m.get_menu_key_values()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_SendTable {
    is_end: Option<bool>,
    net_table_name: ::protobuf::SingularField<String>,
    needs_decoder: Option<bool>,
    props: ::protobuf::RepeatedField<CSVCMsg_SendTable_sendprop_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_SendTable {
    pub fn new() -> CSVCMsg_SendTable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_SendTable {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_SendTable> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_SendTable };
        unsafe {
            instance.get(|| {
                CSVCMsg_SendTable {
                    is_end: None,
                    net_table_name: ::protobuf::SingularField::none(),
                    needs_decoder: None,
                    props: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_is_end(&mut self) {
        self.is_end = None;
    }

    pub fn has_is_end(&self) -> bool {
        self.is_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_end(&mut self, v: bool) {
        self.is_end = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_end(&'a mut self) -> &'a mut bool {
        if self.is_end.is_none() {
            self.is_end = Some(false);
        };
        self.is_end.as_mut().unwrap()
    }

    pub fn get_is_end(&self) -> bool {
        self.is_end.unwrap_or_else(|| false)
    }

    pub fn clear_net_table_name(&mut self) {
        self.net_table_name.clear();
    }

    pub fn has_net_table_name(&self) -> bool {
        self.net_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_table_name(&mut self, v: String) {
        self.net_table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_table_name(&'a mut self) -> &'a mut String {
        if self.net_table_name.is_none() {
            self.net_table_name.set_default();
        };
        self.net_table_name.as_mut().unwrap()
    }

    pub fn get_net_table_name(&'a self) -> &'a str {
        match self.net_table_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_needs_decoder(&mut self) {
        self.needs_decoder = None;
    }

    pub fn has_needs_decoder(&self) -> bool {
        self.needs_decoder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_decoder(&mut self, v: bool) {
        self.needs_decoder = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_needs_decoder(&'a mut self) -> &'a mut bool {
        if self.needs_decoder.is_none() {
            self.needs_decoder = Some(false);
        };
        self.needs_decoder.as_mut().unwrap()
    }

    pub fn get_needs_decoder(&self) -> bool {
        self.needs_decoder.unwrap_or_else(|| false)
    }

    pub fn clear_props(&mut self) {
        self.props.clear();
    }

    // Param is passed by value, moved
    pub fn set_props(&mut self, v: ::protobuf::RepeatedField<CSVCMsg_SendTable_sendprop_t>) {
        self.props = v;
    }

    // Mutable pointer to the field.
    pub fn mut_props(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsg_SendTable_sendprop_t> {
        &mut self.props
    }

    pub fn get_props(&'a self) -> &'a [CSVCMsg_SendTable_sendprop_t] {
        self.props.as_slice()
    }

    pub fn add_props(&mut self, v: CSVCMsg_SendTable_sendprop_t) {
        self.props.push(v);
    }
}

impl ::protobuf::Message for CSVCMsg_SendTable {
    fn new() -> CSVCMsg_SendTable {
        CSVCMsg_SendTable::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_end = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.net_table_name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.needs_decoder = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.props.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.is_end.is_some() {
            my_size += 2;
        };
        for value in self.net_table_name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        if self.needs_decoder.is_some() {
            my_size += 2;
        };
        for value in self.props.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.is_end {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        match self.net_table_name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.needs_decoder {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        for v in self.props.iter() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_SendTable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_is_end_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_net_table_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_needs_decoder_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_props_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_SendTable>(
                    "CSVCMsg_SendTable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_SendTable>()
    }
}

impl ::protobuf::Clear for CSVCMsg_SendTable {
    fn clear(&mut self) {
        self.clear_is_end();
        self.clear_net_table_name();
        self.clear_needs_decoder();
        self.clear_props();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_SendTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_is_end_acc_type;
static CSVCMsg_SendTable_is_end_acc: CSVCMsg_SendTable_is_end_acc_type = CSVCMsg_SendTable_is_end_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable> for CSVCMsg_SendTable_is_end_acc_type {
    fn name(&self) -> &'static str {
        "is_end"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable) -> bool {
        m.has_is_end()
    }

    fn get_bool(&self, m: &CSVCMsg_SendTable) -> bool {
        m.get_is_end()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_net_table_name_acc_type;
static CSVCMsg_SendTable_net_table_name_acc: CSVCMsg_SendTable_net_table_name_acc_type = CSVCMsg_SendTable_net_table_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable> for CSVCMsg_SendTable_net_table_name_acc_type {
    fn name(&self) -> &'static str {
        "net_table_name"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable) -> bool {
        m.has_net_table_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_SendTable) -> &'a str {
        m.get_net_table_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_needs_decoder_acc_type;
static CSVCMsg_SendTable_needs_decoder_acc: CSVCMsg_SendTable_needs_decoder_acc_type = CSVCMsg_SendTable_needs_decoder_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable> for CSVCMsg_SendTable_needs_decoder_acc_type {
    fn name(&self) -> &'static str {
        "needs_decoder"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable) -> bool {
        m.has_needs_decoder()
    }

    fn get_bool(&self, m: &CSVCMsg_SendTable) -> bool {
        m.get_needs_decoder()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_props_acc_type;
static CSVCMsg_SendTable_props_acc: CSVCMsg_SendTable_props_acc_type = CSVCMsg_SendTable_props_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable> for CSVCMsg_SendTable_props_acc_type {
    fn name(&self) -> &'static str {
        "props"
    }

    fn len_field(&self, m: &CSVCMsg_SendTable) -> uint {
        m.get_props().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsg_SendTable, index: uint) -> &'a ::protobuf::Message {
        &m.get_props()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_SendTable_sendprop_t {
    field_type: Option<i32>,
    var_name: ::protobuf::SingularField<String>,
    flags: Option<i32>,
    priority: Option<i32>,
    dt_name: ::protobuf::SingularField<String>,
    num_elements: Option<i32>,
    low_value: Option<f32>,
    high_value: Option<f32>,
    num_bits: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_SendTable_sendprop_t {
    pub fn new() -> CSVCMsg_SendTable_sendprop_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_SendTable_sendprop_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_SendTable_sendprop_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_SendTable_sendprop_t };
        unsafe {
            instance.get(|| {
                CSVCMsg_SendTable_sendprop_t {
                    field_type: None,
                    var_name: ::protobuf::SingularField::none(),
                    flags: None,
                    priority: None,
                    dt_name: ::protobuf::SingularField::none(),
                    num_elements: None,
                    low_value: None,
                    high_value: None,
                    num_bits: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&'a mut self) -> &'a mut i32 {
        if self.field_type.is_none() {
            self.field_type = Some(0);
        };
        self.field_type.as_mut().unwrap()
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or_else(|| 0)
    }

    pub fn clear_var_name(&mut self) {
        self.var_name.clear();
    }

    pub fn has_var_name(&self) -> bool {
        self.var_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_name(&mut self, v: String) {
        self.var_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_var_name(&'a mut self) -> &'a mut String {
        if self.var_name.is_none() {
            self.var_name.set_default();
        };
        self.var_name.as_mut().unwrap()
    }

    pub fn get_var_name(&'a self) -> &'a str {
        match self.var_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_flags(&mut self) {
        self.flags = None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&'a mut self) -> &'a mut i32 {
        if self.flags.is_none() {
            self.flags = Some(0);
        };
        self.flags.as_mut().unwrap()
    }

    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or_else(|| 0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_priority(&'a mut self) -> &'a mut i32 {
        if self.priority.is_none() {
            self.priority = Some(0);
        };
        self.priority.as_mut().unwrap()
    }

    pub fn get_priority(&self) -> i32 {
        self.priority.unwrap_or_else(|| 0)
    }

    pub fn clear_dt_name(&mut self) {
        self.dt_name.clear();
    }

    pub fn has_dt_name(&self) -> bool {
        self.dt_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dt_name(&mut self, v: String) {
        self.dt_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dt_name(&'a mut self) -> &'a mut String {
        if self.dt_name.is_none() {
            self.dt_name.set_default();
        };
        self.dt_name.as_mut().unwrap()
    }

    pub fn get_dt_name(&'a self) -> &'a str {
        match self.dt_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_num_elements(&mut self) {
        self.num_elements = None;
    }

    pub fn has_num_elements(&self) -> bool {
        self.num_elements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_elements(&mut self, v: i32) {
        self.num_elements = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_elements(&'a mut self) -> &'a mut i32 {
        if self.num_elements.is_none() {
            self.num_elements = Some(0);
        };
        self.num_elements.as_mut().unwrap()
    }

    pub fn get_num_elements(&self) -> i32 {
        self.num_elements.unwrap_or_else(|| 0)
    }

    pub fn clear_low_value(&mut self) {
        self.low_value = None;
    }

    pub fn has_low_value(&self) -> bool {
        self.low_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_value(&mut self, v: f32) {
        self.low_value = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_low_value(&'a mut self) -> &'a mut f32 {
        if self.low_value.is_none() {
            self.low_value = Some(0.);
        };
        self.low_value.as_mut().unwrap()
    }

    pub fn get_low_value(&self) -> f32 {
        self.low_value.unwrap_or_else(|| 0.)
    }

    pub fn clear_high_value(&mut self) {
        self.high_value = None;
    }

    pub fn has_high_value(&self) -> bool {
        self.high_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_value(&mut self, v: f32) {
        self.high_value = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_high_value(&'a mut self) -> &'a mut f32 {
        if self.high_value.is_none() {
            self.high_value = Some(0.);
        };
        self.high_value.as_mut().unwrap()
    }

    pub fn get_high_value(&self) -> f32 {
        self.high_value.unwrap_or_else(|| 0.)
    }

    pub fn clear_num_bits(&mut self) {
        self.num_bits = None;
    }

    pub fn has_num_bits(&self) -> bool {
        self.num_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bits(&mut self, v: i32) {
        self.num_bits = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_bits(&'a mut self) -> &'a mut i32 {
        if self.num_bits.is_none() {
            self.num_bits = Some(0);
        };
        self.num_bits.as_mut().unwrap()
    }

    pub fn get_num_bits(&self) -> i32 {
        self.num_bits.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CSVCMsg_SendTable_sendprop_t {
    fn new() -> CSVCMsg_SendTable_sendprop_t {
        CSVCMsg_SendTable_sendprop_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.field_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.var_name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.flags = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.priority = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.dt_name.set_default();
                    is.read_string_into(tmp)
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.num_elements = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.low_value = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.high_value = Some(tmp);
                },
                9 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.num_bits = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.var_name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.flags.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.priority.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dt_name.iter() {
            my_size += ::protobuf::rt::string_size(5, value.as_slice());
        };
        for value in self.num_elements.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.low_value.is_some() {
            my_size += 5;
        };
        if self.high_value.is_some() {
            my_size += 5;
        };
        for value in self.num_bits.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.field_type {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.var_name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.flags {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.priority {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.dt_name.as_ref() {
            Some(ref v) => {
                os.write_string(5, v.as_slice());
            },
            None => {},
        };
        match self.num_elements {
            Some(ref v) => {
                os.write_int32(6, *v);
            },
            None => {},
        };
        match self.low_value {
            Some(ref v) => {
                os.write_float(7, *v);
            },
            None => {},
        };
        match self.high_value {
            Some(ref v) => {
                os.write_float(8, *v);
            },
            None => {},
        };
        match self.num_bits {
            Some(ref v) => {
                os.write_int32(9, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_SendTable_sendprop_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_field_type_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_var_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_flags_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_priority_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_dt_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_num_elements_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_low_value_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_high_value_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_SendTable_sendprop_t_num_bits_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_SendTable_sendprop_t>(
                    "CSVCMsg_SendTable_sendprop_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_SendTable_sendprop_t>()
    }
}

impl ::protobuf::Clear for CSVCMsg_SendTable_sendprop_t {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_var_name();
        self.clear_flags();
        self.clear_priority();
        self.clear_dt_name();
        self.clear_num_elements();
        self.clear_low_value();
        self.clear_high_value();
        self.clear_num_bits();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_SendTable_sendprop_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_field_type_acc_type;
static CSVCMsg_SendTable_sendprop_t_field_type_acc: CSVCMsg_SendTable_sendprop_t_field_type_acc_type = CSVCMsg_SendTable_sendprop_t_field_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_field_type_acc_type {
    fn name(&self) -> &'static str {
        "field_type"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_field_type()
    }

    fn get_i32(&self, m: &CSVCMsg_SendTable_sendprop_t) -> i32 {
        m.get_field_type()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_var_name_acc_type;
static CSVCMsg_SendTable_sendprop_t_var_name_acc: CSVCMsg_SendTable_sendprop_t_var_name_acc_type = CSVCMsg_SendTable_sendprop_t_var_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_var_name_acc_type {
    fn name(&self) -> &'static str {
        "var_name"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_var_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_SendTable_sendprop_t) -> &'a str {
        m.get_var_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_flags_acc_type;
static CSVCMsg_SendTable_sendprop_t_flags_acc: CSVCMsg_SendTable_sendprop_t_flags_acc_type = CSVCMsg_SendTable_sendprop_t_flags_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_flags_acc_type {
    fn name(&self) -> &'static str {
        "flags"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_flags()
    }

    fn get_i32(&self, m: &CSVCMsg_SendTable_sendprop_t) -> i32 {
        m.get_flags()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_priority_acc_type;
static CSVCMsg_SendTable_sendprop_t_priority_acc: CSVCMsg_SendTable_sendprop_t_priority_acc_type = CSVCMsg_SendTable_sendprop_t_priority_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_priority_acc_type {
    fn name(&self) -> &'static str {
        "priority"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_priority()
    }

    fn get_i32(&self, m: &CSVCMsg_SendTable_sendprop_t) -> i32 {
        m.get_priority()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_dt_name_acc_type;
static CSVCMsg_SendTable_sendprop_t_dt_name_acc: CSVCMsg_SendTable_sendprop_t_dt_name_acc_type = CSVCMsg_SendTable_sendprop_t_dt_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_dt_name_acc_type {
    fn name(&self) -> &'static str {
        "dt_name"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_dt_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_SendTable_sendprop_t) -> &'a str {
        m.get_dt_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_num_elements_acc_type;
static CSVCMsg_SendTable_sendprop_t_num_elements_acc: CSVCMsg_SendTable_sendprop_t_num_elements_acc_type = CSVCMsg_SendTable_sendprop_t_num_elements_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_num_elements_acc_type {
    fn name(&self) -> &'static str {
        "num_elements"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_num_elements()
    }

    fn get_i32(&self, m: &CSVCMsg_SendTable_sendprop_t) -> i32 {
        m.get_num_elements()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_low_value_acc_type;
static CSVCMsg_SendTable_sendprop_t_low_value_acc: CSVCMsg_SendTable_sendprop_t_low_value_acc_type = CSVCMsg_SendTable_sendprop_t_low_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_low_value_acc_type {
    fn name(&self) -> &'static str {
        "low_value"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_low_value()
    }

    fn get_f32(&self, m: &CSVCMsg_SendTable_sendprop_t) -> f32 {
        m.get_low_value()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_high_value_acc_type;
static CSVCMsg_SendTable_sendprop_t_high_value_acc: CSVCMsg_SendTable_sendprop_t_high_value_acc_type = CSVCMsg_SendTable_sendprop_t_high_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_high_value_acc_type {
    fn name(&self) -> &'static str {
        "high_value"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_high_value()
    }

    fn get_f32(&self, m: &CSVCMsg_SendTable_sendprop_t) -> f32 {
        m.get_high_value()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_SendTable_sendprop_t_num_bits_acc_type;
static CSVCMsg_SendTable_sendprop_t_num_bits_acc: CSVCMsg_SendTable_sendprop_t_num_bits_acc_type = CSVCMsg_SendTable_sendprop_t_num_bits_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_SendTable_sendprop_t> for CSVCMsg_SendTable_sendprop_t_num_bits_acc_type {
    fn name(&self) -> &'static str {
        "num_bits"
    }

    fn has_field(&self, m: &CSVCMsg_SendTable_sendprop_t) -> bool {
        m.has_num_bits()
    }

    fn get_i32(&self, m: &CSVCMsg_SendTable_sendprop_t) -> i32 {
        m.get_num_bits()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_GameEvent {
    event_name: ::protobuf::SingularField<String>,
    eventid: Option<i32>,
    keys: ::protobuf::RepeatedField<CSVCMsg_GameEvent_key_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_GameEvent {
    pub fn new() -> CSVCMsg_GameEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_GameEvent {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_GameEvent> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_GameEvent };
        unsafe {
            instance.get(|| {
                CSVCMsg_GameEvent {
                    event_name: ::protobuf::SingularField::none(),
                    eventid: None,
                    keys: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name.clear();
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: String) {
        self.event_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&'a mut self) -> &'a mut String {
        if self.event_name.is_none() {
            self.event_name.set_default();
        };
        self.event_name.as_mut().unwrap()
    }

    pub fn get_event_name(&'a self) -> &'a str {
        match self.event_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventid(&'a mut self) -> &'a mut i32 {
        if self.eventid.is_none() {
            self.eventid = Some(0);
        };
        self.eventid.as_mut().unwrap()
    }

    pub fn get_eventid(&self) -> i32 {
        self.eventid.unwrap_or_else(|| 0)
    }

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<CSVCMsg_GameEvent_key_t>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsg_GameEvent_key_t> {
        &mut self.keys
    }

    pub fn get_keys(&'a self) -> &'a [CSVCMsg_GameEvent_key_t] {
        self.keys.as_slice()
    }

    pub fn add_keys(&mut self, v: CSVCMsg_GameEvent_key_t) {
        self.keys.push(v);
    }
}

impl ::protobuf::Message for CSVCMsg_GameEvent {
    fn new() -> CSVCMsg_GameEvent {
        CSVCMsg_GameEvent::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.event_name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.eventid = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.keys.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.event_name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.eventid.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.keys.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.event_name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.eventid {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        for v in self.keys.iter() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_GameEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_event_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_eventid_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_keys_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_GameEvent>(
                    "CSVCMsg_GameEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_GameEvent>()
    }
}

impl ::protobuf::Clear for CSVCMsg_GameEvent {
    fn clear(&mut self) {
        self.clear_event_name();
        self.clear_eventid();
        self.clear_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_GameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_event_name_acc_type;
static CSVCMsg_GameEvent_event_name_acc: CSVCMsg_GameEvent_event_name_acc_type = CSVCMsg_GameEvent_event_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent> for CSVCMsg_GameEvent_event_name_acc_type {
    fn name(&self) -> &'static str {
        "event_name"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent) -> bool {
        m.has_event_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_GameEvent) -> &'a str {
        m.get_event_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_eventid_acc_type;
static CSVCMsg_GameEvent_eventid_acc: CSVCMsg_GameEvent_eventid_acc_type = CSVCMsg_GameEvent_eventid_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent> for CSVCMsg_GameEvent_eventid_acc_type {
    fn name(&self) -> &'static str {
        "eventid"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent) -> bool {
        m.has_eventid()
    }

    fn get_i32(&self, m: &CSVCMsg_GameEvent) -> i32 {
        m.get_eventid()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_keys_acc_type;
static CSVCMsg_GameEvent_keys_acc: CSVCMsg_GameEvent_keys_acc_type = CSVCMsg_GameEvent_keys_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent> for CSVCMsg_GameEvent_keys_acc_type {
    fn name(&self) -> &'static str {
        "keys"
    }

    fn len_field(&self, m: &CSVCMsg_GameEvent) -> uint {
        m.get_keys().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsg_GameEvent, index: uint) -> &'a ::protobuf::Message {
        &m.get_keys()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_GameEvent_key_t {
    field_type: Option<i32>,
    val_string: ::protobuf::SingularField<String>,
    val_float: Option<f32>,
    val_long: Option<i32>,
    val_short: Option<i32>,
    val_byte: Option<i32>,
    val_bool: Option<bool>,
    val_uint64: Option<u64>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_GameEvent_key_t {
    pub fn new() -> CSVCMsg_GameEvent_key_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_GameEvent_key_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_GameEvent_key_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_GameEvent_key_t };
        unsafe {
            instance.get(|| {
                CSVCMsg_GameEvent_key_t {
                    field_type: None,
                    val_string: ::protobuf::SingularField::none(),
                    val_float: None,
                    val_long: None,
                    val_short: None,
                    val_byte: None,
                    val_bool: None,
                    val_uint64: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&'a mut self) -> &'a mut i32 {
        if self.field_type.is_none() {
            self.field_type = Some(0);
        };
        self.field_type.as_mut().unwrap()
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or_else(|| 0)
    }

    pub fn clear_val_string(&mut self) {
        self.val_string.clear();
    }

    pub fn has_val_string(&self) -> bool {
        self.val_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_string(&mut self, v: String) {
        self.val_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_string(&'a mut self) -> &'a mut String {
        if self.val_string.is_none() {
            self.val_string.set_default();
        };
        self.val_string.as_mut().unwrap()
    }

    pub fn get_val_string(&'a self) -> &'a str {
        match self.val_string.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_val_float(&mut self) {
        self.val_float = None;
    }

    pub fn has_val_float(&self) -> bool {
        self.val_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_float(&mut self, v: f32) {
        self.val_float = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_float(&'a mut self) -> &'a mut f32 {
        if self.val_float.is_none() {
            self.val_float = Some(0.);
        };
        self.val_float.as_mut().unwrap()
    }

    pub fn get_val_float(&self) -> f32 {
        self.val_float.unwrap_or_else(|| 0.)
    }

    pub fn clear_val_long(&mut self) {
        self.val_long = None;
    }

    pub fn has_val_long(&self) -> bool {
        self.val_long.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_long(&mut self, v: i32) {
        self.val_long = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_long(&'a mut self) -> &'a mut i32 {
        if self.val_long.is_none() {
            self.val_long = Some(0);
        };
        self.val_long.as_mut().unwrap()
    }

    pub fn get_val_long(&self) -> i32 {
        self.val_long.unwrap_or_else(|| 0)
    }

    pub fn clear_val_short(&mut self) {
        self.val_short = None;
    }

    pub fn has_val_short(&self) -> bool {
        self.val_short.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_short(&mut self, v: i32) {
        self.val_short = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_short(&'a mut self) -> &'a mut i32 {
        if self.val_short.is_none() {
            self.val_short = Some(0);
        };
        self.val_short.as_mut().unwrap()
    }

    pub fn get_val_short(&self) -> i32 {
        self.val_short.unwrap_or_else(|| 0)
    }

    pub fn clear_val_byte(&mut self) {
        self.val_byte = None;
    }

    pub fn has_val_byte(&self) -> bool {
        self.val_byte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_byte(&mut self, v: i32) {
        self.val_byte = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_byte(&'a mut self) -> &'a mut i32 {
        if self.val_byte.is_none() {
            self.val_byte = Some(0);
        };
        self.val_byte.as_mut().unwrap()
    }

    pub fn get_val_byte(&self) -> i32 {
        self.val_byte.unwrap_or_else(|| 0)
    }

    pub fn clear_val_bool(&mut self) {
        self.val_bool = None;
    }

    pub fn has_val_bool(&self) -> bool {
        self.val_bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_bool(&mut self, v: bool) {
        self.val_bool = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_bool(&'a mut self) -> &'a mut bool {
        if self.val_bool.is_none() {
            self.val_bool = Some(false);
        };
        self.val_bool.as_mut().unwrap()
    }

    pub fn get_val_bool(&self) -> bool {
        self.val_bool.unwrap_or_else(|| false)
    }

    pub fn clear_val_uint64(&mut self) {
        self.val_uint64 = None;
    }

    pub fn has_val_uint64(&self) -> bool {
        self.val_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_uint64(&mut self, v: u64) {
        self.val_uint64 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_uint64(&'a mut self) -> &'a mut u64 {
        if self.val_uint64.is_none() {
            self.val_uint64 = Some(0);
        };
        self.val_uint64.as_mut().unwrap()
    }

    pub fn get_val_uint64(&self) -> u64 {
        self.val_uint64.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CSVCMsg_GameEvent_key_t {
    fn new() -> CSVCMsg_GameEvent_key_t {
        CSVCMsg_GameEvent_key_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.field_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.val_string.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.val_float = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.val_long = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.val_short = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.val_byte = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.val_bool = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint64();
                    self.val_uint64 = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.val_string.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        if self.val_float.is_some() {
            my_size += 5;
        };
        for value in self.val_long.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.val_short.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.val_byte.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.val_bool.is_some() {
            my_size += 2;
        };
        for value in self.val_uint64.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.field_type {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.val_string.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.val_float {
            Some(ref v) => {
                os.write_float(3, *v);
            },
            None => {},
        };
        match self.val_long {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.val_short {
            Some(ref v) => {
                os.write_int32(5, *v);
            },
            None => {},
        };
        match self.val_byte {
            Some(ref v) => {
                os.write_int32(6, *v);
            },
            None => {},
        };
        match self.val_bool {
            Some(ref v) => {
                os.write_bool(7, *v);
            },
            None => {},
        };
        match self.val_uint64 {
            Some(ref v) => {
                os.write_uint64(8, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_GameEvent_key_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_field_type_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_val_string_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_val_float_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_val_long_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_val_short_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_val_byte_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_val_bool_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEvent_key_t_val_uint64_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_GameEvent_key_t>(
                    "CSVCMsg_GameEvent_key_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_GameEvent_key_t>()
    }
}

impl ::protobuf::Clear for CSVCMsg_GameEvent_key_t {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_val_string();
        self.clear_val_float();
        self.clear_val_long();
        self.clear_val_short();
        self.clear_val_byte();
        self.clear_val_bool();
        self.clear_val_uint64();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_GameEvent_key_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_field_type_acc_type;
static CSVCMsg_GameEvent_key_t_field_type_acc: CSVCMsg_GameEvent_key_t_field_type_acc_type = CSVCMsg_GameEvent_key_t_field_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_field_type_acc_type {
    fn name(&self) -> &'static str {
        "field_type"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_field_type()
    }

    fn get_i32(&self, m: &CSVCMsg_GameEvent_key_t) -> i32 {
        m.get_field_type()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_val_string_acc_type;
static CSVCMsg_GameEvent_key_t_val_string_acc: CSVCMsg_GameEvent_key_t_val_string_acc_type = CSVCMsg_GameEvent_key_t_val_string_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_val_string_acc_type {
    fn name(&self) -> &'static str {
        "val_string"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_val_string()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_GameEvent_key_t) -> &'a str {
        m.get_val_string()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_val_float_acc_type;
static CSVCMsg_GameEvent_key_t_val_float_acc: CSVCMsg_GameEvent_key_t_val_float_acc_type = CSVCMsg_GameEvent_key_t_val_float_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_val_float_acc_type {
    fn name(&self) -> &'static str {
        "val_float"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_val_float()
    }

    fn get_f32(&self, m: &CSVCMsg_GameEvent_key_t) -> f32 {
        m.get_val_float()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_val_long_acc_type;
static CSVCMsg_GameEvent_key_t_val_long_acc: CSVCMsg_GameEvent_key_t_val_long_acc_type = CSVCMsg_GameEvent_key_t_val_long_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_val_long_acc_type {
    fn name(&self) -> &'static str {
        "val_long"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_val_long()
    }

    fn get_i32(&self, m: &CSVCMsg_GameEvent_key_t) -> i32 {
        m.get_val_long()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_val_short_acc_type;
static CSVCMsg_GameEvent_key_t_val_short_acc: CSVCMsg_GameEvent_key_t_val_short_acc_type = CSVCMsg_GameEvent_key_t_val_short_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_val_short_acc_type {
    fn name(&self) -> &'static str {
        "val_short"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_val_short()
    }

    fn get_i32(&self, m: &CSVCMsg_GameEvent_key_t) -> i32 {
        m.get_val_short()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_val_byte_acc_type;
static CSVCMsg_GameEvent_key_t_val_byte_acc: CSVCMsg_GameEvent_key_t_val_byte_acc_type = CSVCMsg_GameEvent_key_t_val_byte_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_val_byte_acc_type {
    fn name(&self) -> &'static str {
        "val_byte"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_val_byte()
    }

    fn get_i32(&self, m: &CSVCMsg_GameEvent_key_t) -> i32 {
        m.get_val_byte()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_val_bool_acc_type;
static CSVCMsg_GameEvent_key_t_val_bool_acc: CSVCMsg_GameEvent_key_t_val_bool_acc_type = CSVCMsg_GameEvent_key_t_val_bool_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_val_bool_acc_type {
    fn name(&self) -> &'static str {
        "val_bool"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_val_bool()
    }

    fn get_bool(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.get_val_bool()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEvent_key_t_val_uint64_acc_type;
static CSVCMsg_GameEvent_key_t_val_uint64_acc: CSVCMsg_GameEvent_key_t_val_uint64_acc_type = CSVCMsg_GameEvent_key_t_val_uint64_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEvent_key_t> for CSVCMsg_GameEvent_key_t_val_uint64_acc_type {
    fn name(&self) -> &'static str {
        "val_uint64"
    }

    fn has_field(&self, m: &CSVCMsg_GameEvent_key_t) -> bool {
        m.has_val_uint64()
    }

    fn get_u64(&self, m: &CSVCMsg_GameEvent_key_t) -> u64 {
        m.get_val_uint64()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_GameEventList {
    descriptors: ::protobuf::RepeatedField<CSVCMsg_GameEventList_descriptor_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_GameEventList {
    pub fn new() -> CSVCMsg_GameEventList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_GameEventList {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_GameEventList> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_GameEventList };
        unsafe {
            instance.get(|| {
                CSVCMsg_GameEventList {
                    descriptors: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_descriptors(&mut self) {
        self.descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptors(&mut self, v: ::protobuf::RepeatedField<CSVCMsg_GameEventList_descriptor_t>) {
        self.descriptors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_descriptors(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsg_GameEventList_descriptor_t> {
        &mut self.descriptors
    }

    pub fn get_descriptors(&'a self) -> &'a [CSVCMsg_GameEventList_descriptor_t] {
        self.descriptors.as_slice()
    }

    pub fn add_descriptors(&mut self, v: CSVCMsg_GameEventList_descriptor_t) {
        self.descriptors.push(v);
    }
}

impl ::protobuf::Message for CSVCMsg_GameEventList {
    fn new() -> CSVCMsg_GameEventList {
        CSVCMsg_GameEventList::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.descriptors.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.descriptors.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.descriptors.iter() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_GameEventList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEventList_descriptors_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_GameEventList>(
                    "CSVCMsg_GameEventList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_GameEventList>()
    }
}

impl ::protobuf::Clear for CSVCMsg_GameEventList {
    fn clear(&mut self) {
        self.clear_descriptors();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_GameEventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_GameEventList_descriptors_acc_type;
static CSVCMsg_GameEventList_descriptors_acc: CSVCMsg_GameEventList_descriptors_acc_type = CSVCMsg_GameEventList_descriptors_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList> for CSVCMsg_GameEventList_descriptors_acc_type {
    fn name(&self) -> &'static str {
        "descriptors"
    }

    fn len_field(&self, m: &CSVCMsg_GameEventList) -> uint {
        m.get_descriptors().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsg_GameEventList, index: uint) -> &'a ::protobuf::Message {
        &m.get_descriptors()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_GameEventList_key_t {
    field_type: Option<i32>,
    name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_GameEventList_key_t {
    pub fn new() -> CSVCMsg_GameEventList_key_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_GameEventList_key_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_GameEventList_key_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_GameEventList_key_t };
        unsafe {
            instance.get(|| {
                CSVCMsg_GameEventList_key_t {
                    field_type: None,
                    name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&'a mut self) -> &'a mut i32 {
        if self.field_type.is_none() {
            self.field_type = Some(0);
        };
        self.field_type.as_mut().unwrap()
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or_else(|| 0)
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CSVCMsg_GameEventList_key_t {
    fn new() -> CSVCMsg_GameEventList_key_t {
        CSVCMsg_GameEventList_key_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.field_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.field_type {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_GameEventList_key_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_key_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEventList_key_t_field_type_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_key_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEventList_key_t_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_key_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_GameEventList_key_t>(
                    "CSVCMsg_GameEventList_key_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_GameEventList_key_t>()
    }
}

impl ::protobuf::Clear for CSVCMsg_GameEventList_key_t {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_GameEventList_key_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_GameEventList_key_t_field_type_acc_type;
static CSVCMsg_GameEventList_key_t_field_type_acc: CSVCMsg_GameEventList_key_t_field_type_acc_type = CSVCMsg_GameEventList_key_t_field_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_key_t> for CSVCMsg_GameEventList_key_t_field_type_acc_type {
    fn name(&self) -> &'static str {
        "field_type"
    }

    fn has_field(&self, m: &CSVCMsg_GameEventList_key_t) -> bool {
        m.has_field_type()
    }

    fn get_i32(&self, m: &CSVCMsg_GameEventList_key_t) -> i32 {
        m.get_field_type()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEventList_key_t_name_acc_type;
static CSVCMsg_GameEventList_key_t_name_acc: CSVCMsg_GameEventList_key_t_name_acc_type = CSVCMsg_GameEventList_key_t_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_key_t> for CSVCMsg_GameEventList_key_t_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CSVCMsg_GameEventList_key_t) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_GameEventList_key_t) -> &'a str {
        m.get_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_GameEventList_descriptor_t {
    eventid: Option<i32>,
    name: ::protobuf::SingularField<String>,
    keys: ::protobuf::RepeatedField<CSVCMsg_GameEventList_key_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_GameEventList_descriptor_t {
    pub fn new() -> CSVCMsg_GameEventList_descriptor_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_GameEventList_descriptor_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_GameEventList_descriptor_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_GameEventList_descriptor_t };
        unsafe {
            instance.get(|| {
                CSVCMsg_GameEventList_descriptor_t {
                    eventid: None,
                    name: ::protobuf::SingularField::none(),
                    keys: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventid(&'a mut self) -> &'a mut i32 {
        if self.eventid.is_none() {
            self.eventid = Some(0);
        };
        self.eventid.as_mut().unwrap()
    }

    pub fn get_eventid(&self) -> i32 {
        self.eventid.unwrap_or_else(|| 0)
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<CSVCMsg_GameEventList_key_t>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsg_GameEventList_key_t> {
        &mut self.keys
    }

    pub fn get_keys(&'a self) -> &'a [CSVCMsg_GameEventList_key_t] {
        self.keys.as_slice()
    }

    pub fn add_keys(&mut self, v: CSVCMsg_GameEventList_key_t) {
        self.keys.push(v);
    }
}

impl ::protobuf::Message for CSVCMsg_GameEventList_descriptor_t {
    fn new() -> CSVCMsg_GameEventList_descriptor_t {
        CSVCMsg_GameEventList_descriptor_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.eventid = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.keys.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.eventid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.keys.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.eventid {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        for v in self.keys.iter() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_GameEventList_descriptor_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_descriptor_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEventList_descriptor_t_eventid_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_descriptor_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEventList_descriptor_t_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_descriptor_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_GameEventList_descriptor_t_keys_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_descriptor_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_GameEventList_descriptor_t>(
                    "CSVCMsg_GameEventList_descriptor_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_GameEventList_descriptor_t>()
    }
}

impl ::protobuf::Clear for CSVCMsg_GameEventList_descriptor_t {
    fn clear(&mut self) {
        self.clear_eventid();
        self.clear_name();
        self.clear_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_GameEventList_descriptor_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_GameEventList_descriptor_t_eventid_acc_type;
static CSVCMsg_GameEventList_descriptor_t_eventid_acc: CSVCMsg_GameEventList_descriptor_t_eventid_acc_type = CSVCMsg_GameEventList_descriptor_t_eventid_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_descriptor_t> for CSVCMsg_GameEventList_descriptor_t_eventid_acc_type {
    fn name(&self) -> &'static str {
        "eventid"
    }

    fn has_field(&self, m: &CSVCMsg_GameEventList_descriptor_t) -> bool {
        m.has_eventid()
    }

    fn get_i32(&self, m: &CSVCMsg_GameEventList_descriptor_t) -> i32 {
        m.get_eventid()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEventList_descriptor_t_name_acc_type;
static CSVCMsg_GameEventList_descriptor_t_name_acc: CSVCMsg_GameEventList_descriptor_t_name_acc_type = CSVCMsg_GameEventList_descriptor_t_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_descriptor_t> for CSVCMsg_GameEventList_descriptor_t_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CSVCMsg_GameEventList_descriptor_t) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_GameEventList_descriptor_t) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_GameEventList_descriptor_t_keys_acc_type;
static CSVCMsg_GameEventList_descriptor_t_keys_acc: CSVCMsg_GameEventList_descriptor_t_keys_acc_type = CSVCMsg_GameEventList_descriptor_t_keys_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_GameEventList_descriptor_t> for CSVCMsg_GameEventList_descriptor_t_keys_acc_type {
    fn name(&self) -> &'static str {
        "keys"
    }

    fn len_field(&self, m: &CSVCMsg_GameEventList_descriptor_t) -> uint {
        m.get_keys().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsg_GameEventList_descriptor_t, index: uint) -> &'a ::protobuf::Message {
        &m.get_keys()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_PacketEntities {
    max_entries: Option<i32>,
    updated_entries: Option<i32>,
    is_delta: Option<bool>,
    update_baseline: Option<bool>,
    baseline: Option<i32>,
    delta_from: Option<i32>,
    entity_data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_PacketEntities {
    pub fn new() -> CSVCMsg_PacketEntities {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_PacketEntities {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_PacketEntities> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_PacketEntities };
        unsafe {
            instance.get(|| {
                CSVCMsg_PacketEntities {
                    max_entries: None,
                    updated_entries: None,
                    is_delta: None,
                    update_baseline: None,
                    baseline: None,
                    delta_from: None,
                    entity_data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_max_entries(&mut self) {
        self.max_entries = None;
    }

    pub fn has_max_entries(&self) -> bool {
        self.max_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: i32) {
        self.max_entries = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_entries(&'a mut self) -> &'a mut i32 {
        if self.max_entries.is_none() {
            self.max_entries = Some(0);
        };
        self.max_entries.as_mut().unwrap()
    }

    pub fn get_max_entries(&self) -> i32 {
        self.max_entries.unwrap_or_else(|| 0)
    }

    pub fn clear_updated_entries(&mut self) {
        self.updated_entries = None;
    }

    pub fn has_updated_entries(&self) -> bool {
        self.updated_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_entries(&mut self, v: i32) {
        self.updated_entries = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_entries(&'a mut self) -> &'a mut i32 {
        if self.updated_entries.is_none() {
            self.updated_entries = Some(0);
        };
        self.updated_entries.as_mut().unwrap()
    }

    pub fn get_updated_entries(&self) -> i32 {
        self.updated_entries.unwrap_or_else(|| 0)
    }

    pub fn clear_is_delta(&mut self) {
        self.is_delta = None;
    }

    pub fn has_is_delta(&self) -> bool {
        self.is_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_delta(&mut self, v: bool) {
        self.is_delta = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_delta(&'a mut self) -> &'a mut bool {
        if self.is_delta.is_none() {
            self.is_delta = Some(false);
        };
        self.is_delta.as_mut().unwrap()
    }

    pub fn get_is_delta(&self) -> bool {
        self.is_delta.unwrap_or_else(|| false)
    }

    pub fn clear_update_baseline(&mut self) {
        self.update_baseline = None;
    }

    pub fn has_update_baseline(&self) -> bool {
        self.update_baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_baseline(&mut self, v: bool) {
        self.update_baseline = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_baseline(&'a mut self) -> &'a mut bool {
        if self.update_baseline.is_none() {
            self.update_baseline = Some(false);
        };
        self.update_baseline.as_mut().unwrap()
    }

    pub fn get_update_baseline(&self) -> bool {
        self.update_baseline.unwrap_or_else(|| false)
    }

    pub fn clear_baseline(&mut self) {
        self.baseline = None;
    }

    pub fn has_baseline(&self) -> bool {
        self.baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline(&mut self, v: i32) {
        self.baseline = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseline(&'a mut self) -> &'a mut i32 {
        if self.baseline.is_none() {
            self.baseline = Some(0);
        };
        self.baseline.as_mut().unwrap()
    }

    pub fn get_baseline(&self) -> i32 {
        self.baseline.unwrap_or_else(|| 0)
    }

    pub fn clear_delta_from(&mut self) {
        self.delta_from = None;
    }

    pub fn has_delta_from(&self) -> bool {
        self.delta_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_from(&mut self, v: i32) {
        self.delta_from = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delta_from(&'a mut self) -> &'a mut i32 {
        if self.delta_from.is_none() {
            self.delta_from = Some(0);
        };
        self.delta_from.as_mut().unwrap()
    }

    pub fn get_delta_from(&self) -> i32 {
        self.delta_from.unwrap_or_else(|| 0)
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data.clear();
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: Vec<u8>) {
        self.entity_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.entity_data.is_none() {
            self.entity_data.set_default();
        };
        self.entity_data.as_mut().unwrap()
    }

    pub fn get_entity_data(&'a self) -> &'a [u8] {
        match self.entity_data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CSVCMsg_PacketEntities {
    fn new() -> CSVCMsg_PacketEntities {
        CSVCMsg_PacketEntities::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.max_entries = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.updated_entries = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_delta = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.update_baseline = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.baseline = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.delta_from = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.entity_data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.max_entries.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.updated_entries.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_delta.is_some() {
            my_size += 2;
        };
        if self.update_baseline.is_some() {
            my_size += 2;
        };
        for value in self.baseline.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.delta_from.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entity_data.iter() {
            my_size += ::protobuf::rt::bytes_size(7, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.max_entries {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.updated_entries {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.is_delta {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        match self.update_baseline {
            Some(ref v) => {
                os.write_bool(4, *v);
            },
            None => {},
        };
        match self.baseline {
            Some(ref v) => {
                os.write_int32(5, *v);
            },
            None => {},
        };
        match self.delta_from {
            Some(ref v) => {
                os.write_int32(6, *v);
            },
            None => {},
        };
        match self.entity_data.as_ref() {
            Some(ref v) => {
                os.write_bytes(7, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_PacketEntities>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_PacketEntities_max_entries_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_PacketEntities_updated_entries_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_PacketEntities_is_delta_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_PacketEntities_update_baseline_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_PacketEntities_baseline_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_PacketEntities_delta_from_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_PacketEntities_entity_data_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_PacketEntities>(
                    "CSVCMsg_PacketEntities",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_PacketEntities>()
    }
}

impl ::protobuf::Clear for CSVCMsg_PacketEntities {
    fn clear(&mut self) {
        self.clear_max_entries();
        self.clear_updated_entries();
        self.clear_is_delta();
        self.clear_update_baseline();
        self.clear_baseline();
        self.clear_delta_from();
        self.clear_entity_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_PacketEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_PacketEntities_max_entries_acc_type;
static CSVCMsg_PacketEntities_max_entries_acc: CSVCMsg_PacketEntities_max_entries_acc_type = CSVCMsg_PacketEntities_max_entries_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities> for CSVCMsg_PacketEntities_max_entries_acc_type {
    fn name(&self) -> &'static str {
        "max_entries"
    }

    fn has_field(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.has_max_entries()
    }

    fn get_i32(&self, m: &CSVCMsg_PacketEntities) -> i32 {
        m.get_max_entries()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_PacketEntities_updated_entries_acc_type;
static CSVCMsg_PacketEntities_updated_entries_acc: CSVCMsg_PacketEntities_updated_entries_acc_type = CSVCMsg_PacketEntities_updated_entries_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities> for CSVCMsg_PacketEntities_updated_entries_acc_type {
    fn name(&self) -> &'static str {
        "updated_entries"
    }

    fn has_field(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.has_updated_entries()
    }

    fn get_i32(&self, m: &CSVCMsg_PacketEntities) -> i32 {
        m.get_updated_entries()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_PacketEntities_is_delta_acc_type;
static CSVCMsg_PacketEntities_is_delta_acc: CSVCMsg_PacketEntities_is_delta_acc_type = CSVCMsg_PacketEntities_is_delta_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities> for CSVCMsg_PacketEntities_is_delta_acc_type {
    fn name(&self) -> &'static str {
        "is_delta"
    }

    fn has_field(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.has_is_delta()
    }

    fn get_bool(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.get_is_delta()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_PacketEntities_update_baseline_acc_type;
static CSVCMsg_PacketEntities_update_baseline_acc: CSVCMsg_PacketEntities_update_baseline_acc_type = CSVCMsg_PacketEntities_update_baseline_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities> for CSVCMsg_PacketEntities_update_baseline_acc_type {
    fn name(&self) -> &'static str {
        "update_baseline"
    }

    fn has_field(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.has_update_baseline()
    }

    fn get_bool(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.get_update_baseline()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_PacketEntities_baseline_acc_type;
static CSVCMsg_PacketEntities_baseline_acc: CSVCMsg_PacketEntities_baseline_acc_type = CSVCMsg_PacketEntities_baseline_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities> for CSVCMsg_PacketEntities_baseline_acc_type {
    fn name(&self) -> &'static str {
        "baseline"
    }

    fn has_field(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.has_baseline()
    }

    fn get_i32(&self, m: &CSVCMsg_PacketEntities) -> i32 {
        m.get_baseline()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_PacketEntities_delta_from_acc_type;
static CSVCMsg_PacketEntities_delta_from_acc: CSVCMsg_PacketEntities_delta_from_acc_type = CSVCMsg_PacketEntities_delta_from_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities> for CSVCMsg_PacketEntities_delta_from_acc_type {
    fn name(&self) -> &'static str {
        "delta_from"
    }

    fn has_field(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.has_delta_from()
    }

    fn get_i32(&self, m: &CSVCMsg_PacketEntities) -> i32 {
        m.get_delta_from()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_PacketEntities_entity_data_acc_type;
static CSVCMsg_PacketEntities_entity_data_acc: CSVCMsg_PacketEntities_entity_data_acc_type = CSVCMsg_PacketEntities_entity_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_PacketEntities> for CSVCMsg_PacketEntities_entity_data_acc_type {
    fn name(&self) -> &'static str {
        "entity_data"
    }

    fn has_field(&self, m: &CSVCMsg_PacketEntities) -> bool {
        m.has_entity_data()
    }

    fn get_bytes<'a>(&self, m: &'a CSVCMsg_PacketEntities) -> &'a [u8] {
        m.get_entity_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_TempEntities {
    reliable: Option<bool>,
    num_entries: Option<i32>,
    entity_data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_TempEntities {
    pub fn new() -> CSVCMsg_TempEntities {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_TempEntities {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_TempEntities> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_TempEntities };
        unsafe {
            instance.get(|| {
                CSVCMsg_TempEntities {
                    reliable: None,
                    num_entries: None,
                    entity_data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_reliable(&mut self) {
        self.reliable = None;
    }

    pub fn has_reliable(&self) -> bool {
        self.reliable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable(&mut self, v: bool) {
        self.reliable = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reliable(&'a mut self) -> &'a mut bool {
        if self.reliable.is_none() {
            self.reliable = Some(false);
        };
        self.reliable.as_mut().unwrap()
    }

    pub fn get_reliable(&self) -> bool {
        self.reliable.unwrap_or_else(|| false)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_entries(&'a mut self) -> &'a mut i32 {
        if self.num_entries.is_none() {
            self.num_entries = Some(0);
        };
        self.num_entries.as_mut().unwrap()
    }

    pub fn get_num_entries(&self) -> i32 {
        self.num_entries.unwrap_or_else(|| 0)
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data.clear();
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: Vec<u8>) {
        self.entity_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.entity_data.is_none() {
            self.entity_data.set_default();
        };
        self.entity_data.as_mut().unwrap()
    }

    pub fn get_entity_data(&'a self) -> &'a [u8] {
        match self.entity_data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CSVCMsg_TempEntities {
    fn new() -> CSVCMsg_TempEntities {
        CSVCMsg_TempEntities::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.reliable = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.num_entries = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.entity_data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.reliable.is_some() {
            my_size += 2;
        };
        for value in self.num_entries.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entity_data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.reliable {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        match self.num_entries {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.entity_data.as_ref() {
            Some(ref v) => {
                os.write_bytes(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_TempEntities>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_TempEntities>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_TempEntities_reliable_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_TempEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_TempEntities_num_entries_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_TempEntities>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_TempEntities_entity_data_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_TempEntities>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_TempEntities>(
                    "CSVCMsg_TempEntities",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_TempEntities>()
    }
}

impl ::protobuf::Clear for CSVCMsg_TempEntities {
    fn clear(&mut self) {
        self.clear_reliable();
        self.clear_num_entries();
        self.clear_entity_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_TempEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_TempEntities_reliable_acc_type;
static CSVCMsg_TempEntities_reliable_acc: CSVCMsg_TempEntities_reliable_acc_type = CSVCMsg_TempEntities_reliable_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_TempEntities> for CSVCMsg_TempEntities_reliable_acc_type {
    fn name(&self) -> &'static str {
        "reliable"
    }

    fn has_field(&self, m: &CSVCMsg_TempEntities) -> bool {
        m.has_reliable()
    }

    fn get_bool(&self, m: &CSVCMsg_TempEntities) -> bool {
        m.get_reliable()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_TempEntities_num_entries_acc_type;
static CSVCMsg_TempEntities_num_entries_acc: CSVCMsg_TempEntities_num_entries_acc_type = CSVCMsg_TempEntities_num_entries_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_TempEntities> for CSVCMsg_TempEntities_num_entries_acc_type {
    fn name(&self) -> &'static str {
        "num_entries"
    }

    fn has_field(&self, m: &CSVCMsg_TempEntities) -> bool {
        m.has_num_entries()
    }

    fn get_i32(&self, m: &CSVCMsg_TempEntities) -> i32 {
        m.get_num_entries()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_TempEntities_entity_data_acc_type;
static CSVCMsg_TempEntities_entity_data_acc: CSVCMsg_TempEntities_entity_data_acc_type = CSVCMsg_TempEntities_entity_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_TempEntities> for CSVCMsg_TempEntities_entity_data_acc_type {
    fn name(&self) -> &'static str {
        "entity_data"
    }

    fn has_field(&self, m: &CSVCMsg_TempEntities) -> bool {
        m.has_entity_data()
    }

    fn get_bytes<'a>(&self, m: &'a CSVCMsg_TempEntities) -> &'a [u8] {
        m.get_entity_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_CreateStringTable {
    name: ::protobuf::SingularField<String>,
    max_entries: Option<i32>,
    num_entries: Option<i32>,
    user_data_fixed_size: Option<bool>,
    user_data_size: Option<i32>,
    user_data_size_bits: Option<i32>,
    flags: Option<i32>,
    string_data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_CreateStringTable {
    pub fn new() -> CSVCMsg_CreateStringTable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_CreateStringTable {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_CreateStringTable> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_CreateStringTable };
        unsafe {
            instance.get(|| {
                CSVCMsg_CreateStringTable {
                    name: ::protobuf::SingularField::none(),
                    max_entries: None,
                    num_entries: None,
                    user_data_fixed_size: None,
                    user_data_size: None,
                    user_data_size_bits: None,
                    flags: None,
                    string_data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_max_entries(&mut self) {
        self.max_entries = None;
    }

    pub fn has_max_entries(&self) -> bool {
        self.max_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: i32) {
        self.max_entries = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_entries(&'a mut self) -> &'a mut i32 {
        if self.max_entries.is_none() {
            self.max_entries = Some(0);
        };
        self.max_entries.as_mut().unwrap()
    }

    pub fn get_max_entries(&self) -> i32 {
        self.max_entries.unwrap_or_else(|| 0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_entries(&'a mut self) -> &'a mut i32 {
        if self.num_entries.is_none() {
            self.num_entries = Some(0);
        };
        self.num_entries.as_mut().unwrap()
    }

    pub fn get_num_entries(&self) -> i32 {
        self.num_entries.unwrap_or_else(|| 0)
    }

    pub fn clear_user_data_fixed_size(&mut self) {
        self.user_data_fixed_size = None;
    }

    pub fn has_user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_fixed_size(&mut self, v: bool) {
        self.user_data_fixed_size = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_data_fixed_size(&'a mut self) -> &'a mut bool {
        if self.user_data_fixed_size.is_none() {
            self.user_data_fixed_size = Some(false);
        };
        self.user_data_fixed_size.as_mut().unwrap()
    }

    pub fn get_user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.unwrap_or_else(|| false)
    }

    pub fn clear_user_data_size(&mut self) {
        self.user_data_size = None;
    }

    pub fn has_user_data_size(&self) -> bool {
        self.user_data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size(&mut self, v: i32) {
        self.user_data_size = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_data_size(&'a mut self) -> &'a mut i32 {
        if self.user_data_size.is_none() {
            self.user_data_size = Some(0);
        };
        self.user_data_size.as_mut().unwrap()
    }

    pub fn get_user_data_size(&self) -> i32 {
        self.user_data_size.unwrap_or_else(|| 0)
    }

    pub fn clear_user_data_size_bits(&mut self) {
        self.user_data_size_bits = None;
    }

    pub fn has_user_data_size_bits(&self) -> bool {
        self.user_data_size_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size_bits(&mut self, v: i32) {
        self.user_data_size_bits = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_data_size_bits(&'a mut self) -> &'a mut i32 {
        if self.user_data_size_bits.is_none() {
            self.user_data_size_bits = Some(0);
        };
        self.user_data_size_bits.as_mut().unwrap()
    }

    pub fn get_user_data_size_bits(&self) -> i32 {
        self.user_data_size_bits.unwrap_or_else(|| 0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&'a mut self) -> &'a mut i32 {
        if self.flags.is_none() {
            self.flags = Some(0);
        };
        self.flags.as_mut().unwrap()
    }

    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or_else(|| 0)
    }

    pub fn clear_string_data(&mut self) {
        self.string_data.clear();
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: Vec<u8>) {
        self.string_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.string_data.is_none() {
            self.string_data.set_default();
        };
        self.string_data.as_mut().unwrap()
    }

    pub fn get_string_data(&'a self) -> &'a [u8] {
        match self.string_data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CSVCMsg_CreateStringTable {
    fn new() -> CSVCMsg_CreateStringTable {
        CSVCMsg_CreateStringTable::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.max_entries = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.num_entries = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.user_data_fixed_size = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.user_data_size = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.user_data_size_bits = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.flags = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.string_data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.max_entries.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_entries.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.user_data_fixed_size.is_some() {
            my_size += 2;
        };
        for value in self.user_data_size.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.user_data_size_bits.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.flags.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.string_data.iter() {
            my_size += ::protobuf::rt::bytes_size(8, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.max_entries {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.num_entries {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.user_data_fixed_size {
            Some(ref v) => {
                os.write_bool(4, *v);
            },
            None => {},
        };
        match self.user_data_size {
            Some(ref v) => {
                os.write_int32(5, *v);
            },
            None => {},
        };
        match self.user_data_size_bits {
            Some(ref v) => {
                os.write_int32(6, *v);
            },
            None => {},
        };
        match self.flags {
            Some(ref v) => {
                os.write_int32(7, *v);
            },
            None => {},
        };
        match self.string_data.as_ref() {
            Some(ref v) => {
                os.write_bytes(8, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_CreateStringTable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_name_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_max_entries_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_num_entries_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_user_data_fixed_size_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_user_data_size_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_user_data_size_bits_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_flags_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_CreateStringTable_string_data_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_CreateStringTable>(
                    "CSVCMsg_CreateStringTable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_CreateStringTable>()
    }
}

impl ::protobuf::Clear for CSVCMsg_CreateStringTable {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_max_entries();
        self.clear_num_entries();
        self.clear_user_data_fixed_size();
        self.clear_user_data_size();
        self.clear_user_data_size_bits();
        self.clear_flags();
        self.clear_string_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_CreateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_name_acc_type;
static CSVCMsg_CreateStringTable_name_acc: CSVCMsg_CreateStringTable_name_acc_type = CSVCMsg_CreateStringTable_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CSVCMsg_CreateStringTable) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_max_entries_acc_type;
static CSVCMsg_CreateStringTable_max_entries_acc: CSVCMsg_CreateStringTable_max_entries_acc_type = CSVCMsg_CreateStringTable_max_entries_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_max_entries_acc_type {
    fn name(&self) -> &'static str {
        "max_entries"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_max_entries()
    }

    fn get_i32(&self, m: &CSVCMsg_CreateStringTable) -> i32 {
        m.get_max_entries()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_num_entries_acc_type;
static CSVCMsg_CreateStringTable_num_entries_acc: CSVCMsg_CreateStringTable_num_entries_acc_type = CSVCMsg_CreateStringTable_num_entries_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_num_entries_acc_type {
    fn name(&self) -> &'static str {
        "num_entries"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_num_entries()
    }

    fn get_i32(&self, m: &CSVCMsg_CreateStringTable) -> i32 {
        m.get_num_entries()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_user_data_fixed_size_acc_type;
static CSVCMsg_CreateStringTable_user_data_fixed_size_acc: CSVCMsg_CreateStringTable_user_data_fixed_size_acc_type = CSVCMsg_CreateStringTable_user_data_fixed_size_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_user_data_fixed_size_acc_type {
    fn name(&self) -> &'static str {
        "user_data_fixed_size"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_user_data_fixed_size()
    }

    fn get_bool(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.get_user_data_fixed_size()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_user_data_size_acc_type;
static CSVCMsg_CreateStringTable_user_data_size_acc: CSVCMsg_CreateStringTable_user_data_size_acc_type = CSVCMsg_CreateStringTable_user_data_size_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_user_data_size_acc_type {
    fn name(&self) -> &'static str {
        "user_data_size"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_user_data_size()
    }

    fn get_i32(&self, m: &CSVCMsg_CreateStringTable) -> i32 {
        m.get_user_data_size()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_user_data_size_bits_acc_type;
static CSVCMsg_CreateStringTable_user_data_size_bits_acc: CSVCMsg_CreateStringTable_user_data_size_bits_acc_type = CSVCMsg_CreateStringTable_user_data_size_bits_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_user_data_size_bits_acc_type {
    fn name(&self) -> &'static str {
        "user_data_size_bits"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_user_data_size_bits()
    }

    fn get_i32(&self, m: &CSVCMsg_CreateStringTable) -> i32 {
        m.get_user_data_size_bits()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_flags_acc_type;
static CSVCMsg_CreateStringTable_flags_acc: CSVCMsg_CreateStringTable_flags_acc_type = CSVCMsg_CreateStringTable_flags_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_flags_acc_type {
    fn name(&self) -> &'static str {
        "flags"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_flags()
    }

    fn get_i32(&self, m: &CSVCMsg_CreateStringTable) -> i32 {
        m.get_flags()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_CreateStringTable_string_data_acc_type;
static CSVCMsg_CreateStringTable_string_data_acc: CSVCMsg_CreateStringTable_string_data_acc_type = CSVCMsg_CreateStringTable_string_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_CreateStringTable> for CSVCMsg_CreateStringTable_string_data_acc_type {
    fn name(&self) -> &'static str {
        "string_data"
    }

    fn has_field(&self, m: &CSVCMsg_CreateStringTable) -> bool {
        m.has_string_data()
    }

    fn get_bytes<'a>(&self, m: &'a CSVCMsg_CreateStringTable) -> &'a [u8] {
        m.get_string_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_UpdateStringTable {
    table_id: Option<i32>,
    num_changed_entries: Option<i32>,
    string_data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_UpdateStringTable {
    pub fn new() -> CSVCMsg_UpdateStringTable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_UpdateStringTable {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_UpdateStringTable> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_UpdateStringTable };
        unsafe {
            instance.get(|| {
                CSVCMsg_UpdateStringTable {
                    table_id: None,
                    num_changed_entries: None,
                    string_data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_table_id(&mut self) {
        self.table_id = None;
    }

    pub fn has_table_id(&self) -> bool {
        self.table_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: i32) {
        self.table_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_id(&'a mut self) -> &'a mut i32 {
        if self.table_id.is_none() {
            self.table_id = Some(0);
        };
        self.table_id.as_mut().unwrap()
    }

    pub fn get_table_id(&self) -> i32 {
        self.table_id.unwrap_or_else(|| 0)
    }

    pub fn clear_num_changed_entries(&mut self) {
        self.num_changed_entries = None;
    }

    pub fn has_num_changed_entries(&self) -> bool {
        self.num_changed_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_changed_entries(&mut self, v: i32) {
        self.num_changed_entries = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_changed_entries(&'a mut self) -> &'a mut i32 {
        if self.num_changed_entries.is_none() {
            self.num_changed_entries = Some(0);
        };
        self.num_changed_entries.as_mut().unwrap()
    }

    pub fn get_num_changed_entries(&self) -> i32 {
        self.num_changed_entries.unwrap_or_else(|| 0)
    }

    pub fn clear_string_data(&mut self) {
        self.string_data.clear();
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: Vec<u8>) {
        self.string_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.string_data.is_none() {
            self.string_data.set_default();
        };
        self.string_data.as_mut().unwrap()
    }

    pub fn get_string_data(&'a self) -> &'a [u8] {
        match self.string_data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CSVCMsg_UpdateStringTable {
    fn new() -> CSVCMsg_UpdateStringTable {
        CSVCMsg_UpdateStringTable::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.table_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.num_changed_entries = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.string_data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.table_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_changed_entries.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.string_data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.table_id {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.num_changed_entries {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.string_data.as_ref() {
            Some(ref v) => {
                os.write_bytes(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_UpdateStringTable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_UpdateStringTable>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_UpdateStringTable_table_id_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_UpdateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_UpdateStringTable_num_changed_entries_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_UpdateStringTable>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_UpdateStringTable_string_data_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_UpdateStringTable>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_UpdateStringTable>(
                    "CSVCMsg_UpdateStringTable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_UpdateStringTable>()
    }
}

impl ::protobuf::Clear for CSVCMsg_UpdateStringTable {
    fn clear(&mut self) {
        self.clear_table_id();
        self.clear_num_changed_entries();
        self.clear_string_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_UpdateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_UpdateStringTable_table_id_acc_type;
static CSVCMsg_UpdateStringTable_table_id_acc: CSVCMsg_UpdateStringTable_table_id_acc_type = CSVCMsg_UpdateStringTable_table_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_UpdateStringTable> for CSVCMsg_UpdateStringTable_table_id_acc_type {
    fn name(&self) -> &'static str {
        "table_id"
    }

    fn has_field(&self, m: &CSVCMsg_UpdateStringTable) -> bool {
        m.has_table_id()
    }

    fn get_i32(&self, m: &CSVCMsg_UpdateStringTable) -> i32 {
        m.get_table_id()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_UpdateStringTable_num_changed_entries_acc_type;
static CSVCMsg_UpdateStringTable_num_changed_entries_acc: CSVCMsg_UpdateStringTable_num_changed_entries_acc_type = CSVCMsg_UpdateStringTable_num_changed_entries_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_UpdateStringTable> for CSVCMsg_UpdateStringTable_num_changed_entries_acc_type {
    fn name(&self) -> &'static str {
        "num_changed_entries"
    }

    fn has_field(&self, m: &CSVCMsg_UpdateStringTable) -> bool {
        m.has_num_changed_entries()
    }

    fn get_i32(&self, m: &CSVCMsg_UpdateStringTable) -> i32 {
        m.get_num_changed_entries()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_UpdateStringTable_string_data_acc_type;
static CSVCMsg_UpdateStringTable_string_data_acc: CSVCMsg_UpdateStringTable_string_data_acc_type = CSVCMsg_UpdateStringTable_string_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_UpdateStringTable> for CSVCMsg_UpdateStringTable_string_data_acc_type {
    fn name(&self) -> &'static str {
        "string_data"
    }

    fn has_field(&self, m: &CSVCMsg_UpdateStringTable) -> bool {
        m.has_string_data()
    }

    fn get_bytes<'a>(&self, m: &'a CSVCMsg_UpdateStringTable) -> &'a [u8] {
        m.get_string_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_UserMessage {
    msg_type: Option<i32>,
    msg_data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_UserMessage {
    pub fn new() -> CSVCMsg_UserMessage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_UserMessage {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_UserMessage> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_UserMessage };
        unsafe {
            instance.get(|| {
                CSVCMsg_UserMessage {
                    msg_type: None,
                    msg_data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_type(&'a mut self) -> &'a mut i32 {
        if self.msg_type.is_none() {
            self.msg_type = Some(0);
        };
        self.msg_type.as_mut().unwrap()
    }

    pub fn get_msg_type(&self) -> i32 {
        self.msg_type.unwrap_or_else(|| 0)
    }

    pub fn clear_msg_data(&mut self) {
        self.msg_data.clear();
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: Vec<u8>) {
        self.msg_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.msg_data.is_none() {
            self.msg_data.set_default();
        };
        self.msg_data.as_mut().unwrap()
    }

    pub fn get_msg_data(&'a self) -> &'a [u8] {
        match self.msg_data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CSVCMsg_UserMessage {
    fn new() -> CSVCMsg_UserMessage {
        CSVCMsg_UserMessage::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.msg_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.msg_data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.msg_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.msg_data.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.msg_type {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.msg_data.as_ref() {
            Some(ref v) => {
                os.write_bytes(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_UserMessage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_UserMessage>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_UserMessage_msg_type_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_UserMessage>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_UserMessage_msg_data_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_UserMessage>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_UserMessage>(
                    "CSVCMsg_UserMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_UserMessage>()
    }
}

impl ::protobuf::Clear for CSVCMsg_UserMessage {
    fn clear(&mut self) {
        self.clear_msg_type();
        self.clear_msg_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_UserMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_UserMessage_msg_type_acc_type;
static CSVCMsg_UserMessage_msg_type_acc: CSVCMsg_UserMessage_msg_type_acc_type = CSVCMsg_UserMessage_msg_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_UserMessage> for CSVCMsg_UserMessage_msg_type_acc_type {
    fn name(&self) -> &'static str {
        "msg_type"
    }

    fn has_field(&self, m: &CSVCMsg_UserMessage) -> bool {
        m.has_msg_type()
    }

    fn get_i32(&self, m: &CSVCMsg_UserMessage) -> i32 {
        m.get_msg_type()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_UserMessage_msg_data_acc_type;
static CSVCMsg_UserMessage_msg_data_acc: CSVCMsg_UserMessage_msg_data_acc_type = CSVCMsg_UserMessage_msg_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_UserMessage> for CSVCMsg_UserMessage_msg_data_acc_type {
    fn name(&self) -> &'static str {
        "msg_data"
    }

    fn has_field(&self, m: &CSVCMsg_UserMessage) -> bool {
        m.has_msg_data()
    }

    fn get_bytes<'a>(&self, m: &'a CSVCMsg_UserMessage) -> &'a [u8] {
        m.get_msg_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsg_VoiceData {
    client: Option<i32>,
    proximity: Option<bool>,
    xuid: Option<u64>,
    audible_mask: Option<i32>,
    voice_data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsg_VoiceData {
    pub fn new() -> CSVCMsg_VoiceData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsg_VoiceData {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsg_VoiceData> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsg_VoiceData };
        unsafe {
            instance.get(|| {
                CSVCMsg_VoiceData {
                    client: None,
                    proximity: None,
                    xuid: None,
                    audible_mask: None,
                    voice_data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_client(&mut self) {
        self.client = None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&'a mut self) -> &'a mut i32 {
        if self.client.is_none() {
            self.client = Some(0);
        };
        self.client.as_mut().unwrap()
    }

    pub fn get_client(&self) -> i32 {
        self.client.unwrap_or_else(|| 0)
    }

    pub fn clear_proximity(&mut self) {
        self.proximity = None;
    }

    pub fn has_proximity(&self) -> bool {
        self.proximity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proximity(&mut self, v: bool) {
        self.proximity = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proximity(&'a mut self) -> &'a mut bool {
        if self.proximity.is_none() {
            self.proximity = Some(false);
        };
        self.proximity.as_mut().unwrap()
    }

    pub fn get_proximity(&self) -> bool {
        self.proximity.unwrap_or_else(|| false)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xuid(&'a mut self) -> &'a mut u64 {
        if self.xuid.is_none() {
            self.xuid = Some(0);
        };
        self.xuid.as_mut().unwrap()
    }

    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or_else(|| 0)
    }

    pub fn clear_audible_mask(&mut self) {
        self.audible_mask = None;
    }

    pub fn has_audible_mask(&self) -> bool {
        self.audible_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audible_mask(&mut self, v: i32) {
        self.audible_mask = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audible_mask(&'a mut self) -> &'a mut i32 {
        if self.audible_mask.is_none() {
            self.audible_mask = Some(0);
        };
        self.audible_mask.as_mut().unwrap()
    }

    pub fn get_audible_mask(&self) -> i32 {
        self.audible_mask.unwrap_or_else(|| 0)
    }

    pub fn clear_voice_data(&mut self) {
        self.voice_data.clear();
    }

    pub fn has_voice_data(&self) -> bool {
        self.voice_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_data(&mut self, v: Vec<u8>) {
        self.voice_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.voice_data.is_none() {
            self.voice_data.set_default();
        };
        self.voice_data.as_mut().unwrap()
    }

    pub fn get_voice_data(&'a self) -> &'a [u8] {
        match self.voice_data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceData {
    fn new() -> CSVCMsg_VoiceData {
        CSVCMsg_VoiceData::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.client = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.proximity = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed64, wire_type);
                    let tmp = is.read_fixed64();
                    self.xuid = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.audible_mask = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.voice_data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.client.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.proximity.is_some() {
            my_size += 2;
        };
        if self.xuid.is_some() {
            my_size += 9;
        };
        for value in self.audible_mask.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.voice_data.iter() {
            my_size += ::protobuf::rt::bytes_size(5, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.client {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.proximity {
            Some(ref v) => {
                os.write_bool(2, *v);
            },
            None => {},
        };
        match self.xuid {
            Some(ref v) => {
                os.write_fixed64(3, *v);
            },
            None => {},
        };
        match self.audible_mask {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.voice_data.as_ref() {
            Some(ref v) => {
                os.write_bytes(5, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsg_VoiceData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_VoiceData_client_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_VoiceData_proximity_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_VoiceData_xuid_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_VoiceData_audible_mask_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsg_VoiceData_voice_data_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsg_VoiceData>(
                    "CSVCMsg_VoiceData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsg_VoiceData>()
    }
}

impl ::protobuf::Clear for CSVCMsg_VoiceData {
    fn clear(&mut self) {
        self.clear_client();
        self.clear_proximity();
        self.clear_xuid();
        self.clear_audible_mask();
        self.clear_voice_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsg_VoiceData_client_acc_type;
static CSVCMsg_VoiceData_client_acc: CSVCMsg_VoiceData_client_acc_type = CSVCMsg_VoiceData_client_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData> for CSVCMsg_VoiceData_client_acc_type {
    fn name(&self) -> &'static str {
        "client"
    }

    fn has_field(&self, m: &CSVCMsg_VoiceData) -> bool {
        m.has_client()
    }

    fn get_i32(&self, m: &CSVCMsg_VoiceData) -> i32 {
        m.get_client()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_VoiceData_proximity_acc_type;
static CSVCMsg_VoiceData_proximity_acc: CSVCMsg_VoiceData_proximity_acc_type = CSVCMsg_VoiceData_proximity_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData> for CSVCMsg_VoiceData_proximity_acc_type {
    fn name(&self) -> &'static str {
        "proximity"
    }

    fn has_field(&self, m: &CSVCMsg_VoiceData) -> bool {
        m.has_proximity()
    }

    fn get_bool(&self, m: &CSVCMsg_VoiceData) -> bool {
        m.get_proximity()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_VoiceData_xuid_acc_type;
static CSVCMsg_VoiceData_xuid_acc: CSVCMsg_VoiceData_xuid_acc_type = CSVCMsg_VoiceData_xuid_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData> for CSVCMsg_VoiceData_xuid_acc_type {
    fn name(&self) -> &'static str {
        "xuid"
    }

    fn has_field(&self, m: &CSVCMsg_VoiceData) -> bool {
        m.has_xuid()
    }

    fn get_u64(&self, m: &CSVCMsg_VoiceData) -> u64 {
        m.get_xuid()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_VoiceData_audible_mask_acc_type;
static CSVCMsg_VoiceData_audible_mask_acc: CSVCMsg_VoiceData_audible_mask_acc_type = CSVCMsg_VoiceData_audible_mask_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData> for CSVCMsg_VoiceData_audible_mask_acc_type {
    fn name(&self) -> &'static str {
        "audible_mask"
    }

    fn has_field(&self, m: &CSVCMsg_VoiceData) -> bool {
        m.has_audible_mask()
    }

    fn get_i32(&self, m: &CSVCMsg_VoiceData) -> i32 {
        m.get_audible_mask()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsg_VoiceData_voice_data_acc_type;
static CSVCMsg_VoiceData_voice_data_acc: CSVCMsg_VoiceData_voice_data_acc_type = CSVCMsg_VoiceData_voice_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsg_VoiceData> for CSVCMsg_VoiceData_voice_data_acc_type {
    fn name(&self) -> &'static str {
        "voice_data"
    }

    fn has_field(&self, m: &CSVCMsg_VoiceData) -> bool {
        m.has_voice_data()
    }

    fn get_bytes<'a>(&self, m: &'a CSVCMsg_VoiceData) -> &'a [u8] {
        m.get_voice_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsgList_GameEvents {
    events: ::protobuf::RepeatedField<CSVCMsgList_GameEvents_event_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsgList_GameEvents {
    pub fn new() -> CSVCMsgList_GameEvents {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsgList_GameEvents {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsgList_GameEvents> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsgList_GameEvents };
        unsafe {
            instance.get(|| {
                CSVCMsgList_GameEvents {
                    events: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<CSVCMsgList_GameEvents_event_t>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsgList_GameEvents_event_t> {
        &mut self.events
    }

    pub fn get_events(&'a self) -> &'a [CSVCMsgList_GameEvents_event_t] {
        self.events.as_slice()
    }

    pub fn add_events(&mut self, v: CSVCMsgList_GameEvents_event_t) {
        self.events.push(v);
    }
}

impl ::protobuf::Message for CSVCMsgList_GameEvents {
    fn new() -> CSVCMsgList_GameEvents {
        CSVCMsgList_GameEvents::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.events.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.events.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.events.iter() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsgList_GameEvents>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsgList_GameEvents_events_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsgList_GameEvents>(
                    "CSVCMsgList_GameEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsgList_GameEvents>()
    }
}

impl ::protobuf::Clear for CSVCMsgList_GameEvents {
    fn clear(&mut self) {
        self.clear_events();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsgList_GameEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsgList_GameEvents_events_acc_type;
static CSVCMsgList_GameEvents_events_acc: CSVCMsgList_GameEvents_events_acc_type = CSVCMsgList_GameEvents_events_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents> for CSVCMsgList_GameEvents_events_acc_type {
    fn name(&self) -> &'static str {
        "events"
    }

    fn len_field(&self, m: &CSVCMsgList_GameEvents) -> uint {
        m.get_events().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsgList_GameEvents, index: uint) -> &'a ::protobuf::Message {
        &m.get_events()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsgList_GameEvents_event_t {
    tick: Option<i32>,
    event: ::protobuf::SingularPtrField<CSVCMsg_GameEvent>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsgList_GameEvents_event_t {
    pub fn new() -> CSVCMsgList_GameEvents_event_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsgList_GameEvents_event_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsgList_GameEvents_event_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsgList_GameEvents_event_t };
        unsafe {
            instance.get(|| {
                CSVCMsgList_GameEvents_event_t {
                    tick: None,
                    event: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_tick(&mut self) {
        self.tick = None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tick(&'a mut self) -> &'a mut i32 {
        if self.tick.is_none() {
            self.tick = Some(0);
        };
        self.tick.as_mut().unwrap()
    }

    pub fn get_tick(&self) -> i32 {
        self.tick.unwrap_or_else(|| 0)
    }

    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: CSVCMsg_GameEvent) {
        self.event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&'a mut self) -> &'a mut CSVCMsg_GameEvent {
        if self.event.is_none() {
            self.event.set_default();
        };
        self.event.as_mut().unwrap()
    }

    pub fn get_event(&'a self) -> &'a CSVCMsg_GameEvent {
        self.event.as_ref().unwrap_or_else(|| CSVCMsg_GameEvent::default_instance())
    }
}

impl ::protobuf::Message for CSVCMsgList_GameEvents_event_t {
    fn new() -> CSVCMsgList_GameEvents_event_t {
        CSVCMsgList_GameEvents_event_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.tick = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.event.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.tick.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.event.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.tick {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.event.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsgList_GameEvents_event_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents_event_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsgList_GameEvents_event_t_tick_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents_event_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsgList_GameEvents_event_t_event_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents_event_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsgList_GameEvents_event_t>(
                    "CSVCMsgList_GameEvents_event_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsgList_GameEvents_event_t>()
    }
}

impl ::protobuf::Clear for CSVCMsgList_GameEvents_event_t {
    fn clear(&mut self) {
        self.clear_tick();
        self.clear_event();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsgList_GameEvents_event_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsgList_GameEvents_event_t_tick_acc_type;
static CSVCMsgList_GameEvents_event_t_tick_acc: CSVCMsgList_GameEvents_event_t_tick_acc_type = CSVCMsgList_GameEvents_event_t_tick_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents_event_t> for CSVCMsgList_GameEvents_event_t_tick_acc_type {
    fn name(&self) -> &'static str {
        "tick"
    }

    fn has_field(&self, m: &CSVCMsgList_GameEvents_event_t) -> bool {
        m.has_tick()
    }

    fn get_i32(&self, m: &CSVCMsgList_GameEvents_event_t) -> i32 {
        m.get_tick()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsgList_GameEvents_event_t_event_acc_type;
static CSVCMsgList_GameEvents_event_t_event_acc: CSVCMsgList_GameEvents_event_t_event_acc_type = CSVCMsgList_GameEvents_event_t_event_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsgList_GameEvents_event_t> for CSVCMsgList_GameEvents_event_t_event_acc_type {
    fn name(&self) -> &'static str {
        "event"
    }

    fn has_field(&self, m: &CSVCMsgList_GameEvents_event_t) -> bool {
        m.has_event()
    }

    fn get_message<'a>(&self, m: &'a CSVCMsgList_GameEvents_event_t) -> &'a ::protobuf::Message {
        m.get_event() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsgList_UserMessages {
    usermsgs: ::protobuf::RepeatedField<CSVCMsgList_UserMessages_usermsg_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsgList_UserMessages {
    pub fn new() -> CSVCMsgList_UserMessages {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsgList_UserMessages {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsgList_UserMessages> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsgList_UserMessages };
        unsafe {
            instance.get(|| {
                CSVCMsgList_UserMessages {
                    usermsgs: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_usermsgs(&mut self) {
        self.usermsgs.clear();
    }

    // Param is passed by value, moved
    pub fn set_usermsgs(&mut self, v: ::protobuf::RepeatedField<CSVCMsgList_UserMessages_usermsg_t>) {
        self.usermsgs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_usermsgs(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CSVCMsgList_UserMessages_usermsg_t> {
        &mut self.usermsgs
    }

    pub fn get_usermsgs(&'a self) -> &'a [CSVCMsgList_UserMessages_usermsg_t] {
        self.usermsgs.as_slice()
    }

    pub fn add_usermsgs(&mut self, v: CSVCMsgList_UserMessages_usermsg_t) {
        self.usermsgs.push(v);
    }
}

impl ::protobuf::Message for CSVCMsgList_UserMessages {
    fn new() -> CSVCMsgList_UserMessages {
        CSVCMsgList_UserMessages::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.usermsgs.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.usermsgs.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.usermsgs.iter() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsgList_UserMessages>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsgList_UserMessages_usermsgs_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsgList_UserMessages>(
                    "CSVCMsgList_UserMessages",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsgList_UserMessages>()
    }
}

impl ::protobuf::Clear for CSVCMsgList_UserMessages {
    fn clear(&mut self) {
        self.clear_usermsgs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsgList_UserMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsgList_UserMessages_usermsgs_acc_type;
static CSVCMsgList_UserMessages_usermsgs_acc: CSVCMsgList_UserMessages_usermsgs_acc_type = CSVCMsgList_UserMessages_usermsgs_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages> for CSVCMsgList_UserMessages_usermsgs_acc_type {
    fn name(&self) -> &'static str {
        "usermsgs"
    }

    fn len_field(&self, m: &CSVCMsgList_UserMessages) -> uint {
        m.get_usermsgs().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CSVCMsgList_UserMessages, index: uint) -> &'a ::protobuf::Message {
        &m.get_usermsgs()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CSVCMsgList_UserMessages_usermsg_t {
    tick: Option<i32>,
    msg: ::protobuf::SingularPtrField<CSVCMsg_UserMessage>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CSVCMsgList_UserMessages_usermsg_t {
    pub fn new() -> CSVCMsgList_UserMessages_usermsg_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSVCMsgList_UserMessages_usermsg_t {
        static mut instance: ::protobuf::lazy::Lazy<CSVCMsgList_UserMessages_usermsg_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CSVCMsgList_UserMessages_usermsg_t };
        unsafe {
            instance.get(|| {
                CSVCMsgList_UserMessages_usermsg_t {
                    tick: None,
                    msg: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_tick(&mut self) {
        self.tick = None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tick(&'a mut self) -> &'a mut i32 {
        if self.tick.is_none() {
            self.tick = Some(0);
        };
        self.tick.as_mut().unwrap()
    }

    pub fn get_tick(&self) -> i32 {
        self.tick.unwrap_or_else(|| 0)
    }

    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: CSVCMsg_UserMessage) {
        self.msg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&'a mut self) -> &'a mut CSVCMsg_UserMessage {
        if self.msg.is_none() {
            self.msg.set_default();
        };
        self.msg.as_mut().unwrap()
    }

    pub fn get_msg(&'a self) -> &'a CSVCMsg_UserMessage {
        self.msg.as_ref().unwrap_or_else(|| CSVCMsg_UserMessage::default_instance())
    }
}

impl ::protobuf::Message for CSVCMsgList_UserMessages_usermsg_t {
    fn new() -> CSVCMsgList_UserMessages_usermsg_t {
        CSVCMsgList_UserMessages_usermsg_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.tick = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.msg.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.tick.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.msg.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.tick {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.msg.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CSVCMsgList_UserMessages_usermsg_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages_usermsg_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsgList_UserMessages_usermsg_t_tick_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages_usermsg_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CSVCMsgList_UserMessages_usermsg_t_msg_acc as &'static ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages_usermsg_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CSVCMsgList_UserMessages_usermsg_t>(
                    "CSVCMsgList_UserMessages_usermsg_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CSVCMsgList_UserMessages_usermsg_t>()
    }
}

impl ::protobuf::Clear for CSVCMsgList_UserMessages_usermsg_t {
    fn clear(&mut self) {
        self.clear_tick();
        self.clear_msg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CSVCMsgList_UserMessages_usermsg_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CSVCMsgList_UserMessages_usermsg_t_tick_acc_type;
static CSVCMsgList_UserMessages_usermsg_t_tick_acc: CSVCMsgList_UserMessages_usermsg_t_tick_acc_type = CSVCMsgList_UserMessages_usermsg_t_tick_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages_usermsg_t> for CSVCMsgList_UserMessages_usermsg_t_tick_acc_type {
    fn name(&self) -> &'static str {
        "tick"
    }

    fn has_field(&self, m: &CSVCMsgList_UserMessages_usermsg_t) -> bool {
        m.has_tick()
    }

    fn get_i32(&self, m: &CSVCMsgList_UserMessages_usermsg_t) -> i32 {
        m.get_tick()
    }
}

#[allow(non_camel_case_types)]
struct CSVCMsgList_UserMessages_usermsg_t_msg_acc_type;
static CSVCMsgList_UserMessages_usermsg_t_msg_acc: CSVCMsgList_UserMessages_usermsg_t_msg_acc_type = CSVCMsgList_UserMessages_usermsg_t_msg_acc_type;

impl ::protobuf::reflect::FieldAccessor<CSVCMsgList_UserMessages_usermsg_t> for CSVCMsgList_UserMessages_usermsg_t_msg_acc_type {
    fn name(&self) -> &'static str {
        "msg"
    }

    fn has_field(&self, m: &CSVCMsgList_UserMessages_usermsg_t) -> bool {
        m.has_msg()
    }

    fn get_message<'a>(&self, m: &'a CSVCMsgList_UserMessages_usermsg_t) -> &'a ::protobuf::Message {
        m.get_msg() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum NET_Messages {
    net_NOP = 0,
    net_Disconnect = 1,
    net_File = 2,
    net_SplitScreenUser = 3,
    net_Tick = 4,
    net_StringCmd = 5,
    net_SetConVar = 6,
    net_SignonState = 7,
}

impl NET_Messages {
    pub fn new(value: i32) -> NET_Messages {
        match value {
            0 => net_NOP,
            1 => net_Disconnect,
            2 => net_File,
            3 => net_SplitScreenUser,
            4 => net_Tick,
            5 => net_StringCmd,
            6 => net_SetConVar,
            7 => net_SignonState,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for NET_Messages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<NET_Messages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NET_Messages", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum SIGNONSTATE {
    SIGNONSTATE_NONE = 0,
    SIGNONSTATE_CHALLENGE = 1,
    SIGNONSTATE_CONNECTED = 2,
    SIGNONSTATE_NEW = 3,
    SIGNONSTATE_PRESPAWN = 4,
    SIGNONSTATE_SPAWN = 5,
    SIGNONSTATE_FULL = 6,
    SIGNONSTATE_CHANGELEVEL = 7,
}

impl SIGNONSTATE {
    pub fn new(value: i32) -> SIGNONSTATE {
        match value {
            0 => SIGNONSTATE_NONE,
            1 => SIGNONSTATE_CHALLENGE,
            2 => SIGNONSTATE_CONNECTED,
            3 => SIGNONSTATE_NEW,
            4 => SIGNONSTATE_PRESPAWN,
            5 => SIGNONSTATE_SPAWN,
            6 => SIGNONSTATE_FULL,
            7 => SIGNONSTATE_CHANGELEVEL,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for SIGNONSTATE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<SIGNONSTATE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SIGNONSTATE", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum CLC_Messages {
    clc_ClientInfo = 8,
    clc_Move = 9,
    clc_VoiceData = 10,
    clc_BaselineAck = 11,
    clc_ListenEvents = 12,
    clc_RespondCvarValue = 13,
    clc_FileCRCCheck = 14,
    clc_LoadingProgress = 15,
    clc_SplitPlayerConnect = 16,
    clc_ClientMessage = 17,
}

impl CLC_Messages {
    pub fn new(value: i32) -> CLC_Messages {
        match value {
            8 => clc_ClientInfo,
            9 => clc_Move,
            10 => clc_VoiceData,
            11 => clc_BaselineAck,
            12 => clc_ListenEvents,
            13 => clc_RespondCvarValue,
            14 => clc_FileCRCCheck,
            15 => clc_LoadingProgress,
            16 => clc_SplitPlayerConnect,
            17 => clc_ClientMessage,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for CLC_Messages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<CLC_Messages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CLC_Messages", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum SVC_Messages {
    svc_ServerInfo = 8,
    svc_SendTable = 9,
    svc_ClassInfo = 10,
    svc_SetPause = 11,
    svc_CreateStringTable = 12,
    svc_UpdateStringTable = 13,
    svc_VoiceInit = 14,
    svc_VoiceData = 15,
    svc_Print = 16,
    svc_Sounds = 17,
    svc_SetView = 18,
    svc_FixAngle = 19,
    svc_CrosshairAngle = 20,
    svc_BSPDecal = 21,
    svc_SplitScreen = 22,
    svc_UserMessage = 23,
    svc_EntityMessage = 24,
    svc_GameEvent = 25,
    svc_PacketEntities = 26,
    svc_TempEntities = 27,
    svc_Prefetch = 28,
    svc_Menu = 29,
    svc_GameEventList = 30,
    svc_GetCvarValue = 31,
}

impl SVC_Messages {
    pub fn new(value: i32) -> SVC_Messages {
        match value {
            8 => svc_ServerInfo,
            9 => svc_SendTable,
            10 => svc_ClassInfo,
            11 => svc_SetPause,
            12 => svc_CreateStringTable,
            13 => svc_UpdateStringTable,
            14 => svc_VoiceInit,
            15 => svc_VoiceData,
            16 => svc_Print,
            17 => svc_Sounds,
            18 => svc_SetView,
            19 => svc_FixAngle,
            20 => svc_CrosshairAngle,
            21 => svc_BSPDecal,
            22 => svc_SplitScreen,
            23 => svc_UserMessage,
            24 => svc_EntityMessage,
            25 => svc_GameEvent,
            26 => svc_PacketEntities,
            27 => svc_TempEntities,
            28 => svc_Prefetch,
            29 => svc_Menu,
            30 => svc_GameEventList,
            31 => svc_GetCvarValue,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for SVC_Messages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<SVC_Messages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SVC_Messages", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum ESplitScreenMessageType {
    MSG_SPLITSCREEN_ADDUSER = 0,
    MSG_SPLITSCREEN_REMOVEUSER = 1,
    MSG_SPLITSCREEN_TYPE_BITS = 1,
}

impl ESplitScreenMessageType {
    pub fn new(value: i32) -> ESplitScreenMessageType {
        match value {
            0 => MSG_SPLITSCREEN_ADDUSER,
            1 => MSG_SPLITSCREEN_REMOVEUSER,
            1 => MSG_SPLITSCREEN_TYPE_BITS,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for ESplitScreenMessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<ESplitScreenMessageType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ESplitScreenMessageType", file_descriptor_proto())
            })
        }
    }
}
