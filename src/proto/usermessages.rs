// This file is generated. Do not edit

#![allow(dead_code)]
#![allow(non_camel_case_types)]

use descriptor::*;
use netmessages::*;

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x12, 0x75, 0x73, 0x65, 0x72, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x70,
    0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f,
    0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72,
    0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x11, 0x6e, 0x65, 0x74, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x30, 0x0a, 0x19, 0x43, 0x55, 0x73,
    0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e,
    0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x13, 0x0a, 0x0b, 0x61, 0x63, 0x68, 0x69, 0x65, 0x76,
    0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x4c, 0x0a, 0x15, 0x43,
    0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x61, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0c, 0x0a, 0x04, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x07, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x02, 0x12, 0x13, 0x0a, 0x0b, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x70, 0x6c, 0x61,
    0x79, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x22, 0x2c, 0x0a, 0x19, 0x43, 0x55, 0x73,
    0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d,
    0x65, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
    0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x22, 0x6e, 0x0a, 0x19, 0x43, 0x55, 0x73, 0x65, 0x72,
    0x4d, 0x73, 0x67, 0x5f, 0x44, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73,
    0x63, 0x61, 0x6c, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x02, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x12, 0x14, 0x0a, 0x0c, 0x69, 0x6e, 0x74, 0x65, 0x72,
    0x70, 0x6f, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a,
    0x10, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x62, 0x6c, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d,
    0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x22, 0x52, 0x0a, 0x0d, 0x43, 0x55, 0x73, 0x65, 0x72,
    0x4d, 0x73, 0x67, 0x5f, 0x46, 0x61, 0x64, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x68, 0x6f,
    0x6c, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a,
    0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05,
    0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x07, 0x22, 0x59, 0x0a, 0x0e, 0x43,
    0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x68, 0x61, 0x6b, 0x65, 0x12, 0x0f, 0x0a,
    0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11,
    0x0a, 0x09, 0x61, 0x6d, 0x70, 0x6c, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x02, 0x12, 0x11, 0x0a, 0x09, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x02, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x22, 0x53, 0x0a, 0x11, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d,
    0x73, 0x67, 0x5f, 0x53, 0x68, 0x61, 0x6b, 0x65, 0x44, 0x69, 0x72, 0x12, 0x1e, 0x0a, 0x05, 0x73,
    0x68, 0x61, 0x6b, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x43, 0x55, 0x73,
    0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x68, 0x61, 0x6b, 0x65, 0x12, 0x1e, 0x0a, 0x09, 0x64,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x22, 0x71, 0x0a, 0x0d, 0x43,
    0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x54, 0x69, 0x6c, 0x74, 0x12, 0x0f, 0x0a, 0x07,
    0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a,
    0x0b, 0x65, 0x61, 0x73, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x6f, 0x75, 0x74, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x08, 0x12, 0x1a, 0x0a, 0x05, 0x61, 0x6e, 0x67, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x10,
    0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02,
    0x12, 0x0c, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x22, 0x3e,
    0x0a, 0x10, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x61, 0x79, 0x54, 0x65,
    0x78, 0x74, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x0c, 0x0a, 0x04, 0x63, 0x68, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x22, 0x71,
    0x0a, 0x11, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x61, 0x79, 0x54, 0x65,
    0x78, 0x74, 0x32, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x63, 0x68, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x08, 0x12, 0x0e, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x0e, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x10, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28,
    0x09, 0x22, 0xca, 0x01, 0x0a, 0x0f, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x48,
    0x75, 0x64, 0x4d, 0x73, 0x67, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x09, 0x0a, 0x01, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x02, 0x12, 0x09, 0x0a, 0x01, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x12, 0x0e, 0x0a, 0x06,
    0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x31, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06,
    0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x32, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06,
    0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c,
    0x66, 0x61, 0x64, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01,
    0x28, 0x02, 0x12, 0x15, 0x0a, 0x0d, 0x66, 0x61, 0x64, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x5f, 0x74,
    0x69, 0x6d, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x02, 0x12, 0x11, 0x0a, 0x09, 0x68, 0x6f, 0x6c,
    0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x02, 0x12, 0x0f, 0x0a, 0x07,
    0x66, 0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x02, 0x12, 0x0f, 0x0a,
    0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x22, 0x23,
    0x0a, 0x10, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x48, 0x75, 0x64, 0x54, 0x65,
    0x78, 0x74, 0x12, 0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x09, 0x22, 0x2f, 0x0a, 0x10, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f,
    0x54, 0x65, 0x78, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x65, 0x73, 0x74, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x18, 0x02,
    0x20, 0x03, 0x28, 0x09, 0x22, 0x14, 0x0a, 0x12, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67,
    0x5f, 0x47, 0x61, 0x6d, 0x65, 0x54, 0x69, 0x74, 0x6c, 0x65, 0x22, 0x13, 0x0a, 0x11, 0x43, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x52, 0x65, 0x73, 0x65, 0x74, 0x48, 0x55, 0x44, 0x22,
    0x30, 0x0a, 0x12, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x65, 0x6e, 0x64,
    0x41, 0x75, 0x64, 0x69, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x73, 0x74, 0x6f, 0x70, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x09, 0x22, 0x4e, 0x0a, 0x12, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x56, 0x6f,
    0x69, 0x63, 0x65, 0x4d, 0x61, 0x73, 0x6b, 0x12, 0x1c, 0x0a, 0x14, 0x61, 0x75, 0x64, 0x69, 0x62,
    0x6c, 0x65, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x05, 0x12, 0x1a, 0x0a, 0x12, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f,
    0x6d, 0x6f, 0x64, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x08, 0x22, 0x17, 0x0a, 0x15, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x22, 0x24, 0x0a, 0x11, 0x43, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x48, 0x69, 0x6e, 0x74, 0x54, 0x65, 0x78, 0x74, 0x12,
    0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
    0x22, 0x28, 0x0a, 0x14, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x4b, 0x65, 0x79,
    0x48, 0x69, 0x6e, 0x74, 0x54, 0x65, 0x78, 0x74, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x22, 0x18, 0x0a, 0x16, 0x43, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x72, 0x61, 0x77,
    0x6c, 0x4d, 0x73, 0x67, 0x22, 0x41, 0x0a, 0x17, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67,
    0x5f, 0x53, 0x74, 0x61, 0x74, 0x73, 0x53, 0x6b, 0x69, 0x70, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12,
    0x11, 0x0a, 0x09, 0x6e, 0x75, 0x6d, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x73, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6e, 0x75, 0x6d, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72,
    0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x22, 0x47, 0x0a, 0x16, 0x43, 0x55, 0x73, 0x65, 0x72,
    0x4d, 0x73, 0x67, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x53, 0x75, 0x62, 0x74, 0x69, 0x74, 0x6c,
    0x65, 0x12, 0x11, 0x0a, 0x09, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x6d, 0x65, 0x6e, 0x75, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x69, 0x74, 0x65, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
    0x22, 0x7b, 0x0a, 0x11, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x56, 0x47, 0x55,
    0x49, 0x4d, 0x65, 0x6e, 0x75, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x73, 0x68, 0x6f, 0x77, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x08, 0x12, 0x25, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x17, 0x2e, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x56, 0x47, 0x55, 0x49, 0x4d,
    0x65, 0x6e, 0x75, 0x2e, 0x4b, 0x65, 0x79, 0x73, 0x1a, 0x23, 0x0a, 0x04, 0x4b, 0x65, 0x79, 0x73,
    0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0d,
    0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x20, 0x0a,
    0x0f, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x47, 0x65, 0x69, 0x67, 0x65, 0x72,
    0x12, 0x0d, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22,
    0x3d, 0x0a, 0x0f, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x52, 0x75, 0x6d, 0x62,
    0x6c, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x0d, 0x0a, 0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x22, 0x1f,
    0x0a, 0x0e, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x54, 0x72, 0x61, 0x69, 0x6e,
    0x12, 0x0d, 0x0a, 0x05, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22,
    0x48, 0x0a, 0x17, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x61, 0x79, 0x54,
    0x65, 0x78, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x0e, 0x0a, 0x06, 0x70, 0x6c,
    0x61, 0x79, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x68,
    0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x74,
    0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x22, 0x33, 0x0a, 0x14, 0x43, 0x55, 0x73,
    0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x65, 0x78,
    0x74, 0x12, 0x0d, 0x0a, 0x05, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x2a, 0xd4,
    0x04, 0x0a, 0x11, 0x45, 0x42, 0x61, 0x73, 0x65, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x73, 0x12, 0x17, 0x0a, 0x13, 0x55, 0x4d, 0x5f, 0x41, 0x63, 0x68, 0x69, 0x65,
    0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x10, 0x01, 0x12, 0x13, 0x0a,
    0x0f, 0x55, 0x4d, 0x5f, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x61, 0x70, 0x74, 0x69, 0x6f, 0x6e,
    0x10, 0x02, 0x12, 0x19, 0x0a, 0x15, 0x55, 0x4d, 0x5f, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x61,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x10, 0x03, 0x12, 0x17, 0x0a,
    0x13, 0x55, 0x4d, 0x5f, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73,
    0x63, 0x61, 0x6c, 0x65, 0x10, 0x04, 0x12, 0x17, 0x0a, 0x13, 0x55, 0x4d, 0x5f, 0x44, 0x65, 0x73,
    0x69, 0x72, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x10, 0x05, 0x12,
    0x0b, 0x0a, 0x07, 0x55, 0x4d, 0x5f, 0x46, 0x61, 0x64, 0x65, 0x10, 0x06, 0x12, 0x10, 0x0a, 0x0c,
    0x55, 0x4d, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x54, 0x69, 0x74, 0x6c, 0x65, 0x10, 0x07, 0x12, 0x0d,
    0x0a, 0x09, 0x55, 0x4d, 0x5f, 0x47, 0x65, 0x69, 0x67, 0x65, 0x72, 0x10, 0x08, 0x12, 0x0f, 0x0a,
    0x0b, 0x55, 0x4d, 0x5f, 0x48, 0x69, 0x6e, 0x74, 0x54, 0x65, 0x78, 0x74, 0x10, 0x09, 0x12, 0x0d,
    0x0a, 0x09, 0x55, 0x4d, 0x5f, 0x48, 0x75, 0x64, 0x4d, 0x73, 0x67, 0x10, 0x0a, 0x12, 0x0e, 0x0a,
    0x0a, 0x55, 0x4d, 0x5f, 0x48, 0x75, 0x64, 0x54, 0x65, 0x78, 0x74, 0x10, 0x0b, 0x12, 0x12, 0x0a,
    0x0e, 0x55, 0x4d, 0x5f, 0x4b, 0x65, 0x79, 0x48, 0x69, 0x6e, 0x74, 0x54, 0x65, 0x78, 0x74, 0x10,
    0x0c, 0x12, 0x12, 0x0a, 0x0e, 0x55, 0x4d, 0x5f, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54,
    0x65, 0x78, 0x74, 0x10, 0x0d, 0x12, 0x13, 0x0a, 0x0f, 0x55, 0x4d, 0x5f, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x10, 0x0e, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4d,
    0x5f, 0x52, 0x65, 0x73, 0x65, 0x74, 0x48, 0x55, 0x44, 0x10, 0x0f, 0x12, 0x0d, 0x0a, 0x09, 0x55,
    0x4d, 0x5f, 0x52, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x10, 0x10, 0x12, 0x0e, 0x0a, 0x0a, 0x55, 0x4d,
    0x5f, 0x53, 0x61, 0x79, 0x54, 0x65, 0x78, 0x74, 0x10, 0x11, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4d,
    0x5f, 0x53, 0x61, 0x79, 0x54, 0x65, 0x78, 0x74, 0x32, 0x10, 0x12, 0x12, 0x15, 0x0a, 0x11, 0x55,
    0x4d, 0x5f, 0x53, 0x61, 0x79, 0x54, 0x65, 0x78, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
    0x10, 0x13, 0x12, 0x0c, 0x0a, 0x08, 0x55, 0x4d, 0x5f, 0x53, 0x68, 0x61, 0x6b, 0x65, 0x10, 0x14,
    0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4d, 0x5f, 0x53, 0x68, 0x61, 0x6b, 0x65, 0x44, 0x69, 0x72, 0x10,
    0x15, 0x12, 0x14, 0x0a, 0x10, 0x55, 0x4d, 0x5f, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x72, 0x61,
    0x77, 0x6c, 0x4d, 0x73, 0x67, 0x10, 0x16, 0x12, 0x15, 0x0a, 0x11, 0x55, 0x4d, 0x5f, 0x53, 0x74,
    0x61, 0x74, 0x73, 0x53, 0x6b, 0x69, 0x70, 0x53, 0x74, 0x61, 0x74, 0x65, 0x10, 0x17, 0x12, 0x0e,
    0x0a, 0x0a, 0x55, 0x4d, 0x5f, 0x54, 0x65, 0x78, 0x74, 0x4d, 0x73, 0x67, 0x10, 0x18, 0x12, 0x0b,
    0x0a, 0x07, 0x55, 0x4d, 0x5f, 0x54, 0x69, 0x6c, 0x74, 0x10, 0x19, 0x12, 0x0c, 0x0a, 0x08, 0x55,
    0x4d, 0x5f, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x10, 0x1a, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4d, 0x5f,
    0x56, 0x47, 0x55, 0x49, 0x4d, 0x65, 0x6e, 0x75, 0x10, 0x1b, 0x12, 0x10, 0x0a, 0x0c, 0x55, 0x4d,
    0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x4d, 0x61, 0x73, 0x6b, 0x10, 0x1c, 0x12, 0x14, 0x0a, 0x10,
    0x55, 0x4d, 0x5f, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x53, 0x75, 0x62, 0x74, 0x69, 0x74, 0x6c, 0x65,
    0x10, 0x1d, 0x12, 0x10, 0x0a, 0x0c, 0x55, 0x4d, 0x5f, 0x53, 0x65, 0x6e, 0x64, 0x41, 0x75, 0x64,
    0x69, 0x6f, 0x10, 0x1e, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4d, 0x5f, 0x4d, 0x41, 0x58, 0x5f, 0x42,
    0x41, 0x53, 0x45, 0x10, 0x3f, 0x42, 0x05, 0x48, 0x01, 0x80, 0x01, 0x00, 0x4a, 0x97, 0x3e, 0x0a,
    0x07, 0x12, 0x05, 0x1e, 0x00, 0xab, 0x02, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x1e,
    0x00, 0x1c, 0x0a, 0x37, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x1e, 0x00, 0x1c, 0x1a,
    0x2a, 0x20, 0x57, 0x65, 0x20, 0x63, 0x61, 0x72, 0x65, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x61,
    0x62, 0x6f, 0x75, 0x74, 0x20, 0x73, 0x70, 0x65, 0x65, 0x64, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20,
    0x63, 0x6f, 0x64, 0x65, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x08,
    0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x1e, 0x07, 0x13, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x00, 0x12, 0x03, 0x1e, 0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x1e, 0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00,
    0x03, 0x12, 0x03, 0x1e, 0x16, 0x1b, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x21, 0x00, 0x23,
    0x0a, 0x41, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x01, 0x12, 0x03, 0x21, 0x00, 0x23, 0x1a, 0x34, 0x20,
    0x57, 0x65, 0x20, 0x64, 0x6f, 0x6e, 0x27, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x69, 0x74,
    0x79, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x03, 0x21, 0x07,
    0x1a, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x03, 0x21, 0x07, 0x1a,
    0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x21, 0x07, 0x1a,
    0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x03, 0x12, 0x03, 0x21, 0x1d, 0x22, 0x0a, 0x09,
    0x0a, 0x02, 0x03, 0x00, 0x12, 0x03, 0x3a, 0x07, 0x29, 0x0a, 0x22, 0x0a, 0x02, 0x03, 0x01, 0x12,
    0x03, 0x3d, 0x07, 0x1a, 0x1a, 0x17, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x43, 0x4d, 0x73, 0x67, 0x56,
    0x65, 0x63, 0x74, 0x6f, 0x72, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0d, 0x0a, 0x0a, 0x0a, 0x0a,
    0x02, 0x05, 0x00, 0x12, 0x04, 0x43, 0x00, 0x66, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01,
    0x12, 0x03, 0x43, 0x05, 0x16, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x45,
    0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x45, 0x08, 0x1b,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x45, 0x22, 0x23, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x01, 0x12, 0x03, 0x46, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x46, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x01, 0x02, 0x12, 0x03, 0x46, 0x22, 0x23, 0x0a, 0x38, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12,
    0x03, 0x47, 0x08, 0x24, 0x22, 0x2b, 0x20, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65, 0x66, 0x20, 0x43, 0x55, 0x73, 0x65, 0x72, 0x4d,
    0x73, 0x67, 0x5f, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x61, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0d,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x47, 0x08, 0x1d, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x02, 0x12, 0x03, 0x47, 0x22, 0x23, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x00, 0x02, 0x03, 0x12, 0x03, 0x48, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x03, 0x01, 0x12, 0x03, 0x48, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03,
    0x02, 0x12, 0x03, 0x48, 0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x04, 0x12, 0x03,
    0x49, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x49, 0x08,
    0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x49, 0x22, 0x23, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x05, 0x12, 0x03, 0x4a, 0x08, 0x34, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x05, 0x01, 0x12, 0x03, 0x4a, 0x08, 0x0f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x05, 0x02, 0x12, 0x03, 0x4a, 0x32, 0x33, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x06,
    0x12, 0x03, 0x4b, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03,
    0x4b, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x4b, 0x2a,
    0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x07, 0x12, 0x03, 0x4c, 0x08, 0x2c, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x07, 0x01, 0x12, 0x03, 0x4c, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x07, 0x02, 0x12, 0x03, 0x4c, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00,
    0x02, 0x08, 0x12, 0x03, 0x4d, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x01,
    0x12, 0x03, 0x4d, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x02, 0x12, 0x03,
    0x4d, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x09, 0x12, 0x03, 0x4e, 0x08, 0x2d,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x09, 0x01, 0x12, 0x03, 0x4e, 0x08, 0x11, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x09, 0x02, 0x12, 0x03, 0x4e, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x0a, 0x12, 0x03, 0x4f, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x0a, 0x01, 0x12, 0x03, 0x4f, 0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0a, 0x02,
    0x12, 0x03, 0x4f, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0b, 0x12, 0x03, 0x50,
    0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x03, 0x50, 0x08, 0x16,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0b, 0x02, 0x12, 0x03, 0x50, 0x22, 0x24, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x0c, 0x12, 0x03, 0x51, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x0c, 0x01, 0x12, 0x03, 0x51, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x0c, 0x02, 0x12, 0x03, 0x51, 0x22, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0d, 0x12,
    0x03, 0x52, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x03, 0x52,
    0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0d, 0x02, 0x12, 0x03, 0x52, 0x22, 0x24,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0e, 0x12, 0x03, 0x53, 0x08, 0x2d, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x0e, 0x01, 0x12, 0x03, 0x53, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x0e, 0x02, 0x12, 0x03, 0x53, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02,
    0x0f, 0x12, 0x03, 0x54, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0f, 0x01, 0x12,
    0x03, 0x54, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0f, 0x02, 0x12, 0x03, 0x54,
    0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x10, 0x12, 0x03, 0x55, 0x08, 0x2d, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x10, 0x01, 0x12, 0x03, 0x55, 0x08, 0x12, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x10, 0x02, 0x12, 0x03, 0x55, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x00, 0x02, 0x11, 0x12, 0x03, 0x56, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x11,
    0x01, 0x12, 0x03, 0x56, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x11, 0x02, 0x12,
    0x03, 0x56, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x12, 0x12, 0x03, 0x57, 0x08,
    0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x12, 0x01, 0x12, 0x03, 0x57, 0x08, 0x19, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x12, 0x02, 0x12, 0x03, 0x57, 0x22, 0x24, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x00, 0x02, 0x13, 0x12, 0x03, 0x58, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x13, 0x01, 0x12, 0x03, 0x58, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x13,
    0x02, 0x12, 0x03, 0x58, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x14, 0x12, 0x03,
    0x59, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x14, 0x01, 0x12, 0x03, 0x59, 0x08,
    0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x14, 0x02, 0x12, 0x03, 0x59, 0x2a, 0x2c, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x15, 0x12, 0x03, 0x5a, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x15, 0x01, 0x12, 0x03, 0x5a, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x15, 0x02, 0x12, 0x03, 0x5a, 0x22, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x16,
    0x12, 0x03, 0x5b, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x16, 0x01, 0x12, 0x03,
    0x5b, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x16, 0x02, 0x12, 0x03, 0x5b, 0x22,
    0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x17, 0x12, 0x03, 0x5c, 0x08, 0x2d, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x17, 0x01, 0x12, 0x03, 0x5c, 0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x17, 0x02, 0x12, 0x03, 0x5c, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00,
    0x02, 0x18, 0x12, 0x03, 0x5d, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x18, 0x01,
    0x12, 0x03, 0x5d, 0x08, 0x0f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x18, 0x02, 0x12, 0x03,
    0x5d, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x19, 0x12, 0x03, 0x5e, 0x08, 0x2d,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x19, 0x01, 0x12, 0x03, 0x5e, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x19, 0x02, 0x12, 0x03, 0x5e, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x1a, 0x12, 0x03, 0x5f, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x1a, 0x01, 0x12, 0x03, 0x5f, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1a, 0x02,
    0x12, 0x03, 0x5f, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x1b, 0x12, 0x03, 0x60,
    0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1b, 0x01, 0x12, 0x03, 0x60, 0x08, 0x14,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1b, 0x02, 0x12, 0x03, 0x60, 0x2a, 0x2c, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x1c, 0x12, 0x03, 0x61, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x1c, 0x01, 0x12, 0x03, 0x61, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x1c, 0x02, 0x12, 0x03, 0x61, 0x22, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x1d, 0x12,
    0x03, 0x62, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1d, 0x01, 0x12, 0x03, 0x62,
    0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1d, 0x02, 0x12, 0x03, 0x62, 0x2a, 0x2c,
    0x0a, 0x43, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x1e, 0x12, 0x03, 0x65, 0x08, 0x29, 0x1a, 0x36, 0x20,
    0x47, 0x61, 0x6d, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75,
    0x6c, 0x64, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1e, 0x01, 0x12, 0x03,
    0x65, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1e, 0x02, 0x12, 0x03, 0x65, 0x26,
    0x28, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04, 0x6a, 0x00, 0x6d, 0x01, 0x0a, 0x0a, 0x0a,
    0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x6a, 0x08, 0x21, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02,
    0x00, 0x12, 0x03, 0x6c, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x03, 0x6c, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x6c,
    0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x6c, 0x18, 0x23,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x6c, 0x26, 0x27, 0x0a, 0x0a,
    0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x6f, 0x00, 0x74, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01,
    0x01, 0x12, 0x03, 0x6f, 0x08, 0x1d, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03,
    0x71, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x71, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x05, 0x12, 0x03, 0x71, 0x11, 0x18, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x71, 0x19, 0x1d, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03, 0x71, 0x20, 0x21, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x01, 0x02, 0x01, 0x12, 0x03, 0x72, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01,
    0x04, 0x12, 0x03, 0x72, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x05, 0x12,
    0x03, 0x72, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x72,
    0x17, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x03, 0x12, 0x03, 0x72, 0x22, 0x23,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x02, 0x12, 0x03, 0x73, 0x08, 0x26, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x02, 0x04, 0x12, 0x03, 0x73, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x02, 0x05, 0x12, 0x03, 0x73, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x02, 0x01, 0x12, 0x03, 0x73, 0x16, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x03,
    0x12, 0x03, 0x73, 0x24, 0x25, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x76, 0x00, 0x79,
    0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x76, 0x08, 0x21, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x03, 0x78, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x00, 0x04, 0x12, 0x03, 0x78, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00,
    0x05, 0x12, 0x03, 0x78, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12,
    0x03, 0x78, 0x17, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x03, 0x78,
    0x21, 0x22, 0x0a, 0x0b, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x05, 0x7b, 0x00, 0x81, 0x01, 0x01, 0x0a,
    0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x03, 0x7b, 0x08, 0x21, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x03, 0x02, 0x00, 0x12, 0x03, 0x7d, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00,
    0x04, 0x12, 0x03, 0x7d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x05, 0x12,
    0x03, 0x7d, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x03, 0x7d,
    0x17, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x03, 0x7d, 0x21, 0x22,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x01, 0x12, 0x03, 0x7e, 0x08, 0x24, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x01, 0x04, 0x12, 0x03, 0x7e, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x01, 0x05, 0x12, 0x03, 0x7e, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x01, 0x01, 0x12, 0x03, 0x7e, 0x17, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x03,
    0x12, 0x03, 0x7e, 0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x02, 0x12, 0x03, 0x7f,
    0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x04, 0x12, 0x03, 0x7f, 0x08, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x05, 0x12, 0x03, 0x7f, 0x11, 0x17, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x01, 0x12, 0x03, 0x7f, 0x18, 0x24, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x02, 0x03, 0x12, 0x03, 0x7f, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03,
    0x02, 0x03, 0x12, 0x04, 0x80, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03,
    0x04, 0x12, 0x04, 0x80, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x05,
    0x12, 0x04, 0x80, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x01, 0x12,
    0x04, 0x80, 0x01, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x03, 0x12, 0x04,
    0x80, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x06, 0x83, 0x01, 0x00, 0x89,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x04, 0x01, 0x12, 0x04, 0x83, 0x01, 0x08, 0x15, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x00, 0x12, 0x04, 0x85, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12, 0x04, 0x85, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x00, 0x05, 0x12, 0x04, 0x85, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x01, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x04, 0x02,
    0x01, 0x12, 0x04, 0x86, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x86, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x05, 0x12,
    0x04, 0x86, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x86, 0x01, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0x86,
    0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x02, 0x12, 0x04, 0x87, 0x01, 0x08,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x04, 0x12, 0x04, 0x87, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x05, 0x12, 0x04, 0x87, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x04, 0x87, 0x01, 0x18, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x03, 0x12, 0x04, 0x87, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x04, 0x02, 0x03, 0x12, 0x04, 0x88, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x03, 0x04, 0x12, 0x04, 0x88, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x03, 0x05, 0x12, 0x04, 0x88, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x03, 0x01, 0x12, 0x04, 0x88, 0x01, 0x19, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x03,
    0x03, 0x12, 0x04, 0x88, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x06, 0x8b,
    0x01, 0x00, 0x91, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x04, 0x8b, 0x01,
    0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x04, 0x8d, 0x01, 0x08, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8d, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8d, 0x01, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8d, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8d, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x8e, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x01, 0x05, 0x12, 0x04, 0x8e, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01,
    0x01, 0x12, 0x04, 0x8e, 0x01, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x03,
    0x12, 0x04, 0x8e, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x02, 0x12, 0x04,
    0x8f, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8f,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8f, 0x01,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8f, 0x01, 0x17,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8f, 0x01, 0x23, 0x24,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x03, 0x12, 0x04, 0x90, 0x01, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x04, 0x12, 0x04, 0x90, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x03, 0x05, 0x12, 0x04, 0x90, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x03, 0x01, 0x12, 0x04, 0x90, 0x01, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x03, 0x03, 0x12, 0x04, 0x90, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x06,
    0x12, 0x06, 0x93, 0x01, 0x00, 0x97, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12,
    0x04, 0x93, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x04, 0x95,
    0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04, 0x95, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x06, 0x12, 0x04, 0x95, 0x01, 0x11,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0x95, 0x01, 0x20, 0x25,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0x95, 0x01, 0x28, 0x29, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x01, 0x12, 0x04, 0x96, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x01, 0x04, 0x12, 0x04, 0x96, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x01, 0x06, 0x12, 0x04, 0x96, 0x01, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x01, 0x01, 0x12, 0x04, 0x96, 0x01, 0x1c, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x01, 0x03, 0x12, 0x04, 0x96, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x07, 0x12,
    0x06, 0x99, 0x01, 0x00, 0xa0, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x04,
    0x99, 0x01, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x04, 0x9b, 0x01,
    0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9b, 0x01, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9b, 0x01, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9b, 0x01, 0x18, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9b, 0x01, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x07, 0x02, 0x01, 0x12, 0x04, 0x9c, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x07, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9c, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9c, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x9c, 0x01, 0x16, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x9c, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x02,
    0x12, 0x04, 0x9d, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x9d, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x06, 0x12, 0x04,
    0x9d, 0x01, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9d,
    0x01, 0x1c, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x03, 0x12, 0x04, 0x9d, 0x01,
    0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x03, 0x12, 0x04, 0x9e, 0x01, 0x08, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x04, 0x12, 0x04, 0x9e, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x05, 0x12, 0x04, 0x9e, 0x01, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9e, 0x01, 0x17, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9e, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x07, 0x02, 0x04, 0x12, 0x04, 0x9f, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x04, 0x04, 0x12, 0x04, 0x9f, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x04, 0x05, 0x12, 0x04, 0x9f, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x04,
    0x01, 0x12, 0x04, 0x9f, 0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x04, 0x03,
    0x12, 0x04, 0x9f, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0xa2, 0x01,
    0x00, 0xa7, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x04, 0xa2, 0x01, 0x08,
    0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x00, 0x12, 0x04, 0xa4, 0x01, 0x08, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa4, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa4, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa4, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x08, 0x02, 0x01, 0x12, 0x04, 0xa5, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xa5, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xa5, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xa5, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xa5, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x02, 0x12, 0x04, 0xa6,
    0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa6, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa6, 0x01, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa6, 0x01, 0x16, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa6, 0x01, 0x1d, 0x1e, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0xa9, 0x01, 0x00, 0xb1, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x09, 0x01, 0x12, 0x04, 0xa9, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09,
    0x02, 0x00, 0x12, 0x04, 0xab, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xab, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xab, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xab, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xab, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x01, 0x12, 0x04, 0xac, 0x01,
    0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x04, 0x12, 0x04, 0xac, 0x01, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x05, 0x12, 0x04, 0xac, 0x01, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x01, 0x12, 0x04, 0xac, 0x01, 0x16, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04, 0xac, 0x01, 0x1d, 0x1e, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x09, 0x02, 0x02, 0x12, 0x04, 0xad, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x02, 0x04, 0x12, 0x04, 0xad, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x02, 0x05, 0x12, 0x04, 0xad, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xad, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xad, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x03,
    0x12, 0x04, 0xae, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xae, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xae, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x01, 0x12, 0x04, 0xae,
    0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x03, 0x12, 0x04, 0xae, 0x01,
    0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x04, 0x12, 0x04, 0xaf, 0x01, 0x08, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x04, 0x12, 0x04, 0xaf, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x05, 0x12, 0x04, 0xaf, 0x01, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x01, 0x12, 0x04, 0xaf, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x04, 0x03, 0x12, 0x04, 0xaf, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x09, 0x02, 0x05, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x05, 0x05, 0x12, 0x04, 0xb0, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x05,
    0x01, 0x12, 0x04, 0xb0, 0x01, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xb0, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0xb3, 0x01,
    0x00, 0xc0, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0xb3, 0x01, 0x08,
    0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x04, 0xb5, 0x01, 0x08, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb5, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb5, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb5, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0a, 0x02, 0x01, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xb6, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xb6, 0x01, 0x17, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xb6, 0x01, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x02, 0x12, 0x04, 0xb7,
    0x01, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb7, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb7, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb7, 0x01, 0x17, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb7, 0x01, 0x1b, 0x1c, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x03, 0x12, 0x04, 0xb8, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb8, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb8, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xb8, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02,
    0x04, 0x12, 0x04, 0xb9, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xb9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x05, 0x12,
    0x04, 0xb9, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xb9, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb9,
    0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x05, 0x12, 0x04, 0xba, 0x01, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x05, 0x04, 0x12, 0x04, 0xba, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x05, 0x05, 0x12, 0x04, 0xba, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x05, 0x01, 0x12, 0x04, 0xba, 0x01, 0x18, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x05, 0x03, 0x12, 0x04, 0xba, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x0a, 0x02, 0x06, 0x12, 0x04, 0xbb, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x06, 0x04, 0x12, 0x04, 0xbb, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x06, 0x05, 0x12, 0x04, 0xbb, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xbb, 0x01, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x06,
    0x03, 0x12, 0x04, 0xbb, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x07, 0x12,
    0x04, 0xbc, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x07, 0x04, 0x12, 0x04,
    0xbc, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x07, 0x05, 0x12, 0x04, 0xbc,
    0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x07, 0x01, 0x12, 0x04, 0xbc, 0x01,
    0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x07, 0x03, 0x12, 0x04, 0xbc, 0x01, 0x27,
    0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x08, 0x12, 0x04, 0xbd, 0x01, 0x08, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x08, 0x04, 0x12, 0x04, 0xbd, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x08, 0x05, 0x12, 0x04, 0xbd, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x08, 0x01, 0x12, 0x04, 0xbd, 0x01, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x08, 0x03, 0x12, 0x04, 0xbd, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0a, 0x02, 0x09, 0x12, 0x04, 0xbe, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x09, 0x04, 0x12, 0x04, 0xbe, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x09,
    0x05, 0x12, 0x04, 0xbe, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x09, 0x01,
    0x12, 0x04, 0xbe, 0x01, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x09, 0x03, 0x12,
    0x04, 0xbe, 0x01, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x0a, 0x12, 0x04, 0xbf,
    0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xbf, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xbf, 0x01, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x18, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xbf, 0x01, 0x22, 0x24, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06, 0xc2, 0x01, 0x00, 0xc5, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x0b, 0x01, 0x12, 0x04, 0xc2, 0x01, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b,
    0x02, 0x00, 0x12, 0x04, 0xc4, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xc4, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xc4, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xc4, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xc4, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x06, 0xc7, 0x01, 0x00, 0xcb,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0c, 0x01, 0x12, 0x04, 0xc7, 0x01, 0x08, 0x18, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x00, 0x12, 0x04, 0xc9, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc9, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc9, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xc9, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02,
    0x01, 0x12, 0x04, 0xca, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xca, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xca, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xca, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xca,
    0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06, 0xcd, 0x01, 0x00, 0xcf, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0d, 0x01, 0x12, 0x04, 0xcd, 0x01, 0x08, 0x1a, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06, 0xd1, 0x01, 0x00, 0xd3, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x0e, 0x01, 0x12, 0x04, 0xd1, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0f, 0x12,
    0x06, 0xd5, 0x01, 0x00, 0xda, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04,
    0xd5, 0x01, 0x08, 0x1a, 0x0a, 0x39, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x00, 0x12, 0x04, 0xd8, 0x01,
    0x08, 0x1f, 0x1a, 0x2b, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x66, 0x69,
    0x78, 0x65, 0x64, 0x33, 0x32, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x3d, 0x20, 0x31, 0x3b, 0x20,
    0x2f, 0x2f, 0x20, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x68, 0x61, 0x73, 0x68, 0x0d, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd8, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd8, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd8, 0x01, 0x1d, 0x1e, 0x0a, 0x1b, 0x0a, 0x04, 0x04,
    0x0f, 0x02, 0x01, 0x12, 0x04, 0xd9, 0x01, 0x08, 0x21, 0x22, 0x0d, 0x20, 0x73, 0x6f, 0x75, 0x6e,
    0x64, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xd9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xd9, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xd9, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xd9, 0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x10, 0x12, 0x06, 0xdc, 0x01, 0x00, 0xe0,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x10, 0x01, 0x12, 0x04, 0xdc, 0x01, 0x08, 0x1a, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x00, 0x12, 0x04, 0xde, 0x01, 0x08, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x00, 0x04, 0x12, 0x04, 0xde, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x00, 0x05, 0x12, 0x04, 0xde, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0xde, 0x01, 0x17, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xde, 0x01, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02,
    0x01, 0x12, 0x04, 0xdf, 0x01, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xdf, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xdf, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xdf, 0x01, 0x16, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x03, 0x12, 0x04, 0xdf,
    0x01, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0xe2, 0x01, 0x00, 0xe4, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xe2, 0x01, 0x08, 0x1d, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x12, 0x12, 0x06, 0xe6, 0x01, 0x00, 0xe9, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x12, 0x01, 0x12, 0x04, 0xe6, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02,
    0x00, 0x12, 0x04, 0xe8, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xe8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xe8, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xe8, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe8,
    0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x13, 0x12, 0x06, 0xeb, 0x01, 0x00, 0xee, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01, 0x12, 0x04, 0xeb, 0x01, 0x08, 0x1c, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x13, 0x02, 0x00, 0x12, 0x04, 0xed, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x13, 0x02, 0x00, 0x04, 0x12, 0x04, 0xed, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x13, 0x02, 0x00, 0x05, 0x12, 0x04, 0xed, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xed, 0x01, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xed, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x14, 0x12, 0x06,
    0xf0, 0x01, 0x00, 0xf2, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04, 0xf0,
    0x01, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x15, 0x12, 0x06, 0xf4, 0x01, 0x00, 0xf8, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x15, 0x01, 0x12, 0x04, 0xf4, 0x01, 0x08, 0x1f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x15, 0x02, 0x00, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x15, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf6, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xf6, 0x01, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xf6, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x01,
    0x12, 0x04, 0xf7, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xf7, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xf7, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf7,
    0x01, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf7, 0x01,
    0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x16, 0x12, 0x06, 0xfa, 0x01, 0x00, 0xff, 0x01, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xfa, 0x01, 0x08, 0x1e, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x16, 0x02, 0x00, 0x12, 0x04, 0xfc, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfc, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xfc, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xfc, 0x01, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xfc, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x01, 0x12,
    0x04, 0xfd, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xfd, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x05, 0x12, 0x04, 0xfd,
    0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfd, 0x01,
    0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x03, 0x12, 0x04, 0xfd, 0x01, 0x1e,
    0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x02, 0x12, 0x04, 0xfe, 0x01, 0x08, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x04, 0x12, 0x04, 0xfe, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x05, 0x12, 0x04, 0xfe, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x02, 0x01, 0x12, 0x04, 0xfe, 0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x02, 0x03, 0x12, 0x04, 0xfe, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x17, 0x12, 0x06, 0x81, 0x02, 0x00, 0x8d, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01,
    0x12, 0x04, 0x81, 0x02, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x00, 0x12, 0x04,
    0x83, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x04, 0x12, 0x04, 0x83,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x05, 0x12, 0x04, 0x83, 0x02,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x01, 0x12, 0x04, 0x83, 0x02, 0x18,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x03, 0x12, 0x04, 0x83, 0x02, 0x1f, 0x20,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x01, 0x12, 0x04, 0x84, 0x02, 0x08, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x04, 0x12, 0x04, 0x84, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x01, 0x05, 0x12, 0x04, 0x84, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x01, 0x01, 0x12, 0x04, 0x84, 0x02, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x01, 0x03, 0x12, 0x04, 0x84, 0x02, 0x1d, 0x1e, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x17,
    0x03, 0x00, 0x12, 0x06, 0x86, 0x02, 0x08, 0x8a, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x03, 0x00, 0x01, 0x12, 0x04, 0x86, 0x02, 0x10, 0x14, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x04, 0x88, 0x02, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x88, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x88, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x88, 0x02, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x88, 0x02, 0x27, 0x28, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x89, 0x02, 0x10, 0x2a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x89, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x89, 0x02, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x89, 0x02, 0x20, 0x25,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x89, 0x02, 0x28,
    0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x02, 0x12, 0x04, 0x8c, 0x02, 0x08, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8c, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x06, 0x12, 0x04, 0x8c, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8c, 0x02, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8c, 0x02, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x18, 0x12, 0x06, 0x8f, 0x02, 0x00, 0x92, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01,
    0x12, 0x04, 0x8f, 0x02, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04,
    0x91, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04, 0x91,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0x91, 0x02,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x01, 0x12, 0x04, 0x91, 0x02, 0x17,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x03, 0x12, 0x04, 0x91, 0x02, 0x1f, 0x20,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06, 0x94, 0x02, 0x00, 0x99, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x19, 0x01, 0x12, 0x04, 0x94, 0x02, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x19, 0x02, 0x00, 0x12, 0x04, 0x96, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x96, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x96, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x96, 0x02, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x96, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x01, 0x12, 0x04, 0x97,
    0x02, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x04, 0x12, 0x04, 0x97, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x05, 0x12, 0x04, 0x97, 0x02, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x01, 0x12, 0x04, 0x97, 0x02, 0x17, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x03, 0x12, 0x04, 0x97, 0x02, 0x1e, 0x1f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x02, 0x12, 0x04, 0x98, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x02, 0x04, 0x12, 0x04, 0x98, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x02, 0x05, 0x12, 0x04, 0x98, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x02, 0x01, 0x12, 0x04, 0x98, 0x02, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x02, 0x03, 0x12, 0x04, 0x98, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1a, 0x12,
    0x06, 0x9b, 0x02, 0x00, 0x9e, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1a, 0x01, 0x12, 0x04,
    0x9b, 0x02, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x00, 0x12, 0x04, 0x9d, 0x02,
    0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9d, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9d, 0x02, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9d, 0x02, 0x17, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9d, 0x02, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x1b, 0x12, 0x06, 0xa0, 0x02, 0x00, 0xa5, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x1b, 0x01, 0x12, 0x04, 0xa0, 0x02, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02,
    0x00, 0x12, 0x04, 0xa2, 0x02, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xa2, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xa2, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xa2, 0x02, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa2,
    0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x02, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa3, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa3, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x02, 0x17, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa3, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1b, 0x02, 0x02, 0x12, 0x04, 0xa4, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1b, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa4, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xa4, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xa4, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06, 0xa7,
    0x02, 0x00, 0xab, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1c, 0x01, 0x12, 0x04, 0xa7, 0x02,
    0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x00, 0x12, 0x04, 0xa9, 0x02, 0x08, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa9, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa9, 0x02, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa9, 0x02, 0x18, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa9, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1c, 0x02, 0x01, 0x12, 0x04, 0xaa, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xaa, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xaa, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xaa, 0x02, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xaa, 0x02, 0x1f, 0x20,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto };

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data)
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_AchievementEvent {
    achievement: Option<u32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_AchievementEvent {
    pub fn new() -> CUserMsg_AchievementEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_AchievementEvent {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_AchievementEvent> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_AchievementEvent };
        unsafe {
            instance.get(|| {
                CUserMsg_AchievementEvent {
                    achievement: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: u32) {
        self.achievement = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement(&'a mut self) -> &'a mut u32 {
        if self.achievement.is_none() {
            self.achievement = Some(0);
        };
        self.achievement.as_mut().unwrap()
    }

    pub fn get_achievement(&self) -> u32 {
        self.achievement.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CUserMsg_AchievementEvent {
    fn new() -> CUserMsg_AchievementEvent {
        CUserMsg_AchievementEvent::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.achievement = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.achievement.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.achievement {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_AchievementEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_AchievementEvent>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_AchievementEvent_achievement_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_AchievementEvent>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_AchievementEvent>(
                    "CUserMsg_AchievementEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_AchievementEvent>()
    }
}

impl ::protobuf::Clear for CUserMsg_AchievementEvent {
    fn clear(&mut self) {
        self.clear_achievement();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_AchievementEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_AchievementEvent_achievement_acc_type;
static CUserMsg_AchievementEvent_achievement_acc: CUserMsg_AchievementEvent_achievement_acc_type = CUserMsg_AchievementEvent_achievement_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_AchievementEvent> for CUserMsg_AchievementEvent_achievement_acc_type {
    fn name(&self) -> &'static str {
        "achievement"
    }

    fn has_field(&self, m: &CUserMsg_AchievementEvent) -> bool {
        m.has_achievement()
    }

    fn get_u32(&self, m: &CUserMsg_AchievementEvent) -> u32 {
        m.get_achievement()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_CloseCaption {
    hash: Option<u32>,
    duration: Option<f32>,
    from_player: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_CloseCaption {
    pub fn new() -> CUserMsg_CloseCaption {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_CloseCaption {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_CloseCaption> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_CloseCaption };
        unsafe {
            instance.get(|| {
                CUserMsg_CloseCaption {
                    hash: None,
                    duration: None,
                    from_player: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_hash(&mut self) {
        self.hash = None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&'a mut self) -> &'a mut u32 {
        if self.hash.is_none() {
            self.hash = Some(0);
        };
        self.hash.as_mut().unwrap()
    }

    pub fn get_hash(&self) -> u32 {
        self.hash.unwrap_or_else(|| 0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut f32 {
        if self.duration.is_none() {
            self.duration = Some(0.);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or_else(|| 0.)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_player(&'a mut self) -> &'a mut bool {
        if self.from_player.is_none() {
            self.from_player = Some(false);
        };
        self.from_player.as_mut().unwrap()
    }

    pub fn get_from_player(&self) -> bool {
        self.from_player.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CUserMsg_CloseCaption {
    fn new() -> CUserMsg_CloseCaption {
        CUserMsg_CloseCaption::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.hash = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.duration = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.from_player = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.hash.is_some() {
            my_size += 5;
        };
        if self.duration.is_some() {
            my_size += 5;
        };
        if self.from_player.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.hash {
            Some(ref v) => {
                os.write_fixed32(1, *v);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        match self.from_player {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_CloseCaption>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_CloseCaption>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_CloseCaption_hash_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_CloseCaption>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_CloseCaption_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_CloseCaption>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_CloseCaption_from_player_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_CloseCaption>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_CloseCaption>(
                    "CUserMsg_CloseCaption",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_CloseCaption>()
    }
}

impl ::protobuf::Clear for CUserMsg_CloseCaption {
    fn clear(&mut self) {
        self.clear_hash();
        self.clear_duration();
        self.clear_from_player();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_CloseCaption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_CloseCaption_hash_acc_type;
static CUserMsg_CloseCaption_hash_acc: CUserMsg_CloseCaption_hash_acc_type = CUserMsg_CloseCaption_hash_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_CloseCaption> for CUserMsg_CloseCaption_hash_acc_type {
    fn name(&self) -> &'static str {
        "hash"
    }

    fn has_field(&self, m: &CUserMsg_CloseCaption) -> bool {
        m.has_hash()
    }

    fn get_u32(&self, m: &CUserMsg_CloseCaption) -> u32 {
        m.get_hash()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_CloseCaption_duration_acc_type;
static CUserMsg_CloseCaption_duration_acc: CUserMsg_CloseCaption_duration_acc_type = CUserMsg_CloseCaption_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_CloseCaption> for CUserMsg_CloseCaption_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CUserMsg_CloseCaption) -> bool {
        m.has_duration()
    }

    fn get_f32(&self, m: &CUserMsg_CloseCaption) -> f32 {
        m.get_duration()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_CloseCaption_from_player_acc_type;
static CUserMsg_CloseCaption_from_player_acc: CUserMsg_CloseCaption_from_player_acc_type = CUserMsg_CloseCaption_from_player_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_CloseCaption> for CUserMsg_CloseCaption_from_player_acc_type {
    fn name(&self) -> &'static str {
        "from_player"
    }

    fn has_field(&self, m: &CUserMsg_CloseCaption) -> bool {
        m.has_from_player()
    }

    fn get_bool(&self, m: &CUserMsg_CloseCaption) -> bool {
        m.get_from_player()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_CurrentTimescale {
    current: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_CurrentTimescale {
    pub fn new() -> CUserMsg_CurrentTimescale {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_CurrentTimescale {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_CurrentTimescale> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_CurrentTimescale };
        unsafe {
            instance.get(|| {
                CUserMsg_CurrentTimescale {
                    current: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_current(&mut self) {
        self.current = None;
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: f32) {
        self.current = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current(&'a mut self) -> &'a mut f32 {
        if self.current.is_none() {
            self.current = Some(0.);
        };
        self.current.as_mut().unwrap()
    }

    pub fn get_current(&self) -> f32 {
        self.current.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CUserMsg_CurrentTimescale {
    fn new() -> CUserMsg_CurrentTimescale {
        CUserMsg_CurrentTimescale::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.current = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.current.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.current {
            Some(ref v) => {
                os.write_float(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_CurrentTimescale>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_CurrentTimescale>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_CurrentTimescale_current_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_CurrentTimescale>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_CurrentTimescale>(
                    "CUserMsg_CurrentTimescale",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_CurrentTimescale>()
    }
}

impl ::protobuf::Clear for CUserMsg_CurrentTimescale {
    fn clear(&mut self) {
        self.clear_current();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_CurrentTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_CurrentTimescale_current_acc_type;
static CUserMsg_CurrentTimescale_current_acc: CUserMsg_CurrentTimescale_current_acc_type = CUserMsg_CurrentTimescale_current_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_CurrentTimescale> for CUserMsg_CurrentTimescale_current_acc_type {
    fn name(&self) -> &'static str {
        "current"
    }

    fn has_field(&self, m: &CUserMsg_CurrentTimescale) -> bool {
        m.has_current()
    }

    fn get_f32(&self, m: &CUserMsg_CurrentTimescale) -> f32 {
        m.get_current()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_DesiredTimescale {
    desired: Option<f32>,
    duration: Option<f32>,
    interpolator: Option<u32>,
    start_blend_time: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_DesiredTimescale {
    pub fn new() -> CUserMsg_DesiredTimescale {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_DesiredTimescale {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_DesiredTimescale> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_DesiredTimescale };
        unsafe {
            instance.get(|| {
                CUserMsg_DesiredTimescale {
                    desired: None,
                    duration: None,
                    interpolator: None,
                    start_blend_time: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_desired(&mut self) {
        self.desired = None;
    }

    pub fn has_desired(&self) -> bool {
        self.desired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired(&mut self, v: f32) {
        self.desired = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired(&'a mut self) -> &'a mut f32 {
        if self.desired.is_none() {
            self.desired = Some(0.);
        };
        self.desired.as_mut().unwrap()
    }

    pub fn get_desired(&self) -> f32 {
        self.desired.unwrap_or_else(|| 0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut f32 {
        if self.duration.is_none() {
            self.duration = Some(0.);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or_else(|| 0.)
    }

    pub fn clear_interpolator(&mut self) {
        self.interpolator = None;
    }

    pub fn has_interpolator(&self) -> bool {
        self.interpolator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpolator(&mut self, v: u32) {
        self.interpolator = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interpolator(&'a mut self) -> &'a mut u32 {
        if self.interpolator.is_none() {
            self.interpolator = Some(0);
        };
        self.interpolator.as_mut().unwrap()
    }

    pub fn get_interpolator(&self) -> u32 {
        self.interpolator.unwrap_or_else(|| 0)
    }

    pub fn clear_start_blend_time(&mut self) {
        self.start_blend_time = None;
    }

    pub fn has_start_blend_time(&self) -> bool {
        self.start_blend_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_blend_time(&mut self, v: f32) {
        self.start_blend_time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_blend_time(&'a mut self) -> &'a mut f32 {
        if self.start_blend_time.is_none() {
            self.start_blend_time = Some(0.);
        };
        self.start_blend_time.as_mut().unwrap()
    }

    pub fn get_start_blend_time(&self) -> f32 {
        self.start_blend_time.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CUserMsg_DesiredTimescale {
    fn new() -> CUserMsg_DesiredTimescale {
        CUserMsg_DesiredTimescale::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.desired = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.duration = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.interpolator = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.start_blend_time = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.desired.is_some() {
            my_size += 5;
        };
        if self.duration.is_some() {
            my_size += 5;
        };
        for value in self.interpolator.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.start_blend_time.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.desired {
            Some(ref v) => {
                os.write_float(1, *v);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        match self.interpolator {
            Some(ref v) => {
                os.write_uint32(3, *v);
            },
            None => {},
        };
        match self.start_blend_time {
            Some(ref v) => {
                os.write_float(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_DesiredTimescale>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_DesiredTimescale_desired_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_DesiredTimescale_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_DesiredTimescale_interpolator_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_DesiredTimescale_start_blend_time_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_DesiredTimescale>(
                    "CUserMsg_DesiredTimescale",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_DesiredTimescale>()
    }
}

impl ::protobuf::Clear for CUserMsg_DesiredTimescale {
    fn clear(&mut self) {
        self.clear_desired();
        self.clear_duration();
        self.clear_interpolator();
        self.clear_start_blend_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_DesiredTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_DesiredTimescale_desired_acc_type;
static CUserMsg_DesiredTimescale_desired_acc: CUserMsg_DesiredTimescale_desired_acc_type = CUserMsg_DesiredTimescale_desired_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale> for CUserMsg_DesiredTimescale_desired_acc_type {
    fn name(&self) -> &'static str {
        "desired"
    }

    fn has_field(&self, m: &CUserMsg_DesiredTimescale) -> bool {
        m.has_desired()
    }

    fn get_f32(&self, m: &CUserMsg_DesiredTimescale) -> f32 {
        m.get_desired()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_DesiredTimescale_duration_acc_type;
static CUserMsg_DesiredTimescale_duration_acc: CUserMsg_DesiredTimescale_duration_acc_type = CUserMsg_DesiredTimescale_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale> for CUserMsg_DesiredTimescale_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CUserMsg_DesiredTimescale) -> bool {
        m.has_duration()
    }

    fn get_f32(&self, m: &CUserMsg_DesiredTimescale) -> f32 {
        m.get_duration()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_DesiredTimescale_interpolator_acc_type;
static CUserMsg_DesiredTimescale_interpolator_acc: CUserMsg_DesiredTimescale_interpolator_acc_type = CUserMsg_DesiredTimescale_interpolator_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale> for CUserMsg_DesiredTimescale_interpolator_acc_type {
    fn name(&self) -> &'static str {
        "interpolator"
    }

    fn has_field(&self, m: &CUserMsg_DesiredTimescale) -> bool {
        m.has_interpolator()
    }

    fn get_u32(&self, m: &CUserMsg_DesiredTimescale) -> u32 {
        m.get_interpolator()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_DesiredTimescale_start_blend_time_acc_type;
static CUserMsg_DesiredTimescale_start_blend_time_acc: CUserMsg_DesiredTimescale_start_blend_time_acc_type = CUserMsg_DesiredTimescale_start_blend_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_DesiredTimescale> for CUserMsg_DesiredTimescale_start_blend_time_acc_type {
    fn name(&self) -> &'static str {
        "start_blend_time"
    }

    fn has_field(&self, m: &CUserMsg_DesiredTimescale) -> bool {
        m.has_start_blend_time()
    }

    fn get_f32(&self, m: &CUserMsg_DesiredTimescale) -> f32 {
        m.get_start_blend_time()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_Fade {
    duration: Option<u32>,
    hold_time: Option<u32>,
    flags: Option<u32>,
    color: Option<u32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_Fade {
    pub fn new() -> CUserMsg_Fade {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_Fade {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_Fade> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_Fade };
        unsafe {
            instance.get(|| {
                CUserMsg_Fade {
                    duration: None,
                    hold_time: None,
                    flags: None,
                    color: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut u32 {
        if self.duration.is_none() {
            self.duration = Some(0);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> u32 {
        self.duration.unwrap_or_else(|| 0)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: u32) {
        self.hold_time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hold_time(&'a mut self) -> &'a mut u32 {
        if self.hold_time.is_none() {
            self.hold_time = Some(0);
        };
        self.hold_time.as_mut().unwrap()
    }

    pub fn get_hold_time(&self) -> u32 {
        self.hold_time.unwrap_or_else(|| 0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&'a mut self) -> &'a mut u32 {
        if self.flags.is_none() {
            self.flags = Some(0);
        };
        self.flags.as_mut().unwrap()
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or_else(|| 0)
    }

    pub fn clear_color(&mut self) {
        self.color = None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&'a mut self) -> &'a mut u32 {
        if self.color.is_none() {
            self.color = Some(0);
        };
        self.color.as_mut().unwrap()
    }

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CUserMsg_Fade {
    fn new() -> CUserMsg_Fade {
        CUserMsg_Fade::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.duration = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.hold_time = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.flags = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_fixed32();
                    self.color = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.duration.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.hold_time.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.flags.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.color.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.duration {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.hold_time {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.flags {
            Some(ref v) => {
                os.write_uint32(3, *v);
            },
            None => {},
        };
        match self.color {
            Some(ref v) => {
                os.write_fixed32(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_Fade>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_Fade>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Fade_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Fade>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Fade_hold_time_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Fade>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Fade_flags_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Fade>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Fade_color_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Fade>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_Fade>(
                    "CUserMsg_Fade",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_Fade>()
    }
}

impl ::protobuf::Clear for CUserMsg_Fade {
    fn clear(&mut self) {
        self.clear_duration();
        self.clear_hold_time();
        self.clear_flags();
        self.clear_color();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_Fade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_Fade_duration_acc_type;
static CUserMsg_Fade_duration_acc: CUserMsg_Fade_duration_acc_type = CUserMsg_Fade_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Fade> for CUserMsg_Fade_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CUserMsg_Fade) -> bool {
        m.has_duration()
    }

    fn get_u32(&self, m: &CUserMsg_Fade) -> u32 {
        m.get_duration()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Fade_hold_time_acc_type;
static CUserMsg_Fade_hold_time_acc: CUserMsg_Fade_hold_time_acc_type = CUserMsg_Fade_hold_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Fade> for CUserMsg_Fade_hold_time_acc_type {
    fn name(&self) -> &'static str {
        "hold_time"
    }

    fn has_field(&self, m: &CUserMsg_Fade) -> bool {
        m.has_hold_time()
    }

    fn get_u32(&self, m: &CUserMsg_Fade) -> u32 {
        m.get_hold_time()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Fade_flags_acc_type;
static CUserMsg_Fade_flags_acc: CUserMsg_Fade_flags_acc_type = CUserMsg_Fade_flags_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Fade> for CUserMsg_Fade_flags_acc_type {
    fn name(&self) -> &'static str {
        "flags"
    }

    fn has_field(&self, m: &CUserMsg_Fade) -> bool {
        m.has_flags()
    }

    fn get_u32(&self, m: &CUserMsg_Fade) -> u32 {
        m.get_flags()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Fade_color_acc_type;
static CUserMsg_Fade_color_acc: CUserMsg_Fade_color_acc_type = CUserMsg_Fade_color_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Fade> for CUserMsg_Fade_color_acc_type {
    fn name(&self) -> &'static str {
        "color"
    }

    fn has_field(&self, m: &CUserMsg_Fade) -> bool {
        m.has_color()
    }

    fn get_u32(&self, m: &CUserMsg_Fade) -> u32 {
        m.get_color()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_Shake {
    command: Option<u32>,
    amplitude: Option<f32>,
    frequency: Option<f32>,
    duration: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_Shake {
    pub fn new() -> CUserMsg_Shake {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_Shake {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_Shake> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_Shake };
        unsafe {
            instance.get(|| {
                CUserMsg_Shake {
                    command: None,
                    amplitude: None,
                    frequency: None,
                    duration: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_command(&mut self) {
        self.command = None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&'a mut self) -> &'a mut u32 {
        if self.command.is_none() {
            self.command = Some(0);
        };
        self.command.as_mut().unwrap()
    }

    pub fn get_command(&self) -> u32 {
        self.command.unwrap_or_else(|| 0)
    }

    pub fn clear_amplitude(&mut self) {
        self.amplitude = None;
    }

    pub fn has_amplitude(&self) -> bool {
        self.amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amplitude(&mut self, v: f32) {
        self.amplitude = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amplitude(&'a mut self) -> &'a mut f32 {
        if self.amplitude.is_none() {
            self.amplitude = Some(0.);
        };
        self.amplitude.as_mut().unwrap()
    }

    pub fn get_amplitude(&self) -> f32 {
        self.amplitude.unwrap_or_else(|| 0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequency(&'a mut self) -> &'a mut f32 {
        if self.frequency.is_none() {
            self.frequency = Some(0.);
        };
        self.frequency.as_mut().unwrap()
    }

    pub fn get_frequency(&self) -> f32 {
        self.frequency.unwrap_or_else(|| 0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut f32 {
        if self.duration.is_none() {
            self.duration = Some(0.);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CUserMsg_Shake {
    fn new() -> CUserMsg_Shake {
        CUserMsg_Shake::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.command = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.amplitude = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.frequency = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.duration = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.command.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.amplitude.is_some() {
            my_size += 5;
        };
        if self.frequency.is_some() {
            my_size += 5;
        };
        if self.duration.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.command {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.amplitude {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        match self.frequency {
            Some(ref v) => {
                os.write_float(3, *v);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_float(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_Shake>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_Shake>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Shake_command_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Shake>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Shake_amplitude_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Shake>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Shake_frequency_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Shake>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Shake_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Shake>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_Shake>(
                    "CUserMsg_Shake",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_Shake>()
    }
}

impl ::protobuf::Clear for CUserMsg_Shake {
    fn clear(&mut self) {
        self.clear_command();
        self.clear_amplitude();
        self.clear_frequency();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_Shake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_Shake_command_acc_type;
static CUserMsg_Shake_command_acc: CUserMsg_Shake_command_acc_type = CUserMsg_Shake_command_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Shake> for CUserMsg_Shake_command_acc_type {
    fn name(&self) -> &'static str {
        "command"
    }

    fn has_field(&self, m: &CUserMsg_Shake) -> bool {
        m.has_command()
    }

    fn get_u32(&self, m: &CUserMsg_Shake) -> u32 {
        m.get_command()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Shake_amplitude_acc_type;
static CUserMsg_Shake_amplitude_acc: CUserMsg_Shake_amplitude_acc_type = CUserMsg_Shake_amplitude_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Shake> for CUserMsg_Shake_amplitude_acc_type {
    fn name(&self) -> &'static str {
        "amplitude"
    }

    fn has_field(&self, m: &CUserMsg_Shake) -> bool {
        m.has_amplitude()
    }

    fn get_f32(&self, m: &CUserMsg_Shake) -> f32 {
        m.get_amplitude()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Shake_frequency_acc_type;
static CUserMsg_Shake_frequency_acc: CUserMsg_Shake_frequency_acc_type = CUserMsg_Shake_frequency_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Shake> for CUserMsg_Shake_frequency_acc_type {
    fn name(&self) -> &'static str {
        "frequency"
    }

    fn has_field(&self, m: &CUserMsg_Shake) -> bool {
        m.has_frequency()
    }

    fn get_f32(&self, m: &CUserMsg_Shake) -> f32 {
        m.get_frequency()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Shake_duration_acc_type;
static CUserMsg_Shake_duration_acc: CUserMsg_Shake_duration_acc_type = CUserMsg_Shake_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Shake> for CUserMsg_Shake_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CUserMsg_Shake) -> bool {
        m.has_duration()
    }

    fn get_f32(&self, m: &CUserMsg_Shake) -> f32 {
        m.get_duration()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_ShakeDir {
    shake: ::protobuf::SingularPtrField<CUserMsg_Shake>,
    direction: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_ShakeDir {
    pub fn new() -> CUserMsg_ShakeDir {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_ShakeDir {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_ShakeDir> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_ShakeDir };
        unsafe {
            instance.get(|| {
                CUserMsg_ShakeDir {
                    shake: ::protobuf::SingularPtrField::none(),
                    direction: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_shake(&mut self) {
        self.shake.clear();
    }

    pub fn has_shake(&self) -> bool {
        self.shake.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shake(&mut self, v: CUserMsg_Shake) {
        self.shake = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shake(&'a mut self) -> &'a mut CUserMsg_Shake {
        if self.shake.is_none() {
            self.shake.set_default();
        };
        self.shake.as_mut().unwrap()
    }

    pub fn get_shake(&'a self) -> &'a CUserMsg_Shake {
        self.shake.as_ref().unwrap_or_else(|| CUserMsg_Shake::default_instance())
    }

    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: CMsgVector) {
        self.direction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&'a mut self) -> &'a mut CMsgVector {
        if self.direction.is_none() {
            self.direction.set_default();
        };
        self.direction.as_mut().unwrap()
    }

    pub fn get_direction(&'a self) -> &'a CMsgVector {
        self.direction.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CUserMsg_ShakeDir {
    fn new() -> CUserMsg_ShakeDir {
        CUserMsg_ShakeDir::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.shake.set_default();
                    is.merge_message(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.direction.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.shake.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.direction.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.shake.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.direction.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_ShakeDir>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_ShakeDir>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_ShakeDir_shake_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_ShakeDir>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_ShakeDir_direction_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_ShakeDir>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_ShakeDir>(
                    "CUserMsg_ShakeDir",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_ShakeDir>()
    }
}

impl ::protobuf::Clear for CUserMsg_ShakeDir {
    fn clear(&mut self) {
        self.clear_shake();
        self.clear_direction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_ShakeDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_ShakeDir_shake_acc_type;
static CUserMsg_ShakeDir_shake_acc: CUserMsg_ShakeDir_shake_acc_type = CUserMsg_ShakeDir_shake_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_ShakeDir> for CUserMsg_ShakeDir_shake_acc_type {
    fn name(&self) -> &'static str {
        "shake"
    }

    fn has_field(&self, m: &CUserMsg_ShakeDir) -> bool {
        m.has_shake()
    }

    fn get_message<'a>(&self, m: &'a CUserMsg_ShakeDir) -> &'a ::protobuf::Message {
        m.get_shake() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_ShakeDir_direction_acc_type;
static CUserMsg_ShakeDir_direction_acc: CUserMsg_ShakeDir_direction_acc_type = CUserMsg_ShakeDir_direction_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_ShakeDir> for CUserMsg_ShakeDir_direction_acc_type {
    fn name(&self) -> &'static str {
        "direction"
    }

    fn has_field(&self, m: &CUserMsg_ShakeDir) -> bool {
        m.has_direction()
    }

    fn get_message<'a>(&self, m: &'a CUserMsg_ShakeDir) -> &'a ::protobuf::Message {
        m.get_direction() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_Tilt {
    command: Option<u32>,
    ease_in_out: Option<bool>,
    angle: ::protobuf::SingularPtrField<CMsgVector>,
    duration: Option<f32>,
    time: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_Tilt {
    pub fn new() -> CUserMsg_Tilt {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_Tilt {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_Tilt> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_Tilt };
        unsafe {
            instance.get(|| {
                CUserMsg_Tilt {
                    command: None,
                    ease_in_out: None,
                    angle: ::protobuf::SingularPtrField::none(),
                    duration: None,
                    time: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_command(&mut self) {
        self.command = None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&'a mut self) -> &'a mut u32 {
        if self.command.is_none() {
            self.command = Some(0);
        };
        self.command.as_mut().unwrap()
    }

    pub fn get_command(&self) -> u32 {
        self.command.unwrap_or_else(|| 0)
    }

    pub fn clear_ease_in_out(&mut self) {
        self.ease_in_out = None;
    }

    pub fn has_ease_in_out(&self) -> bool {
        self.ease_in_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ease_in_out(&mut self, v: bool) {
        self.ease_in_out = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ease_in_out(&'a mut self) -> &'a mut bool {
        if self.ease_in_out.is_none() {
            self.ease_in_out = Some(false);
        };
        self.ease_in_out.as_mut().unwrap()
    }

    pub fn get_ease_in_out(&self) -> bool {
        self.ease_in_out.unwrap_or_else(|| false)
    }

    pub fn clear_angle(&mut self) {
        self.angle.clear();
    }

    pub fn has_angle(&self) -> bool {
        self.angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_angle(&mut self, v: CMsgVector) {
        self.angle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_angle(&'a mut self) -> &'a mut CMsgVector {
        if self.angle.is_none() {
            self.angle.set_default();
        };
        self.angle.as_mut().unwrap()
    }

    pub fn get_angle(&'a self) -> &'a CMsgVector {
        self.angle.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut f32 {
        if self.duration.is_none() {
            self.duration = Some(0.);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or_else(|| 0.)
    }

    pub fn clear_time(&mut self) {
        self.time = None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f32) {
        self.time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&'a mut self) -> &'a mut f32 {
        if self.time.is_none() {
            self.time = Some(0.);
        };
        self.time.as_mut().unwrap()
    }

    pub fn get_time(&self) -> f32 {
        self.time.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CUserMsg_Tilt {
    fn new() -> CUserMsg_Tilt {
        CUserMsg_Tilt::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.command = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.ease_in_out = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.angle.set_default();
                    is.merge_message(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.duration = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.time = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.command.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.ease_in_out.is_some() {
            my_size += 2;
        };
        for value in self.angle.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.duration.is_some() {
            my_size += 5;
        };
        if self.time.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.command {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.ease_in_out {
            Some(ref v) => {
                os.write_bool(2, *v);
            },
            None => {},
        };
        match self.angle.as_ref() {
            Some(ref v) => {
                os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_float(4, *v);
            },
            None => {},
        };
        match self.time {
            Some(ref v) => {
                os.write_float(5, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_Tilt>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Tilt_command_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Tilt_ease_in_out_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Tilt_angle_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Tilt_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Tilt_time_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_Tilt>(
                    "CUserMsg_Tilt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_Tilt>()
    }
}

impl ::protobuf::Clear for CUserMsg_Tilt {
    fn clear(&mut self) {
        self.clear_command();
        self.clear_ease_in_out();
        self.clear_angle();
        self.clear_duration();
        self.clear_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_Tilt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_Tilt_command_acc_type;
static CUserMsg_Tilt_command_acc: CUserMsg_Tilt_command_acc_type = CUserMsg_Tilt_command_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt> for CUserMsg_Tilt_command_acc_type {
    fn name(&self) -> &'static str {
        "command"
    }

    fn has_field(&self, m: &CUserMsg_Tilt) -> bool {
        m.has_command()
    }

    fn get_u32(&self, m: &CUserMsg_Tilt) -> u32 {
        m.get_command()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Tilt_ease_in_out_acc_type;
static CUserMsg_Tilt_ease_in_out_acc: CUserMsg_Tilt_ease_in_out_acc_type = CUserMsg_Tilt_ease_in_out_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt> for CUserMsg_Tilt_ease_in_out_acc_type {
    fn name(&self) -> &'static str {
        "ease_in_out"
    }

    fn has_field(&self, m: &CUserMsg_Tilt) -> bool {
        m.has_ease_in_out()
    }

    fn get_bool(&self, m: &CUserMsg_Tilt) -> bool {
        m.get_ease_in_out()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Tilt_angle_acc_type;
static CUserMsg_Tilt_angle_acc: CUserMsg_Tilt_angle_acc_type = CUserMsg_Tilt_angle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt> for CUserMsg_Tilt_angle_acc_type {
    fn name(&self) -> &'static str {
        "angle"
    }

    fn has_field(&self, m: &CUserMsg_Tilt) -> bool {
        m.has_angle()
    }

    fn get_message<'a>(&self, m: &'a CUserMsg_Tilt) -> &'a ::protobuf::Message {
        m.get_angle() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Tilt_duration_acc_type;
static CUserMsg_Tilt_duration_acc: CUserMsg_Tilt_duration_acc_type = CUserMsg_Tilt_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt> for CUserMsg_Tilt_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CUserMsg_Tilt) -> bool {
        m.has_duration()
    }

    fn get_f32(&self, m: &CUserMsg_Tilt) -> f32 {
        m.get_duration()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Tilt_time_acc_type;
static CUserMsg_Tilt_time_acc: CUserMsg_Tilt_time_acc_type = CUserMsg_Tilt_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Tilt> for CUserMsg_Tilt_time_acc_type {
    fn name(&self) -> &'static str {
        "time"
    }

    fn has_field(&self, m: &CUserMsg_Tilt) -> bool {
        m.has_time()
    }

    fn get_f32(&self, m: &CUserMsg_Tilt) -> f32 {
        m.get_time()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_SayText {
    client: Option<u32>,
    text: ::protobuf::SingularField<String>,
    chat: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_SayText {
    pub fn new() -> CUserMsg_SayText {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_SayText {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_SayText> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_SayText };
        unsafe {
            instance.get(|| {
                CUserMsg_SayText {
                    client: None,
                    text: ::protobuf::SingularField::none(),
                    chat: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_client(&mut self) {
        self.client = None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: u32) {
        self.client = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&'a mut self) -> &'a mut u32 {
        if self.client.is_none() {
            self.client = Some(0);
        };
        self.client.as_mut().unwrap()
    }

    pub fn get_client(&self) -> u32 {
        self.client.unwrap_or_else(|| 0)
    }

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&'a mut self) -> &'a mut String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    pub fn get_text(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_chat(&mut self) {
        self.chat = None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat(&'a mut self) -> &'a mut bool {
        if self.chat.is_none() {
            self.chat = Some(false);
        };
        self.chat.as_mut().unwrap()
    }

    pub fn get_chat(&self) -> bool {
        self.chat.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CUserMsg_SayText {
    fn new() -> CUserMsg_SayText {
        CUserMsg_SayText::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.client = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.text.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.chat = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.client.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        if self.chat.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.client {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.text.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.chat {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_SayText>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText_client_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText_text_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText_chat_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_SayText>(
                    "CUserMsg_SayText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_SayText>()
    }
}

impl ::protobuf::Clear for CUserMsg_SayText {
    fn clear(&mut self) {
        self.clear_client();
        self.clear_text();
        self.clear_chat();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_SayText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_SayText_client_acc_type;
static CUserMsg_SayText_client_acc: CUserMsg_SayText_client_acc_type = CUserMsg_SayText_client_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText> for CUserMsg_SayText_client_acc_type {
    fn name(&self) -> &'static str {
        "client"
    }

    fn has_field(&self, m: &CUserMsg_SayText) -> bool {
        m.has_client()
    }

    fn get_u32(&self, m: &CUserMsg_SayText) -> u32 {
        m.get_client()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayText_text_acc_type;
static CUserMsg_SayText_text_acc: CUserMsg_SayText_text_acc_type = CUserMsg_SayText_text_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText> for CUserMsg_SayText_text_acc_type {
    fn name(&self) -> &'static str {
        "text"
    }

    fn has_field(&self, m: &CUserMsg_SayText) -> bool {
        m.has_text()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_SayText) -> &'a str {
        m.get_text()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayText_chat_acc_type;
static CUserMsg_SayText_chat_acc: CUserMsg_SayText_chat_acc_type = CUserMsg_SayText_chat_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText> for CUserMsg_SayText_chat_acc_type {
    fn name(&self) -> &'static str {
        "chat"
    }

    fn has_field(&self, m: &CUserMsg_SayText) -> bool {
        m.has_chat()
    }

    fn get_bool(&self, m: &CUserMsg_SayText) -> bool {
        m.get_chat()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_SayText2 {
    client: Option<u32>,
    chat: Option<bool>,
    format: ::protobuf::SingularField<String>,
    prefix: ::protobuf::SingularField<String>,
    text: ::protobuf::SingularField<String>,
    location: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_SayText2 {
    pub fn new() -> CUserMsg_SayText2 {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_SayText2 {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_SayText2> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_SayText2 };
        unsafe {
            instance.get(|| {
                CUserMsg_SayText2 {
                    client: None,
                    chat: None,
                    format: ::protobuf::SingularField::none(),
                    prefix: ::protobuf::SingularField::none(),
                    text: ::protobuf::SingularField::none(),
                    location: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_client(&mut self) {
        self.client = None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: u32) {
        self.client = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&'a mut self) -> &'a mut u32 {
        if self.client.is_none() {
            self.client = Some(0);
        };
        self.client.as_mut().unwrap()
    }

    pub fn get_client(&self) -> u32 {
        self.client.unwrap_or_else(|| 0)
    }

    pub fn clear_chat(&mut self) {
        self.chat = None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat(&'a mut self) -> &'a mut bool {
        if self.chat.is_none() {
            self.chat = Some(false);
        };
        self.chat.as_mut().unwrap()
    }

    pub fn get_chat(&self) -> bool {
        self.chat.unwrap_or_else(|| false)
    }

    pub fn clear_format(&mut self) {
        self.format.clear();
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: String) {
        self.format = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&'a mut self) -> &'a mut String {
        if self.format.is_none() {
            self.format.set_default();
        };
        self.format.as_mut().unwrap()
    }

    pub fn get_format(&'a self) -> &'a str {
        match self.format.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: String) {
        self.prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&'a mut self) -> &'a mut String {
        if self.prefix.is_none() {
            self.prefix.set_default();
        };
        self.prefix.as_mut().unwrap()
    }

    pub fn get_prefix(&'a self) -> &'a str {
        match self.prefix.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&'a mut self) -> &'a mut String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    pub fn get_text(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&'a mut self) -> &'a mut String {
        if self.location.is_none() {
            self.location.set_default();
        };
        self.location.as_mut().unwrap()
    }

    pub fn get_location(&'a self) -> &'a str {
        match self.location.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_SayText2 {
    fn new() -> CUserMsg_SayText2 {
        CUserMsg_SayText2::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.client = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.chat = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.format.set_default();
                    is.read_string_into(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.prefix.set_default();
                    is.read_string_into(tmp)
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.text.set_default();
                    is.read_string_into(tmp)
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.location.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.client.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.chat.is_some() {
            my_size += 2;
        };
        for value in self.format.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        for value in self.prefix.iter() {
            my_size += ::protobuf::rt::string_size(4, value.as_slice());
        };
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(5, value.as_slice());
        };
        for value in self.location.iter() {
            my_size += ::protobuf::rt::string_size(6, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.client {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.chat {
            Some(ref v) => {
                os.write_bool(2, *v);
            },
            None => {},
        };
        match self.format.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        match self.prefix.as_ref() {
            Some(ref v) => {
                os.write_string(4, v.as_slice());
            },
            None => {},
        };
        match self.text.as_ref() {
            Some(ref v) => {
                os.write_string(5, v.as_slice());
            },
            None => {},
        };
        match self.location.as_ref() {
            Some(ref v) => {
                os.write_string(6, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_SayText2>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText2_client_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText2_chat_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText2_format_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText2_prefix_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText2_text_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayText2_location_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_SayText2>(
                    "CUserMsg_SayText2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_SayText2>()
    }
}

impl ::protobuf::Clear for CUserMsg_SayText2 {
    fn clear(&mut self) {
        self.clear_client();
        self.clear_chat();
        self.clear_format();
        self.clear_prefix();
        self.clear_text();
        self.clear_location();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_SayText2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_SayText2_client_acc_type;
static CUserMsg_SayText2_client_acc: CUserMsg_SayText2_client_acc_type = CUserMsg_SayText2_client_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2> for CUserMsg_SayText2_client_acc_type {
    fn name(&self) -> &'static str {
        "client"
    }

    fn has_field(&self, m: &CUserMsg_SayText2) -> bool {
        m.has_client()
    }

    fn get_u32(&self, m: &CUserMsg_SayText2) -> u32 {
        m.get_client()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayText2_chat_acc_type;
static CUserMsg_SayText2_chat_acc: CUserMsg_SayText2_chat_acc_type = CUserMsg_SayText2_chat_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2> for CUserMsg_SayText2_chat_acc_type {
    fn name(&self) -> &'static str {
        "chat"
    }

    fn has_field(&self, m: &CUserMsg_SayText2) -> bool {
        m.has_chat()
    }

    fn get_bool(&self, m: &CUserMsg_SayText2) -> bool {
        m.get_chat()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayText2_format_acc_type;
static CUserMsg_SayText2_format_acc: CUserMsg_SayText2_format_acc_type = CUserMsg_SayText2_format_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2> for CUserMsg_SayText2_format_acc_type {
    fn name(&self) -> &'static str {
        "format"
    }

    fn has_field(&self, m: &CUserMsg_SayText2) -> bool {
        m.has_format()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_SayText2) -> &'a str {
        m.get_format()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayText2_prefix_acc_type;
static CUserMsg_SayText2_prefix_acc: CUserMsg_SayText2_prefix_acc_type = CUserMsg_SayText2_prefix_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2> for CUserMsg_SayText2_prefix_acc_type {
    fn name(&self) -> &'static str {
        "prefix"
    }

    fn has_field(&self, m: &CUserMsg_SayText2) -> bool {
        m.has_prefix()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_SayText2) -> &'a str {
        m.get_prefix()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayText2_text_acc_type;
static CUserMsg_SayText2_text_acc: CUserMsg_SayText2_text_acc_type = CUserMsg_SayText2_text_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2> for CUserMsg_SayText2_text_acc_type {
    fn name(&self) -> &'static str {
        "text"
    }

    fn has_field(&self, m: &CUserMsg_SayText2) -> bool {
        m.has_text()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_SayText2) -> &'a str {
        m.get_text()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayText2_location_acc_type;
static CUserMsg_SayText2_location_acc: CUserMsg_SayText2_location_acc_type = CUserMsg_SayText2_location_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayText2> for CUserMsg_SayText2_location_acc_type {
    fn name(&self) -> &'static str {
        "location"
    }

    fn has_field(&self, m: &CUserMsg_SayText2) -> bool {
        m.has_location()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_SayText2) -> &'a str {
        m.get_location()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_HudMsg {
    channel: Option<u32>,
    x: Option<f32>,
    y: Option<f32>,
    color1: Option<u32>,
    color2: Option<u32>,
    effect: Option<u32>,
    fade_in_time: Option<f32>,
    fade_out_time: Option<f32>,
    hold_time: Option<f32>,
    fx_time: Option<f32>,
    message: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_HudMsg {
    pub fn new() -> CUserMsg_HudMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_HudMsg {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_HudMsg> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_HudMsg };
        unsafe {
            instance.get(|| {
                CUserMsg_HudMsg {
                    channel: None,
                    x: None,
                    y: None,
                    color1: None,
                    color2: None,
                    effect: None,
                    fade_in_time: None,
                    fade_out_time: None,
                    hold_time: None,
                    fx_time: None,
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_channel(&mut self) {
        self.channel = None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&'a mut self) -> &'a mut u32 {
        if self.channel.is_none() {
            self.channel = Some(0);
        };
        self.channel.as_mut().unwrap()
    }

    pub fn get_channel(&self) -> u32 {
        self.channel.unwrap_or_else(|| 0)
    }

    pub fn clear_x(&mut self) {
        self.x = None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&'a mut self) -> &'a mut f32 {
        if self.x.is_none() {
            self.x = Some(0.);
        };
        self.x.as_mut().unwrap()
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or_else(|| 0.)
    }

    pub fn clear_y(&mut self) {
        self.y = None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&'a mut self) -> &'a mut f32 {
        if self.y.is_none() {
            self.y = Some(0.);
        };
        self.y.as_mut().unwrap()
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or_else(|| 0.)
    }

    pub fn clear_color1(&mut self) {
        self.color1 = None;
    }

    pub fn has_color1(&self) -> bool {
        self.color1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color1(&mut self, v: u32) {
        self.color1 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color1(&'a mut self) -> &'a mut u32 {
        if self.color1.is_none() {
            self.color1 = Some(0);
        };
        self.color1.as_mut().unwrap()
    }

    pub fn get_color1(&self) -> u32 {
        self.color1.unwrap_or_else(|| 0)
    }

    pub fn clear_color2(&mut self) {
        self.color2 = None;
    }

    pub fn has_color2(&self) -> bool {
        self.color2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color2(&mut self, v: u32) {
        self.color2 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color2(&'a mut self) -> &'a mut u32 {
        if self.color2.is_none() {
            self.color2 = Some(0);
        };
        self.color2.as_mut().unwrap()
    }

    pub fn get_color2(&self) -> u32 {
        self.color2.unwrap_or_else(|| 0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: u32) {
        self.effect = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&'a mut self) -> &'a mut u32 {
        if self.effect.is_none() {
            self.effect = Some(0);
        };
        self.effect.as_mut().unwrap()
    }

    pub fn get_effect(&self) -> u32 {
        self.effect.unwrap_or_else(|| 0)
    }

    pub fn clear_fade_in_time(&mut self) {
        self.fade_in_time = None;
    }

    pub fn has_fade_in_time(&self) -> bool {
        self.fade_in_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in_time(&mut self, v: f32) {
        self.fade_in_time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fade_in_time(&'a mut self) -> &'a mut f32 {
        if self.fade_in_time.is_none() {
            self.fade_in_time = Some(0.);
        };
        self.fade_in_time.as_mut().unwrap()
    }

    pub fn get_fade_in_time(&self) -> f32 {
        self.fade_in_time.unwrap_or_else(|| 0.)
    }

    pub fn clear_fade_out_time(&mut self) {
        self.fade_out_time = None;
    }

    pub fn has_fade_out_time(&self) -> bool {
        self.fade_out_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out_time(&mut self, v: f32) {
        self.fade_out_time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fade_out_time(&'a mut self) -> &'a mut f32 {
        if self.fade_out_time.is_none() {
            self.fade_out_time = Some(0.);
        };
        self.fade_out_time.as_mut().unwrap()
    }

    pub fn get_fade_out_time(&self) -> f32 {
        self.fade_out_time.unwrap_or_else(|| 0.)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: f32) {
        self.hold_time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hold_time(&'a mut self) -> &'a mut f32 {
        if self.hold_time.is_none() {
            self.hold_time = Some(0.);
        };
        self.hold_time.as_mut().unwrap()
    }

    pub fn get_hold_time(&self) -> f32 {
        self.hold_time.unwrap_or_else(|| 0.)
    }

    pub fn clear_fx_time(&mut self) {
        self.fx_time = None;
    }

    pub fn has_fx_time(&self) -> bool {
        self.fx_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fx_time(&mut self, v: f32) {
        self.fx_time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fx_time(&'a mut self) -> &'a mut f32 {
        if self.fx_time.is_none() {
            self.fx_time = Some(0.);
        };
        self.fx_time.as_mut().unwrap()
    }

    pub fn get_fx_time(&self) -> f32 {
        self.fx_time.unwrap_or_else(|| 0.)
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&'a mut self) -> &'a mut String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    pub fn get_message(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_HudMsg {
    fn new() -> CUserMsg_HudMsg {
        CUserMsg_HudMsg::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.channel = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.x = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.y = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.color1 = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.color2 = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.effect = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.fade_in_time = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.fade_out_time = Some(tmp);
                },
                9 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.hold_time = Some(tmp);
                },
                10 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.fx_time = Some(tmp);
                },
                11 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.message.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.channel.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.x.is_some() {
            my_size += 5;
        };
        if self.y.is_some() {
            my_size += 5;
        };
        for value in self.color1.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.color2.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.effect.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.fade_in_time.is_some() {
            my_size += 5;
        };
        if self.fade_out_time.is_some() {
            my_size += 5;
        };
        if self.hold_time.is_some() {
            my_size += 5;
        };
        if self.fx_time.is_some() {
            my_size += 5;
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(11, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.channel {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.x {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        match self.y {
            Some(ref v) => {
                os.write_float(3, *v);
            },
            None => {},
        };
        match self.color1 {
            Some(ref v) => {
                os.write_uint32(4, *v);
            },
            None => {},
        };
        match self.color2 {
            Some(ref v) => {
                os.write_uint32(5, *v);
            },
            None => {},
        };
        match self.effect {
            Some(ref v) => {
                os.write_uint32(6, *v);
            },
            None => {},
        };
        match self.fade_in_time {
            Some(ref v) => {
                os.write_float(7, *v);
            },
            None => {},
        };
        match self.fade_out_time {
            Some(ref v) => {
                os.write_float(8, *v);
            },
            None => {},
        };
        match self.hold_time {
            Some(ref v) => {
                os.write_float(9, *v);
            },
            None => {},
        };
        match self.fx_time {
            Some(ref v) => {
                os.write_float(10, *v);
            },
            None => {},
        };
        match self.message.as_ref() {
            Some(ref v) => {
                os.write_string(11, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_HudMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_channel_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_x_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_y_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_color1_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_color2_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_effect_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_fade_in_time_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_fade_out_time_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_hold_time_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_fx_time_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudMsg_message_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_HudMsg>(
                    "CUserMsg_HudMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_HudMsg>()
    }
}

impl ::protobuf::Clear for CUserMsg_HudMsg {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_x();
        self.clear_y();
        self.clear_color1();
        self.clear_color2();
        self.clear_effect();
        self.clear_fade_in_time();
        self.clear_fade_out_time();
        self.clear_hold_time();
        self.clear_fx_time();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_HudMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_channel_acc_type;
static CUserMsg_HudMsg_channel_acc: CUserMsg_HudMsg_channel_acc_type = CUserMsg_HudMsg_channel_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_channel_acc_type {
    fn name(&self) -> &'static str {
        "channel"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_channel()
    }

    fn get_u32(&self, m: &CUserMsg_HudMsg) -> u32 {
        m.get_channel()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_x_acc_type;
static CUserMsg_HudMsg_x_acc: CUserMsg_HudMsg_x_acc_type = CUserMsg_HudMsg_x_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_x_acc_type {
    fn name(&self) -> &'static str {
        "x"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_x()
    }

    fn get_f32(&self, m: &CUserMsg_HudMsg) -> f32 {
        m.get_x()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_y_acc_type;
static CUserMsg_HudMsg_y_acc: CUserMsg_HudMsg_y_acc_type = CUserMsg_HudMsg_y_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_y_acc_type {
    fn name(&self) -> &'static str {
        "y"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_y()
    }

    fn get_f32(&self, m: &CUserMsg_HudMsg) -> f32 {
        m.get_y()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_color1_acc_type;
static CUserMsg_HudMsg_color1_acc: CUserMsg_HudMsg_color1_acc_type = CUserMsg_HudMsg_color1_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_color1_acc_type {
    fn name(&self) -> &'static str {
        "color1"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_color1()
    }

    fn get_u32(&self, m: &CUserMsg_HudMsg) -> u32 {
        m.get_color1()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_color2_acc_type;
static CUserMsg_HudMsg_color2_acc: CUserMsg_HudMsg_color2_acc_type = CUserMsg_HudMsg_color2_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_color2_acc_type {
    fn name(&self) -> &'static str {
        "color2"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_color2()
    }

    fn get_u32(&self, m: &CUserMsg_HudMsg) -> u32 {
        m.get_color2()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_effect_acc_type;
static CUserMsg_HudMsg_effect_acc: CUserMsg_HudMsg_effect_acc_type = CUserMsg_HudMsg_effect_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_effect_acc_type {
    fn name(&self) -> &'static str {
        "effect"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_effect()
    }

    fn get_u32(&self, m: &CUserMsg_HudMsg) -> u32 {
        m.get_effect()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_fade_in_time_acc_type;
static CUserMsg_HudMsg_fade_in_time_acc: CUserMsg_HudMsg_fade_in_time_acc_type = CUserMsg_HudMsg_fade_in_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_fade_in_time_acc_type {
    fn name(&self) -> &'static str {
        "fade_in_time"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_fade_in_time()
    }

    fn get_f32(&self, m: &CUserMsg_HudMsg) -> f32 {
        m.get_fade_in_time()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_fade_out_time_acc_type;
static CUserMsg_HudMsg_fade_out_time_acc: CUserMsg_HudMsg_fade_out_time_acc_type = CUserMsg_HudMsg_fade_out_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_fade_out_time_acc_type {
    fn name(&self) -> &'static str {
        "fade_out_time"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_fade_out_time()
    }

    fn get_f32(&self, m: &CUserMsg_HudMsg) -> f32 {
        m.get_fade_out_time()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_hold_time_acc_type;
static CUserMsg_HudMsg_hold_time_acc: CUserMsg_HudMsg_hold_time_acc_type = CUserMsg_HudMsg_hold_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_hold_time_acc_type {
    fn name(&self) -> &'static str {
        "hold_time"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_hold_time()
    }

    fn get_f32(&self, m: &CUserMsg_HudMsg) -> f32 {
        m.get_hold_time()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_fx_time_acc_type;
static CUserMsg_HudMsg_fx_time_acc: CUserMsg_HudMsg_fx_time_acc_type = CUserMsg_HudMsg_fx_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_fx_time_acc_type {
    fn name(&self) -> &'static str {
        "fx_time"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_fx_time()
    }

    fn get_f32(&self, m: &CUserMsg_HudMsg) -> f32 {
        m.get_fx_time()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_HudMsg_message_acc_type;
static CUserMsg_HudMsg_message_acc: CUserMsg_HudMsg_message_acc_type = CUserMsg_HudMsg_message_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudMsg> for CUserMsg_HudMsg_message_acc_type {
    fn name(&self) -> &'static str {
        "message"
    }

    fn has_field(&self, m: &CUserMsg_HudMsg) -> bool {
        m.has_message()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_HudMsg) -> &'a str {
        m.get_message()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_HudText {
    message: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_HudText {
    pub fn new() -> CUserMsg_HudText {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_HudText {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_HudText> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_HudText };
        unsafe {
            instance.get(|| {
                CUserMsg_HudText {
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&'a mut self) -> &'a mut String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    pub fn get_message(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_HudText {
    fn new() -> CUserMsg_HudText {
        CUserMsg_HudText::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.message.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.message.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_HudText>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudText>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HudText_message_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HudText>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_HudText>(
                    "CUserMsg_HudText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_HudText>()
    }
}

impl ::protobuf::Clear for CUserMsg_HudText {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_HudText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_HudText_message_acc_type;
static CUserMsg_HudText_message_acc: CUserMsg_HudText_message_acc_type = CUserMsg_HudText_message_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HudText> for CUserMsg_HudText_message_acc_type {
    fn name(&self) -> &'static str {
        "message"
    }

    fn has_field(&self, m: &CUserMsg_HudText) -> bool {
        m.has_message()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_HudText) -> &'a str {
        m.get_message()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_TextMsg {
    dest: Option<u32>,
    param: ::protobuf::RepeatedField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_TextMsg {
    pub fn new() -> CUserMsg_TextMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_TextMsg {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_TextMsg> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_TextMsg };
        unsafe {
            instance.get(|| {
                CUserMsg_TextMsg {
                    dest: None,
                    param: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_dest(&mut self) {
        self.dest = None;
    }

    pub fn has_dest(&self) -> bool {
        self.dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: u32) {
        self.dest = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&'a mut self) -> &'a mut u32 {
        if self.dest.is_none() {
            self.dest = Some(0);
        };
        self.dest.as_mut().unwrap()
    }

    pub fn get_dest(&self) -> u32 {
        self.dest.unwrap_or_else(|| 0)
    }

    pub fn clear_param(&mut self) {
        self.param.clear();
    }

    // Param is passed by value, moved
    pub fn set_param(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.param = v;
    }

    // Mutable pointer to the field.
    pub fn mut_param(&'a mut self) -> &'a mut ::protobuf::RepeatedField<String> {
        &mut self.param
    }

    pub fn get_param(&'a self) -> &'a [String] {
        self.param.as_slice()
    }

    pub fn add_param(&mut self, v: String) {
        self.param.push(v);
    }
}

impl ::protobuf::Message for CUserMsg_TextMsg {
    fn new() -> CUserMsg_TextMsg {
        CUserMsg_TextMsg::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.dest = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.param.push_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.dest.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.param.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.dest {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        for v in self.param.iter() {
            os.write_string(2, v.as_slice());
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_TextMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_TextMsg>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_TextMsg_dest_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_TextMsg>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_TextMsg_param_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_TextMsg>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_TextMsg>(
                    "CUserMsg_TextMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_TextMsg>()
    }
}

impl ::protobuf::Clear for CUserMsg_TextMsg {
    fn clear(&mut self) {
        self.clear_dest();
        self.clear_param();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_TextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_TextMsg_dest_acc_type;
static CUserMsg_TextMsg_dest_acc: CUserMsg_TextMsg_dest_acc_type = CUserMsg_TextMsg_dest_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_TextMsg> for CUserMsg_TextMsg_dest_acc_type {
    fn name(&self) -> &'static str {
        "dest"
    }

    fn has_field(&self, m: &CUserMsg_TextMsg) -> bool {
        m.has_dest()
    }

    fn get_u32(&self, m: &CUserMsg_TextMsg) -> u32 {
        m.get_dest()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_TextMsg_param_acc_type;
static CUserMsg_TextMsg_param_acc: CUserMsg_TextMsg_param_acc_type = CUserMsg_TextMsg_param_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_TextMsg> for CUserMsg_TextMsg_param_acc_type {
    fn name(&self) -> &'static str {
        "param"
    }

    fn len_field(&self, m: &CUserMsg_TextMsg) -> uint {
        m.get_param().len()
    }

    fn get_rep_str<'a>(&self, m: &'a CUserMsg_TextMsg) -> &'a [String] {
        m.get_param()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_GameTitle {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_GameTitle {
    pub fn new() -> CUserMsg_GameTitle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_GameTitle {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_GameTitle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_GameTitle };
        unsafe {
            instance.get(|| {
                CUserMsg_GameTitle {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CUserMsg_GameTitle {
    fn new() -> CUserMsg_GameTitle {
        CUserMsg_GameTitle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_GameTitle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_GameTitle>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_GameTitle>(
                    "CUserMsg_GameTitle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_GameTitle>()
    }
}

impl ::protobuf::Clear for CUserMsg_GameTitle {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_GameTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_ResetHUD {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_ResetHUD {
    pub fn new() -> CUserMsg_ResetHUD {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_ResetHUD {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_ResetHUD> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_ResetHUD };
        unsafe {
            instance.get(|| {
                CUserMsg_ResetHUD {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CUserMsg_ResetHUD {
    fn new() -> CUserMsg_ResetHUD {
        CUserMsg_ResetHUD::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_ResetHUD>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_ResetHUD>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_ResetHUD>(
                    "CUserMsg_ResetHUD",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_ResetHUD>()
    }
}

impl ::protobuf::Clear for CUserMsg_ResetHUD {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_ResetHUD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_SendAudio {
    stop: Option<bool>,
    name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_SendAudio {
    pub fn new() -> CUserMsg_SendAudio {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_SendAudio {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_SendAudio> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_SendAudio };
        unsafe {
            instance.get(|| {
                CUserMsg_SendAudio {
                    stop: None,
                    name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_stop(&mut self) {
        self.stop = None;
    }

    pub fn has_stop(&self) -> bool {
        self.stop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop(&mut self, v: bool) {
        self.stop = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop(&'a mut self) -> &'a mut bool {
        if self.stop.is_none() {
            self.stop = Some(false);
        };
        self.stop.as_mut().unwrap()
    }

    pub fn get_stop(&self) -> bool {
        self.stop.unwrap_or_else(|| false)
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_SendAudio {
    fn new() -> CUserMsg_SendAudio {
        CUserMsg_SendAudio::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.stop = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.stop.is_some() {
            my_size += 2;
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.stop {
            Some(ref v) => {
                os.write_bool(2, *v);
            },
            None => {},
        };
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_SendAudio>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_SendAudio>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SendAudio_stop_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SendAudio>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SendAudio_name_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SendAudio>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_SendAudio>(
                    "CUserMsg_SendAudio",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_SendAudio>()
    }
}

impl ::protobuf::Clear for CUserMsg_SendAudio {
    fn clear(&mut self) {
        self.clear_stop();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_SendAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_SendAudio_stop_acc_type;
static CUserMsg_SendAudio_stop_acc: CUserMsg_SendAudio_stop_acc_type = CUserMsg_SendAudio_stop_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SendAudio> for CUserMsg_SendAudio_stop_acc_type {
    fn name(&self) -> &'static str {
        "stop"
    }

    fn has_field(&self, m: &CUserMsg_SendAudio) -> bool {
        m.has_stop()
    }

    fn get_bool(&self, m: &CUserMsg_SendAudio) -> bool {
        m.get_stop()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SendAudio_name_acc_type;
static CUserMsg_SendAudio_name_acc: CUserMsg_SendAudio_name_acc_type = CUserMsg_SendAudio_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SendAudio> for CUserMsg_SendAudio_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CUserMsg_SendAudio) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_SendAudio) -> &'a str {
        m.get_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_VoiceMask {
    audible_players_mask: Vec<i32>,
    player_mod_enabled: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_VoiceMask {
    pub fn new() -> CUserMsg_VoiceMask {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_VoiceMask {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_VoiceMask> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_VoiceMask };
        unsafe {
            instance.get(|| {
                CUserMsg_VoiceMask {
                    audible_players_mask: Vec::new(),
                    player_mod_enabled: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_audible_players_mask(&mut self) {
        self.audible_players_mask.clear();
    }

    // Param is passed by value, moved
    pub fn set_audible_players_mask(&mut self, v: Vec<i32>) {
        self.audible_players_mask = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audible_players_mask(&'a mut self) -> &'a mut Vec<i32> {
        &mut self.audible_players_mask
    }

    pub fn get_audible_players_mask(&'a self) -> &'a [i32] {
        self.audible_players_mask.as_slice()
    }

    pub fn add_audible_players_mask(&mut self, v: i32) {
        self.audible_players_mask.push(v);
    }

    pub fn clear_player_mod_enabled(&mut self) {
        self.player_mod_enabled = None;
    }

    pub fn has_player_mod_enabled(&self) -> bool {
        self.player_mod_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mod_enabled(&mut self, v: bool) {
        self.player_mod_enabled = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_mod_enabled(&'a mut self) -> &'a mut bool {
        if self.player_mod_enabled.is_none() {
            self.player_mod_enabled = Some(false);
        };
        self.player_mod_enabled.as_mut().unwrap()
    }

    pub fn get_player_mod_enabled(&self) -> bool {
        self.player_mod_enabled.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CUserMsg_VoiceMask {
    fn new() -> CUserMsg_VoiceMask {
        CUserMsg_VoiceMask::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = is.read_raw_varint32();
                        let old_limit = is.push_limit(len);
                        while !is.eof() {
                            self.audible_players_mask.push(is.read_int32());
                        }
                        is.pop_limit(old_limit);
                    } else {
                        assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                        self.audible_players_mask.push(is.read_int32());
                    }
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.player_mod_enabled = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.audible_players_mask.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.player_mod_enabled.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.audible_players_mask.iter() {
            os.write_int32(1, *v);
        };
        match self.player_mod_enabled {
            Some(ref v) => {
                os.write_bool(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_VoiceMask>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceMask>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VoiceMask_audible_players_mask_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceMask>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VoiceMask_player_mod_enabled_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceMask>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_VoiceMask>(
                    "CUserMsg_VoiceMask",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_VoiceMask>()
    }
}

impl ::protobuf::Clear for CUserMsg_VoiceMask {
    fn clear(&mut self) {
        self.clear_audible_players_mask();
        self.clear_player_mod_enabled();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_VoiceMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_VoiceMask_audible_players_mask_acc_type;
static CUserMsg_VoiceMask_audible_players_mask_acc: CUserMsg_VoiceMask_audible_players_mask_acc_type = CUserMsg_VoiceMask_audible_players_mask_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceMask> for CUserMsg_VoiceMask_audible_players_mask_acc_type {
    fn name(&self) -> &'static str {
        "audible_players_mask"
    }

    fn len_field(&self, m: &CUserMsg_VoiceMask) -> uint {
        m.get_audible_players_mask().len()
    }

    fn get_rep_i32<'a>(&self, m: &'a CUserMsg_VoiceMask) -> &'a [i32] {
        m.get_audible_players_mask()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_VoiceMask_player_mod_enabled_acc_type;
static CUserMsg_VoiceMask_player_mod_enabled_acc: CUserMsg_VoiceMask_player_mod_enabled_acc_type = CUserMsg_VoiceMask_player_mod_enabled_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceMask> for CUserMsg_VoiceMask_player_mod_enabled_acc_type {
    fn name(&self) -> &'static str {
        "player_mod_enabled"
    }

    fn has_field(&self, m: &CUserMsg_VoiceMask) -> bool {
        m.has_player_mod_enabled()
    }

    fn get_bool(&self, m: &CUserMsg_VoiceMask) -> bool {
        m.get_player_mod_enabled()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_RequestState {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_RequestState {
    pub fn new() -> CUserMsg_RequestState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_RequestState {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_RequestState> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_RequestState };
        unsafe {
            instance.get(|| {
                CUserMsg_RequestState {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CUserMsg_RequestState {
    fn new() -> CUserMsg_RequestState {
        CUserMsg_RequestState::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_RequestState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_RequestState>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_RequestState>(
                    "CUserMsg_RequestState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_RequestState>()
    }
}

impl ::protobuf::Clear for CUserMsg_RequestState {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_RequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_HintText {
    message: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_HintText {
    pub fn new() -> CUserMsg_HintText {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_HintText {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_HintText> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_HintText };
        unsafe {
            instance.get(|| {
                CUserMsg_HintText {
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&'a mut self) -> &'a mut String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    pub fn get_message(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_HintText {
    fn new() -> CUserMsg_HintText {
        CUserMsg_HintText::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.message.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.message.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_HintText>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_HintText>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_HintText_message_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_HintText>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_HintText>(
                    "CUserMsg_HintText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_HintText>()
    }
}

impl ::protobuf::Clear for CUserMsg_HintText {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_HintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_HintText_message_acc_type;
static CUserMsg_HintText_message_acc: CUserMsg_HintText_message_acc_type = CUserMsg_HintText_message_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_HintText> for CUserMsg_HintText_message_acc_type {
    fn name(&self) -> &'static str {
        "message"
    }

    fn has_field(&self, m: &CUserMsg_HintText) -> bool {
        m.has_message()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_HintText) -> &'a str {
        m.get_message()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_KeyHintText {
    messages: ::protobuf::RepeatedField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_KeyHintText {
    pub fn new() -> CUserMsg_KeyHintText {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_KeyHintText {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_KeyHintText> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_KeyHintText };
        unsafe {
            instance.get(|| {
                CUserMsg_KeyHintText {
                    messages: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&'a mut self) -> &'a mut ::protobuf::RepeatedField<String> {
        &mut self.messages
    }

    pub fn get_messages(&'a self) -> &'a [String] {
        self.messages.as_slice()
    }

    pub fn add_messages(&mut self, v: String) {
        self.messages.push(v);
    }
}

impl ::protobuf::Message for CUserMsg_KeyHintText {
    fn new() -> CUserMsg_KeyHintText {
        CUserMsg_KeyHintText::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.messages.push_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.messages.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.messages.iter() {
            os.write_string(1, v.as_slice());
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_KeyHintText>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_KeyHintText>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_KeyHintText_messages_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_KeyHintText>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_KeyHintText>(
                    "CUserMsg_KeyHintText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_KeyHintText>()
    }
}

impl ::protobuf::Clear for CUserMsg_KeyHintText {
    fn clear(&mut self) {
        self.clear_messages();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_KeyHintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_KeyHintText_messages_acc_type;
static CUserMsg_KeyHintText_messages_acc: CUserMsg_KeyHintText_messages_acc_type = CUserMsg_KeyHintText_messages_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_KeyHintText> for CUserMsg_KeyHintText_messages_acc_type {
    fn name(&self) -> &'static str {
        "messages"
    }

    fn len_field(&self, m: &CUserMsg_KeyHintText) -> uint {
        m.get_messages().len()
    }

    fn get_rep_str<'a>(&self, m: &'a CUserMsg_KeyHintText) -> &'a [String] {
        m.get_messages()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_StatsCrawlMsg {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_StatsCrawlMsg {
    pub fn new() -> CUserMsg_StatsCrawlMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_StatsCrawlMsg {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_StatsCrawlMsg> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_StatsCrawlMsg };
        unsafe {
            instance.get(|| {
                CUserMsg_StatsCrawlMsg {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CUserMsg_StatsCrawlMsg {
    fn new() -> CUserMsg_StatsCrawlMsg {
        CUserMsg_StatsCrawlMsg::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_StatsCrawlMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_StatsCrawlMsg>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_StatsCrawlMsg>(
                    "CUserMsg_StatsCrawlMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_StatsCrawlMsg>()
    }
}

impl ::protobuf::Clear for CUserMsg_StatsCrawlMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_StatsCrawlMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_StatsSkipState {
    num_skips: Option<i32>,
    num_players: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_StatsSkipState {
    pub fn new() -> CUserMsg_StatsSkipState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_StatsSkipState {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_StatsSkipState> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_StatsSkipState };
        unsafe {
            instance.get(|| {
                CUserMsg_StatsSkipState {
                    num_skips: None,
                    num_players: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_num_skips(&mut self) {
        self.num_skips = None;
    }

    pub fn has_num_skips(&self) -> bool {
        self.num_skips.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_skips(&mut self, v: i32) {
        self.num_skips = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_skips(&'a mut self) -> &'a mut i32 {
        if self.num_skips.is_none() {
            self.num_skips = Some(0);
        };
        self.num_skips.as_mut().unwrap()
    }

    pub fn get_num_skips(&self) -> i32 {
        self.num_skips.unwrap_or_else(|| 0)
    }

    pub fn clear_num_players(&mut self) {
        self.num_players = None;
    }

    pub fn has_num_players(&self) -> bool {
        self.num_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_players(&mut self, v: i32) {
        self.num_players = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_players(&'a mut self) -> &'a mut i32 {
        if self.num_players.is_none() {
            self.num_players = Some(0);
        };
        self.num_players.as_mut().unwrap()
    }

    pub fn get_num_players(&self) -> i32 {
        self.num_players.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CUserMsg_StatsSkipState {
    fn new() -> CUserMsg_StatsSkipState {
        CUserMsg_StatsSkipState::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.num_skips = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.num_players = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.num_skips.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_players.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.num_skips {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.num_players {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_StatsSkipState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_StatsSkipState>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_StatsSkipState_num_skips_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_StatsSkipState>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_StatsSkipState_num_players_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_StatsSkipState>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_StatsSkipState>(
                    "CUserMsg_StatsSkipState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_StatsSkipState>()
    }
}

impl ::protobuf::Clear for CUserMsg_StatsSkipState {
    fn clear(&mut self) {
        self.clear_num_skips();
        self.clear_num_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_StatsSkipState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_StatsSkipState_num_skips_acc_type;
static CUserMsg_StatsSkipState_num_skips_acc: CUserMsg_StatsSkipState_num_skips_acc_type = CUserMsg_StatsSkipState_num_skips_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_StatsSkipState> for CUserMsg_StatsSkipState_num_skips_acc_type {
    fn name(&self) -> &'static str {
        "num_skips"
    }

    fn has_field(&self, m: &CUserMsg_StatsSkipState) -> bool {
        m.has_num_skips()
    }

    fn get_i32(&self, m: &CUserMsg_StatsSkipState) -> i32 {
        m.get_num_skips()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_StatsSkipState_num_players_acc_type;
static CUserMsg_StatsSkipState_num_players_acc: CUserMsg_StatsSkipState_num_players_acc_type = CUserMsg_StatsSkipState_num_players_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_StatsSkipState> for CUserMsg_StatsSkipState_num_players_acc_type {
    fn name(&self) -> &'static str {
        "num_players"
    }

    fn has_field(&self, m: &CUserMsg_StatsSkipState) -> bool {
        m.has_num_players()
    }

    fn get_i32(&self, m: &CUserMsg_StatsSkipState) -> i32 {
        m.get_num_players()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_VoiceSubtitle {
    ent_index: Option<i32>,
    menu: Option<i32>,
    item: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_VoiceSubtitle {
    pub fn new() -> CUserMsg_VoiceSubtitle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_VoiceSubtitle {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_VoiceSubtitle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_VoiceSubtitle };
        unsafe {
            instance.get(|| {
                CUserMsg_VoiceSubtitle {
                    ent_index: None,
                    menu: None,
                    item: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ent_index(&'a mut self) -> &'a mut i32 {
        if self.ent_index.is_none() {
            self.ent_index = Some(0);
        };
        self.ent_index.as_mut().unwrap()
    }

    pub fn get_ent_index(&self) -> i32 {
        self.ent_index.unwrap_or_else(|| 0)
    }

    pub fn clear_menu(&mut self) {
        self.menu = None;
    }

    pub fn has_menu(&self) -> bool {
        self.menu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu(&mut self, v: i32) {
        self.menu = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu(&'a mut self) -> &'a mut i32 {
        if self.menu.is_none() {
            self.menu = Some(0);
        };
        self.menu.as_mut().unwrap()
    }

    pub fn get_menu(&self) -> i32 {
        self.menu.unwrap_or_else(|| 0)
    }

    pub fn clear_item(&mut self) {
        self.item = None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: i32) {
        self.item = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&'a mut self) -> &'a mut i32 {
        if self.item.is_none() {
            self.item = Some(0);
        };
        self.item.as_mut().unwrap()
    }

    pub fn get_item(&self) -> i32 {
        self.item.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CUserMsg_VoiceSubtitle {
    fn new() -> CUserMsg_VoiceSubtitle {
        CUserMsg_VoiceSubtitle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.ent_index = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.menu = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.item = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.ent_index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.menu.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.item.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.ent_index {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.menu {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.item {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_VoiceSubtitle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceSubtitle>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VoiceSubtitle_ent_index_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceSubtitle>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VoiceSubtitle_menu_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceSubtitle>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VoiceSubtitle_item_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceSubtitle>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_VoiceSubtitle>(
                    "CUserMsg_VoiceSubtitle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_VoiceSubtitle>()
    }
}

impl ::protobuf::Clear for CUserMsg_VoiceSubtitle {
    fn clear(&mut self) {
        self.clear_ent_index();
        self.clear_menu();
        self.clear_item();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_VoiceSubtitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_VoiceSubtitle_ent_index_acc_type;
static CUserMsg_VoiceSubtitle_ent_index_acc: CUserMsg_VoiceSubtitle_ent_index_acc_type = CUserMsg_VoiceSubtitle_ent_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceSubtitle> for CUserMsg_VoiceSubtitle_ent_index_acc_type {
    fn name(&self) -> &'static str {
        "ent_index"
    }

    fn has_field(&self, m: &CUserMsg_VoiceSubtitle) -> bool {
        m.has_ent_index()
    }

    fn get_i32(&self, m: &CUserMsg_VoiceSubtitle) -> i32 {
        m.get_ent_index()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_VoiceSubtitle_menu_acc_type;
static CUserMsg_VoiceSubtitle_menu_acc: CUserMsg_VoiceSubtitle_menu_acc_type = CUserMsg_VoiceSubtitle_menu_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceSubtitle> for CUserMsg_VoiceSubtitle_menu_acc_type {
    fn name(&self) -> &'static str {
        "menu"
    }

    fn has_field(&self, m: &CUserMsg_VoiceSubtitle) -> bool {
        m.has_menu()
    }

    fn get_i32(&self, m: &CUserMsg_VoiceSubtitle) -> i32 {
        m.get_menu()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_VoiceSubtitle_item_acc_type;
static CUserMsg_VoiceSubtitle_item_acc: CUserMsg_VoiceSubtitle_item_acc_type = CUserMsg_VoiceSubtitle_item_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VoiceSubtitle> for CUserMsg_VoiceSubtitle_item_acc_type {
    fn name(&self) -> &'static str {
        "item"
    }

    fn has_field(&self, m: &CUserMsg_VoiceSubtitle) -> bool {
        m.has_item()
    }

    fn get_i32(&self, m: &CUserMsg_VoiceSubtitle) -> i32 {
        m.get_item()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_VGUIMenu {
    name: ::protobuf::SingularField<String>,
    show: Option<bool>,
    keys: ::protobuf::RepeatedField<CUserMsg_VGUIMenu_Keys>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_VGUIMenu {
    pub fn new() -> CUserMsg_VGUIMenu {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_VGUIMenu {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_VGUIMenu> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_VGUIMenu };
        unsafe {
            instance.get(|| {
                CUserMsg_VGUIMenu {
                    name: ::protobuf::SingularField::none(),
                    show: None,
                    keys: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_show(&mut self) {
        self.show = None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_show(&'a mut self) -> &'a mut bool {
        if self.show.is_none() {
            self.show = Some(false);
        };
        self.show.as_mut().unwrap()
    }

    pub fn get_show(&self) -> bool {
        self.show.unwrap_or_else(|| false)
    }

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<CUserMsg_VGUIMenu_Keys>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CUserMsg_VGUIMenu_Keys> {
        &mut self.keys
    }

    pub fn get_keys(&'a self) -> &'a [CUserMsg_VGUIMenu_Keys] {
        self.keys.as_slice()
    }

    pub fn add_keys(&mut self, v: CUserMsg_VGUIMenu_Keys) {
        self.keys.push(v);
    }
}

impl ::protobuf::Message for CUserMsg_VGUIMenu {
    fn new() -> CUserMsg_VGUIMenu {
        CUserMsg_VGUIMenu::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.show = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.keys.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        if self.show.is_some() {
            my_size += 2;
        };
        for value in self.keys.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.show {
            Some(ref v) => {
                os.write_bool(2, *v);
            },
            None => {},
        };
        for v in self.keys.iter() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_VGUIMenu>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VGUIMenu_name_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VGUIMenu_show_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VGUIMenu_keys_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_VGUIMenu>(
                    "CUserMsg_VGUIMenu",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_VGUIMenu>()
    }
}

impl ::protobuf::Clear for CUserMsg_VGUIMenu {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_show();
        self.clear_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_VGUIMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_VGUIMenu_name_acc_type;
static CUserMsg_VGUIMenu_name_acc: CUserMsg_VGUIMenu_name_acc_type = CUserMsg_VGUIMenu_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu> for CUserMsg_VGUIMenu_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CUserMsg_VGUIMenu) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_VGUIMenu) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_VGUIMenu_show_acc_type;
static CUserMsg_VGUIMenu_show_acc: CUserMsg_VGUIMenu_show_acc_type = CUserMsg_VGUIMenu_show_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu> for CUserMsg_VGUIMenu_show_acc_type {
    fn name(&self) -> &'static str {
        "show"
    }

    fn has_field(&self, m: &CUserMsg_VGUIMenu) -> bool {
        m.has_show()
    }

    fn get_bool(&self, m: &CUserMsg_VGUIMenu) -> bool {
        m.get_show()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_VGUIMenu_keys_acc_type;
static CUserMsg_VGUIMenu_keys_acc: CUserMsg_VGUIMenu_keys_acc_type = CUserMsg_VGUIMenu_keys_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu> for CUserMsg_VGUIMenu_keys_acc_type {
    fn name(&self) -> &'static str {
        "keys"
    }

    fn len_field(&self, m: &CUserMsg_VGUIMenu) -> uint {
        m.get_keys().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CUserMsg_VGUIMenu, index: uint) -> &'a ::protobuf::Message {
        &m.get_keys()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_VGUIMenu_Keys {
    name: ::protobuf::SingularField<String>,
    value: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_VGUIMenu_Keys {
    pub fn new() -> CUserMsg_VGUIMenu_Keys {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_VGUIMenu_Keys {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_VGUIMenu_Keys> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_VGUIMenu_Keys };
        unsafe {
            instance.get(|| {
                CUserMsg_VGUIMenu_Keys {
                    name: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&'a mut self) -> &'a mut String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    pub fn get_value(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_VGUIMenu_Keys {
    fn new() -> CUserMsg_VGUIMenu_Keys {
        CUserMsg_VGUIMenu_Keys::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.value.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.value.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_VGUIMenu_Keys>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu_Keys>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VGUIMenu_Keys_name_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu_Keys>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_VGUIMenu_Keys_value_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu_Keys>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_VGUIMenu_Keys>(
                    "CUserMsg_VGUIMenu_Keys",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_VGUIMenu_Keys>()
    }
}

impl ::protobuf::Clear for CUserMsg_VGUIMenu_Keys {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_VGUIMenu_Keys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_VGUIMenu_Keys_name_acc_type;
static CUserMsg_VGUIMenu_Keys_name_acc: CUserMsg_VGUIMenu_Keys_name_acc_type = CUserMsg_VGUIMenu_Keys_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu_Keys> for CUserMsg_VGUIMenu_Keys_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CUserMsg_VGUIMenu_Keys) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_VGUIMenu_Keys) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_VGUIMenu_Keys_value_acc_type;
static CUserMsg_VGUIMenu_Keys_value_acc: CUserMsg_VGUIMenu_Keys_value_acc_type = CUserMsg_VGUIMenu_Keys_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_VGUIMenu_Keys> for CUserMsg_VGUIMenu_Keys_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &CUserMsg_VGUIMenu_Keys) -> bool {
        m.has_value()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_VGUIMenu_Keys) -> &'a str {
        m.get_value()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_Geiger {
    range: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_Geiger {
    pub fn new() -> CUserMsg_Geiger {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_Geiger {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_Geiger> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_Geiger };
        unsafe {
            instance.get(|| {
                CUserMsg_Geiger {
                    range: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_range(&mut self) {
        self.range = None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: i32) {
        self.range = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&'a mut self) -> &'a mut i32 {
        if self.range.is_none() {
            self.range = Some(0);
        };
        self.range.as_mut().unwrap()
    }

    pub fn get_range(&self) -> i32 {
        self.range.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CUserMsg_Geiger {
    fn new() -> CUserMsg_Geiger {
        CUserMsg_Geiger::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.range = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.range.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.range {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_Geiger>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_Geiger>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Geiger_range_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Geiger>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_Geiger>(
                    "CUserMsg_Geiger",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_Geiger>()
    }
}

impl ::protobuf::Clear for CUserMsg_Geiger {
    fn clear(&mut self) {
        self.clear_range();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_Geiger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_Geiger_range_acc_type;
static CUserMsg_Geiger_range_acc: CUserMsg_Geiger_range_acc_type = CUserMsg_Geiger_range_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Geiger> for CUserMsg_Geiger_range_acc_type {
    fn name(&self) -> &'static str {
        "range"
    }

    fn has_field(&self, m: &CUserMsg_Geiger) -> bool {
        m.has_range()
    }

    fn get_i32(&self, m: &CUserMsg_Geiger) -> i32 {
        m.get_range()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_Rumble {
    index: Option<i32>,
    data: Option<i32>,
    flags: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_Rumble {
    pub fn new() -> CUserMsg_Rumble {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_Rumble {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_Rumble> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_Rumble };
        unsafe {
            instance.get(|| {
                CUserMsg_Rumble {
                    index: None,
                    data: None,
                    flags: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_index(&mut self) {
        self.index = None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&'a mut self) -> &'a mut i32 {
        if self.index.is_none() {
            self.index = Some(0);
        };
        self.index.as_mut().unwrap()
    }

    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or_else(|| 0)
    }

    pub fn clear_data(&mut self) {
        self.data = None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut i32 {
        if self.data.is_none() {
            self.data = Some(0);
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&self) -> i32 {
        self.data.unwrap_or_else(|| 0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&'a mut self) -> &'a mut i32 {
        if self.flags.is_none() {
            self.flags = Some(0);
        };
        self.flags.as_mut().unwrap()
    }

    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CUserMsg_Rumble {
    fn new() -> CUserMsg_Rumble {
        CUserMsg_Rumble::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.index = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.data = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.flags = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.flags.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.index {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.data {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.flags {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_Rumble>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_Rumble>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Rumble_index_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Rumble>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Rumble_data_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Rumble>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Rumble_flags_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Rumble>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_Rumble>(
                    "CUserMsg_Rumble",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_Rumble>()
    }
}

impl ::protobuf::Clear for CUserMsg_Rumble {
    fn clear(&mut self) {
        self.clear_index();
        self.clear_data();
        self.clear_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_Rumble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_Rumble_index_acc_type;
static CUserMsg_Rumble_index_acc: CUserMsg_Rumble_index_acc_type = CUserMsg_Rumble_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Rumble> for CUserMsg_Rumble_index_acc_type {
    fn name(&self) -> &'static str {
        "index"
    }

    fn has_field(&self, m: &CUserMsg_Rumble) -> bool {
        m.has_index()
    }

    fn get_i32(&self, m: &CUserMsg_Rumble) -> i32 {
        m.get_index()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Rumble_data_acc_type;
static CUserMsg_Rumble_data_acc: CUserMsg_Rumble_data_acc_type = CUserMsg_Rumble_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Rumble> for CUserMsg_Rumble_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CUserMsg_Rumble) -> bool {
        m.has_data()
    }

    fn get_i32(&self, m: &CUserMsg_Rumble) -> i32 {
        m.get_data()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_Rumble_flags_acc_type;
static CUserMsg_Rumble_flags_acc: CUserMsg_Rumble_flags_acc_type = CUserMsg_Rumble_flags_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Rumble> for CUserMsg_Rumble_flags_acc_type {
    fn name(&self) -> &'static str {
        "flags"
    }

    fn has_field(&self, m: &CUserMsg_Rumble) -> bool {
        m.has_flags()
    }

    fn get_i32(&self, m: &CUserMsg_Rumble) -> i32 {
        m.get_flags()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_Train {
    train: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_Train {
    pub fn new() -> CUserMsg_Train {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_Train {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_Train> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_Train };
        unsafe {
            instance.get(|| {
                CUserMsg_Train {
                    train: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_train(&mut self) {
        self.train = None;
    }

    pub fn has_train(&self) -> bool {
        self.train.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train(&mut self, v: i32) {
        self.train = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_train(&'a mut self) -> &'a mut i32 {
        if self.train.is_none() {
            self.train = Some(0);
        };
        self.train.as_mut().unwrap()
    }

    pub fn get_train(&self) -> i32 {
        self.train.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CUserMsg_Train {
    fn new() -> CUserMsg_Train {
        CUserMsg_Train::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.train = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.train.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.train {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_Train>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_Train>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_Train_train_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_Train>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_Train>(
                    "CUserMsg_Train",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_Train>()
    }
}

impl ::protobuf::Clear for CUserMsg_Train {
    fn clear(&mut self) {
        self.clear_train();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_Train {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_Train_train_acc_type;
static CUserMsg_Train_train_acc: CUserMsg_Train_train_acc_type = CUserMsg_Train_train_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_Train> for CUserMsg_Train_train_acc_type {
    fn name(&self) -> &'static str {
        "train"
    }

    fn has_field(&self, m: &CUserMsg_Train) -> bool {
        m.has_train()
    }

    fn get_i32(&self, m: &CUserMsg_Train) -> i32 {
        m.get_train()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_SayTextChannel {
    player: Option<i32>,
    channel: Option<i32>,
    text: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_SayTextChannel {
    pub fn new() -> CUserMsg_SayTextChannel {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_SayTextChannel {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_SayTextChannel> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_SayTextChannel };
        unsafe {
            instance.get(|| {
                CUserMsg_SayTextChannel {
                    player: None,
                    channel: None,
                    text: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_player(&mut self) {
        self.player = None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player(&'a mut self) -> &'a mut i32 {
        if self.player.is_none() {
            self.player = Some(0);
        };
        self.player.as_mut().unwrap()
    }

    pub fn get_player(&self) -> i32 {
        self.player.unwrap_or_else(|| 0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&'a mut self) -> &'a mut i32 {
        if self.channel.is_none() {
            self.channel = Some(0);
        };
        self.channel.as_mut().unwrap()
    }

    pub fn get_channel(&self) -> i32 {
        self.channel.unwrap_or_else(|| 0)
    }

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&'a mut self) -> &'a mut String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    pub fn get_text(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_SayTextChannel {
    fn new() -> CUserMsg_SayTextChannel {
        CUserMsg_SayTextChannel::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.player = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.channel = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.text.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.player.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.player {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.channel {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.text.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_SayTextChannel>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayTextChannel>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayTextChannel_player_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayTextChannel>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayTextChannel_channel_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayTextChannel>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_SayTextChannel_text_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_SayTextChannel>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_SayTextChannel>(
                    "CUserMsg_SayTextChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_SayTextChannel>()
    }
}

impl ::protobuf::Clear for CUserMsg_SayTextChannel {
    fn clear(&mut self) {
        self.clear_player();
        self.clear_channel();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_SayTextChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_SayTextChannel_player_acc_type;
static CUserMsg_SayTextChannel_player_acc: CUserMsg_SayTextChannel_player_acc_type = CUserMsg_SayTextChannel_player_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayTextChannel> for CUserMsg_SayTextChannel_player_acc_type {
    fn name(&self) -> &'static str {
        "player"
    }

    fn has_field(&self, m: &CUserMsg_SayTextChannel) -> bool {
        m.has_player()
    }

    fn get_i32(&self, m: &CUserMsg_SayTextChannel) -> i32 {
        m.get_player()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayTextChannel_channel_acc_type;
static CUserMsg_SayTextChannel_channel_acc: CUserMsg_SayTextChannel_channel_acc_type = CUserMsg_SayTextChannel_channel_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayTextChannel> for CUserMsg_SayTextChannel_channel_acc_type {
    fn name(&self) -> &'static str {
        "channel"
    }

    fn has_field(&self, m: &CUserMsg_SayTextChannel) -> bool {
        m.has_channel()
    }

    fn get_i32(&self, m: &CUserMsg_SayTextChannel) -> i32 {
        m.get_channel()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_SayTextChannel_text_acc_type;
static CUserMsg_SayTextChannel_text_acc: CUserMsg_SayTextChannel_text_acc_type = CUserMsg_SayTextChannel_text_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_SayTextChannel> for CUserMsg_SayTextChannel_text_acc_type {
    fn name(&self) -> &'static str {
        "text"
    }

    fn has_field(&self, m: &CUserMsg_SayTextChannel) -> bool {
        m.has_text()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_SayTextChannel) -> &'a str {
        m.get_text()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CUserMsg_MessageText {
    color: Option<u32>,
    text: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CUserMsg_MessageText {
    pub fn new() -> CUserMsg_MessageText {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CUserMsg_MessageText {
        static mut instance: ::protobuf::lazy::Lazy<CUserMsg_MessageText> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CUserMsg_MessageText };
        unsafe {
            instance.get(|| {
                CUserMsg_MessageText {
                    color: None,
                    text: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_color(&mut self) {
        self.color = None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&'a mut self) -> &'a mut u32 {
        if self.color.is_none() {
            self.color = Some(0);
        };
        self.color.as_mut().unwrap()
    }

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or_else(|| 0)
    }

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&'a mut self) -> &'a mut String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    pub fn get_text(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CUserMsg_MessageText {
    fn new() -> CUserMsg_MessageText {
        CUserMsg_MessageText::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.color = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.text.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.color.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.color {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.text.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CUserMsg_MessageText>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CUserMsg_MessageText>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_MessageText_color_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_MessageText>) });
                fields.push(unsafe { ::std::mem::transmute(&CUserMsg_MessageText_text_acc as &'static ::protobuf::reflect::FieldAccessor<CUserMsg_MessageText>) });
                ::protobuf::reflect::MessageDescriptor::new::<CUserMsg_MessageText>(
                    "CUserMsg_MessageText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CUserMsg_MessageText>()
    }
}

impl ::protobuf::Clear for CUserMsg_MessageText {
    fn clear(&mut self) {
        self.clear_color();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CUserMsg_MessageText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CUserMsg_MessageText_color_acc_type;
static CUserMsg_MessageText_color_acc: CUserMsg_MessageText_color_acc_type = CUserMsg_MessageText_color_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_MessageText> for CUserMsg_MessageText_color_acc_type {
    fn name(&self) -> &'static str {
        "color"
    }

    fn has_field(&self, m: &CUserMsg_MessageText) -> bool {
        m.has_color()
    }

    fn get_u32(&self, m: &CUserMsg_MessageText) -> u32 {
        m.get_color()
    }
}

#[allow(non_camel_case_types)]
struct CUserMsg_MessageText_text_acc_type;
static CUserMsg_MessageText_text_acc: CUserMsg_MessageText_text_acc_type = CUserMsg_MessageText_text_acc_type;

impl ::protobuf::reflect::FieldAccessor<CUserMsg_MessageText> for CUserMsg_MessageText_text_acc_type {
    fn name(&self) -> &'static str {
        "text"
    }

    fn has_field(&self, m: &CUserMsg_MessageText) -> bool {
        m.has_text()
    }

    fn get_str<'a>(&self, m: &'a CUserMsg_MessageText) -> &'a str {
        m.get_text()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum EBaseUserMessages {
    UM_AchievementEvent = 1,
    UM_CloseCaption = 2,
    UM_CloseCaptionDirect = 3,
    UM_CurrentTimescale = 4,
    UM_DesiredTimescale = 5,
    UM_Fade = 6,
    UM_GameTitle = 7,
    UM_Geiger = 8,
    UM_HintText = 9,
    UM_HudMsg = 10,
    UM_HudText = 11,
    UM_KeyHintText = 12,
    UM_MessageText = 13,
    UM_RequestState = 14,
    UM_ResetHUD = 15,
    UM_Rumble = 16,
    UM_SayText = 17,
    UM_SayText2 = 18,
    UM_SayTextChannel = 19,
    UM_Shake = 20,
    UM_ShakeDir = 21,
    UM_StatsCrawlMsg = 22,
    UM_StatsSkipState = 23,
    UM_TextMsg = 24,
    UM_Tilt = 25,
    UM_Train = 26,
    UM_VGUIMenu = 27,
    UM_VoiceMask = 28,
    UM_VoiceSubtitle = 29,
    UM_SendAudio = 30,
    UM_MAX_BASE = 63,
}

impl EBaseUserMessages {
    pub fn new(value: i32) -> EBaseUserMessages {
        match value {
            1 => UM_AchievementEvent,
            2 => UM_CloseCaption,
            3 => UM_CloseCaptionDirect,
            4 => UM_CurrentTimescale,
            5 => UM_DesiredTimescale,
            6 => UM_Fade,
            7 => UM_GameTitle,
            8 => UM_Geiger,
            9 => UM_HintText,
            10 => UM_HudMsg,
            11 => UM_HudText,
            12 => UM_KeyHintText,
            13 => UM_MessageText,
            14 => UM_RequestState,
            15 => UM_ResetHUD,
            16 => UM_Rumble,
            17 => UM_SayText,
            18 => UM_SayText2,
            19 => UM_SayTextChannel,
            20 => UM_Shake,
            21 => UM_ShakeDir,
            22 => UM_StatsCrawlMsg,
            23 => UM_StatsSkipState,
            24 => UM_TextMsg,
            25 => UM_Tilt,
            26 => UM_Train,
            27 => UM_VGUIMenu,
            28 => UM_VoiceMask,
            29 => UM_VoiceSubtitle,
            30 => UM_SendAudio,
            63 => UM_MAX_BASE,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for EBaseUserMessages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<EBaseUserMessages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EBaseUserMessages", file_descriptor_proto())
            })
        }
    }
}
