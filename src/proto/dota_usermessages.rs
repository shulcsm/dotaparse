// This file is generated. Do not edit

#![allow(dead_code)]
#![allow(non_camel_case_types)]

use descriptor::*;
use netmessages::*;
use ai_activity::*;
use dota_commonmessages::*;

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x17, 0x64, 0x6f, 0x74, 0x61, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
    0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x11, 0x6e, 0x65, 0x74,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x11,
    0x61, 0x69, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x1a, 0x19, 0x64, 0x6f, 0x74, 0x61, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2b, 0x0a, 0x18,
    0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x41, 0x49, 0x44,
    0x65, 0x62, 0x75, 0x67, 0x4c, 0x69, 0x6e, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x22, 0x24, 0x0a, 0x11, 0x43, 0x44, 0x4f,
    0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x69, 0x6e, 0x67, 0x12, 0x0f,
    0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x22,
    0xd9, 0x01, 0x0a, 0x16, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67,
    0x5f, 0x43, 0x68, 0x61, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x20, 0x0a, 0x04, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x44, 0x4f, 0x54, 0x41, 0x5f,
    0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x12, 0x0d, 0x0a, 0x05,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0a, 0x70,
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x69, 0x64, 0x5f, 0x31, 0x18, 0x03, 0x20, 0x01, 0x28, 0x11, 0x3a,
    0x02, 0x2d, 0x31, 0x12, 0x16, 0x0a, 0x0a, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x69, 0x64, 0x5f,
    0x32, 0x18, 0x04, 0x20, 0x01, 0x28, 0x11, 0x3a, 0x02, 0x2d, 0x31, 0x12, 0x16, 0x0a, 0x0a, 0x70,
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x69, 0x64, 0x5f, 0x33, 0x18, 0x05, 0x20, 0x01, 0x28, 0x11, 0x3a,
    0x02, 0x2d, 0x31, 0x12, 0x16, 0x0a, 0x0a, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x69, 0x64, 0x5f,
    0x34, 0x18, 0x06, 0x20, 0x01, 0x28, 0x11, 0x3a, 0x02, 0x2d, 0x31, 0x12, 0x16, 0x0a, 0x0a, 0x70,
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x69, 0x64, 0x5f, 0x35, 0x18, 0x07, 0x20, 0x01, 0x28, 0x11, 0x3a,
    0x02, 0x2d, 0x31, 0x12, 0x16, 0x0a, 0x0a, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x69, 0x64, 0x5f,
    0x36, 0x18, 0x08, 0x20, 0x01, 0x28, 0x11, 0x3a, 0x02, 0x2d, 0x31, 0x22, 0xcf, 0x01, 0x0a, 0x1a,
    0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6f, 0x6d,
    0x62, 0x61, 0x74, 0x4c, 0x6f, 0x67, 0x44, 0x61, 0x74, 0x61, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x74, 0x61, 0x72, 0x67,
    0x65, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a,
    0x0d, 0x61, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11, 0x61, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x65, 0x72,
    0x5f, 0x69, 0x6c, 0x6c, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x12,
    0x17, 0x0a, 0x0f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x69, 0x6c, 0x6c, 0x75, 0x73, 0x69,
    0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x12, 0x16, 0x0a, 0x0e, 0x69, 0x6e, 0x66, 0x6c,
    0x69, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x0e, 0x0a, 0x06, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x0c, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x02, 0x22, 0x21, 0x0a,
    0x1f, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6f,
    0x6d, 0x62, 0x61, 0x74, 0x4c, 0x6f, 0x67, 0x53, 0x68, 0x6f, 0x77, 0x44, 0x65, 0x61, 0x74, 0x68,
    0x22, 0x5a, 0x0a, 0x14, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67,
    0x5f, 0x42, 0x6f, 0x74, 0x43, 0x68, 0x61, 0x74, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x6c, 0x61, 0x79,
    0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x66,
    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06,
    0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x22, 0x71, 0x0a, 0x20,
    0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x6f, 0x6d,
    0x62, 0x61, 0x74, 0x48, 0x65, 0x72, 0x6f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x12, 0x0d, 0x0a, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x0c, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x20, 0x0a,
    0x09, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x5f, 0x70, 0x6f, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x0d, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x32, 0x44, 0x12,
    0x0e, 0x0a, 0x06, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x22,
    0xfd, 0x01, 0x0a, 0x1c, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67,
    0x5f, 0x4d, 0x69, 0x6e, 0x69, 0x4b, 0x69, 0x6c, 0x6c, 0x43, 0x61, 0x6d, 0x49, 0x6e, 0x66, 0x6f,
    0x12, 0x39, 0x0a, 0x09, 0x61, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d,
    0x73, 0x67, 0x5f, 0x4d, 0x69, 0x6e, 0x69, 0x4b, 0x69, 0x6c, 0x6c, 0x43, 0x61, 0x6d, 0x49, 0x6e,
    0x66, 0x6f, 0x2e, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x1a, 0xa1, 0x01, 0x0a, 0x08,
    0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x08, 0x61, 0x74, 0x74, 0x61,
    0x63, 0x6b, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x6f,
    0x74, 0x61, 0x6c, 0x5f, 0x64, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x41, 0x0a, 0x09, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d,
    0x73, 0x67, 0x5f, 0x4d, 0x69, 0x6e, 0x69, 0x4b, 0x69, 0x6c, 0x6c, 0x43, 0x61, 0x6d, 0x49, 0x6e,
    0x66, 0x6f, 0x2e, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x2e, 0x41, 0x62, 0x69, 0x6c,
    0x69, 0x74, 0x79, 0x1a, 0x2a, 0x0a, 0x07, 0x41, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x0f,
    0x0a, 0x07, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x0e, 0x0a, 0x06, 0x64, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x22,
    0x40, 0x0a, 0x1d, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f,
    0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x4c, 0x69, 0x67, 0x68, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72,
    0x12, 0x0d, 0x0a, 0x05, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x02, 0x22, 0x55, 0x0a, 0x21, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73,
    0x67, 0x5f, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x4c, 0x69, 0x67, 0x68, 0x74, 0x44, 0x69, 0x72,
    0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x0a, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67,
    0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x22, 0x5d, 0x0a, 0x19, 0x43, 0x44, 0x4f, 0x54,
    0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x50, 0x69, 0x6e, 0x67, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x2d, 0x0a, 0x0d, 0x6c, 0x6f, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x16, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x4d, 0x73, 0x67, 0x5f, 0x4c, 0x6f, 0x63, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x50, 0x69, 0x6e, 0x67, 0x22, 0x6e, 0x0a, 0x19, 0x43, 0x44, 0x4f, 0x54, 0x41,
    0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x70, 0x45,
    0x76, 0x65, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x0a, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x15, 0x0a, 0x0d, 0x65, 0x6e, 0x74, 0x69,
    0x74, 0x79, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x09, 0x0a, 0x01, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x09, 0x0a, 0x01, 0x79, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x22, 0x4d, 0x0a, 0x14, 0x43, 0x44, 0x4f, 0x54, 0x41,
    0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x4d, 0x61, 0x70, 0x4c, 0x69, 0x6e, 0x65, 0x12,
    0x11, 0x0a, 0x09, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x22, 0x0a, 0x07, 0x6d, 0x61, 0x70, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x4d, 0x73, 0x67, 0x5f, 0x4d,
    0x61, 0x70, 0x4c, 0x69, 0x6e, 0x65, 0x22, 0x6e, 0x0a, 0x1e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x70, 0x44, 0x65,
    0x62, 0x75, 0x67, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x1d, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73,
    0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x0d, 0x0a, 0x05, 0x63, 0x6f, 0x6c, 0x6f, 0x72,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x22, 0xae, 0x01, 0x0a, 0x23, 0x43, 0x44, 0x4f, 0x54, 0x41,
    0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4c, 0x69,
    0x6e, 0x65, 0x61, 0x72, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6c, 0x65, 0x12, 0x1b,
    0x0a, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x1f, 0x0a, 0x08, 0x76,
    0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
    0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x32, 0x44, 0x12, 0x0f, 0x0a, 0x07,
    0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a,
    0x08, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x16, 0x0a, 0x0e, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x5f, 0x69, 0x6e, 0x64, 0x65,
    0x78, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0e, 0x0a, 0x06, 0x68, 0x61, 0x6e, 0x64, 0x6c,
    0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x22, 0x36, 0x0a, 0x24, 0x43, 0x44, 0x4f, 0x54, 0x41,
    0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x4c,
    0x69, 0x6e, 0x65, 0x61, 0x72, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6c, 0x65, 0x12,
    0x0e, 0x0a, 0x06, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22,
    0x39, 0x0a, 0x25, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f,
    0x44, 0x6f, 0x64, 0x67, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f,
    0x6a, 0x65, 0x63, 0x74, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x10, 0x0a, 0x08, 0x65, 0x6e, 0x74, 0x69,
    0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x02, 0x28, 0x05, 0x22, 0x5f, 0x0a, 0x21, 0x43, 0x44,
    0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x70, 0x65, 0x63, 0x74,
    0x61, 0x74, 0x6f, 0x72, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x43, 0x6c, 0x69, 0x63, 0x6b, 0x12,
    0x10, 0x0a, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x05, 0x12, 0x12, 0x0a, 0x0a, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f,
    0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x22, 0x62, 0x0a, 0x1d, 0x43,
    0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x4e, 0x65, 0x76, 0x65,
    0x72, 0x6d, 0x6f, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75, 0x69, 0x65, 0x6d, 0x12, 0x15, 0x0a, 0x0d,
    0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x05, 0x12, 0x0d, 0x0a, 0x05, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x1b, 0x0a, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x22,
    0x2e, 0x0a, 0x1b, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f,
    0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x0f,
    0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x22,
    0x29, 0x0a, 0x15, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f,
    0x48, 0x75, 0x64, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x10, 0x0a, 0x08, 0x6f, 0x72, 0x64, 0x65,
    0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22, 0x63, 0x0a, 0x1b, 0x43, 0x44,
    0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x53, 0x68, 0x61, 0x72, 0x65,
    0x64, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x12, 0x10, 0x0a, 0x08, 0x65, 0x6e, 0x74,
    0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x6e,
    0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x63, 0x6f, 0x6f,
    0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x12, 0x12, 0x0a, 0x0a, 0x6e,
    0x61, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x22,
    0x2f, 0x0a, 0x1f, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f,
    0x53, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x41, 0x75, 0x74, 0x6f, 0x62, 0x75, 0x79, 0x49, 0x74,
    0x65, 0x6d, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
    0x22, 0xa3, 0x06, 0x0a, 0x16, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73,
    0x67, 0x5f, 0x55, 0x6e, 0x69, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x26, 0x0a, 0x08, 0x6d,
    0x73, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x14, 0x2e,
    0x45, 0x44, 0x6f, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x0c, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x69, 0x6e,
    0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x02, 0x28, 0x05, 0x12, 0x2e, 0x0a, 0x06, 0x73, 0x70, 0x65,
    0x65, 0x63, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x43, 0x44, 0x4f, 0x54,
    0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x55, 0x6e, 0x69, 0x74, 0x45, 0x76, 0x65,
    0x6e, 0x74, 0x2e, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x12, 0x37, 0x0a, 0x0b, 0x73, 0x70, 0x65,
    0x65, 0x63, 0x68, 0x5f, 0x6d, 0x75, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22,
    0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x55, 0x6e,
    0x69, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x4d, 0x75,
    0x74, 0x65, 0x12, 0x37, 0x0a, 0x0b, 0x61, 0x64, 0x64, 0x5f, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72,
    0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x55, 0x6e, 0x69, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74,
    0x2e, 0x41, 0x64, 0x64, 0x47, 0x65, 0x73, 0x74, 0x75, 0x72, 0x65, 0x12, 0x3d, 0x0a, 0x0e, 0x72,
    0x65, 0x6d, 0x6f, 0x76, 0x65, 0x5f, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x65, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d,
    0x73, 0x67, 0x5f, 0x55, 0x6e, 0x69, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x65, 0x6d,
    0x6f, 0x76, 0x65, 0x47, 0x65, 0x73, 0x74, 0x75, 0x72, 0x65, 0x12, 0x39, 0x0a, 0x0c, 0x62, 0x6c,
    0x6f, 0x6f, 0x64, 0x5f, 0x69, 0x6d, 0x70, 0x61, 0x63, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x23, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f,
    0x55, 0x6e, 0x69, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x42, 0x6c, 0x6f, 0x6f, 0x64, 0x49,
    0x6d, 0x70, 0x61, 0x63, 0x74, 0x12, 0x39, 0x0a, 0x0c, 0x66, 0x61, 0x64, 0x65, 0x5f, 0x67, 0x65,
    0x73, 0x74, 0x75, 0x72, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x43, 0x44,
    0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x55, 0x6e, 0x69, 0x74, 0x45,
    0x76, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x61, 0x64, 0x65, 0x47, 0x65, 0x73, 0x74, 0x75, 0x72, 0x65,
    0x1a, 0x52, 0x0a, 0x06, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x6f,
    0x6e, 0x63, 0x65, 0x70, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x72,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x16, 0x0a,
    0x0e, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0d, 0x0a, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x05, 0x1a, 0x20, 0x0a, 0x0a, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x4d, 0x75,
    0x74, 0x65, 0x12, 0x12, 0x0a, 0x05, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x02, 0x3a, 0x03, 0x30, 0x2e, 0x35, 0x1a, 0x62, 0x0a, 0x0a, 0x41, 0x64, 0x64, 0x47, 0x65, 0x73,
    0x74, 0x75, 0x72, 0x65, 0x12, 0x1b, 0x0a, 0x08, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x09, 0x2e, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74,
    0x79, 0x12, 0x0c, 0x0a, 0x04, 0x73, 0x6c, 0x6f, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x12, 0x0a, 0x07, 0x66, 0x61, 0x64, 0x65, 0x5f, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02,
    0x3a, 0x01, 0x30, 0x12, 0x15, 0x0a, 0x08, 0x66, 0x61, 0x64, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x02, 0x3a, 0x03, 0x30, 0x2e, 0x31, 0x1a, 0x2c, 0x0a, 0x0d, 0x52, 0x65,
    0x6d, 0x6f, 0x76, 0x65, 0x47, 0x65, 0x73, 0x74, 0x75, 0x72, 0x65, 0x12, 0x1b, 0x0a, 0x08, 0x61,
    0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x09, 0x2e,
    0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x1a, 0x40, 0x0a, 0x0b, 0x42, 0x6c, 0x6f, 0x6f,
    0x64, 0x49, 0x6d, 0x70, 0x61, 0x63, 0x74, 0x12, 0x0d, 0x0a, 0x05, 0x73, 0x63, 0x61, 0x6c, 0x65,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x78, 0x5f, 0x6e, 0x6f, 0x72, 0x6d,
    0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x79, 0x5f, 0x6e, 0x6f,
    0x72, 0x6d, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x1a, 0x2a, 0x0a, 0x0b, 0x46, 0x61,
    0x64, 0x65, 0x47, 0x65, 0x73, 0x74, 0x75, 0x72, 0x65, 0x12, 0x1b, 0x0a, 0x08, 0x61, 0x63, 0x74,
    0x69, 0x76, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x09, 0x2e, 0x41, 0x63,
    0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x22, 0x30, 0x0a, 0x1a, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x49, 0x74, 0x65, 0x6d, 0x50, 0x75, 0x72, 0x63, 0x68,
    0x61, 0x73, 0x65, 0x64, 0x12, 0x12, 0x0a, 0x0a, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x69, 0x6e, 0x64,
    0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x22, 0x6a, 0x0a, 0x16, 0x43, 0x44, 0x4f, 0x54,
    0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x49, 0x74, 0x65, 0x6d, 0x46, 0x6f, 0x75,
    0x6e, 0x64, 0x12, 0x0e, 0x0a, 0x06, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x05, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x61, 0x72, 0x69, 0x74, 0x79, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x05, 0x12, 0x0e, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x69, 0x74, 0x65, 0x6d, 0x64, 0x65, 0x66, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x05, 0x22, 0xcb, 0x0e, 0x0a, 0x1c, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73,
    0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61,
    0x6e, 0x61, 0x67, 0x65, 0x72, 0x12, 0x24, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49,
    0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x12, 0x0d, 0x0a, 0x05, 0x69,
    0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x52, 0x0a, 0x16, 0x72, 0x65,
    0x6c, 0x65, 0x61, 0x73, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x5f, 0x69,
    0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x43, 0x44, 0x4f,
    0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63,
    0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73,
    0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x45,
    0x0a, 0x0f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c,
    0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d,
    0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72,
    0x74, 0x69, 0x63, 0x6c, 0x65, 0x12, 0x47, 0x0a, 0x10, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79,
    0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x2d, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50,
    0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x44,
    0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x12, 0x5a,
    0x0a, 0x1a, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63,
    0x6c, 0x65, 0x5f, 0x69, 0x6e, 0x76, 0x6f, 0x6c, 0x76, 0x69, 0x6e, 0x67, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x36, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73,
    0x67, 0x5f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65,
    0x72, 0x2e, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c,
    0x65, 0x49, 0x6e, 0x76, 0x6f, 0x6c, 0x76, 0x69, 0x6e, 0x67, 0x12, 0x45, 0x0a, 0x0f, 0x75, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x18, 0x07, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d,
    0x73, 0x67, 0x5f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67,
    0x65, 0x72, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c,
    0x65, 0x12, 0x4c, 0x0a, 0x13, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74,
    0x69, 0x63, 0x6c, 0x65, 0x5f, 0x66, 0x77, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f,
    0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61,
    0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x55, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x46, 0x77, 0x64, 0x12,
    0x52, 0x0a, 0x16, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63,
    0x6c, 0x65, 0x5f, 0x6f, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x32, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50,
    0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x55,
    0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4f, 0x72, 0x69,
    0x65, 0x6e, 0x74, 0x12, 0x56, 0x0a, 0x18, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61,
    0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x5f, 0x66, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x18,
    0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65,
    0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e,
    0x61, 0x67, 0x65, 0x72, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69,
    0x63, 0x6c, 0x65, 0x46, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x12, 0x52, 0x0a, 0x16, 0x75,
    0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x5f, 0x6f,
    0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x43, 0x44,
    0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61, 0x72, 0x74, 0x69,
    0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74,
    0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12,
    0x4c, 0x0a, 0x13, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63,
    0x6c, 0x65, 0x5f, 0x65, 0x6e, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x43,
    0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61, 0x72, 0x74,
    0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x55, 0x70, 0x64, 0x61,
    0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x45, 0x6e, 0x74, 0x12, 0x54, 0x0a,
    0x17, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65,
    0x5f, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33,
    0x2e, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x50, 0x61,
    0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x2e, 0x55, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4c, 0x61, 0x74, 0x65,
    0x6e, 0x63, 0x79, 0x1a, 0x16, 0x0a, 0x14, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x50, 0x61,
    0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x1a, 0x59, 0x0a, 0x0e, 0x43,
    0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x12, 0x1b, 0x0a,
    0x13, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x69,
    0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x61, 0x74,
    0x74, 0x61, 0x63, 0x68, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x15, 0x0a, 0x0d, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x1a, 0x2e, 0x0a, 0x0f, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f,
    0x79, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x12, 0x1b, 0x0a, 0x13, 0x64, 0x65, 0x73,
    0x74, 0x72, 0x6f, 0x79, 0x5f, 0x69, 0x6d, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x6c, 0x79,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x4e, 0x0a, 0x18, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f,
    0x79, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x49, 0x6e, 0x76, 0x6f, 0x6c, 0x76, 0x69,
    0x6e, 0x67, 0x12, 0x1b, 0x0a, 0x13, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x5f, 0x69, 0x6d,
    0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x6c, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x12,
    0x15, 0x0a, 0x0d, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x1a, 0x46, 0x0a, 0x0e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
    0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74,
    0x72, 0x6f, 0x6c, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x1d, 0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x1a, 0x48,
    0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65,
    0x46, 0x77, 0x64, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70,
    0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1c, 0x0a, 0x07, 0x66, 0x6f,
    0x72, 0x77, 0x61, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x1a, 0x80, 0x01, 0x0a, 0x14, 0x55, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4f, 0x72, 0x69, 0x65, 0x6e,
    0x74, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70, 0x6f, 0x69,
    0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1c, 0x0a, 0x07, 0x66, 0x6f, 0x72, 0x77,
    0x61, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67,
    0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x1a, 0x0a, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74,
    0x6f, 0x72, 0x12, 0x17, 0x0a, 0x02, 0x75, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x1a, 0x4e, 0x0a, 0x16, 0x55,
    0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x46, 0x61, 0x6c,
    0x6c, 0x62, 0x61, 0x63, 0x6b, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
    0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1d, 0x0a, 0x08,
    0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x1a, 0x51, 0x0a, 0x14, 0x55,
    0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4f, 0x66, 0x66,
    0x73, 0x65, 0x74, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70,
    0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x22, 0x0a, 0x0d, 0x6f, 0x72,
    0x69, 0x67, 0x69, 0x6e, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x1a, 0x92,
    0x01, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c,
    0x65, 0x45, 0x6e, 0x74, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f,
    0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x15, 0x0a, 0x0d, 0x65,
    0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x5f, 0x74, 0x79, 0x70,
    0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x61, 0x74, 0x74, 0x61, 0x63,
    0x68, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x26, 0x0a, 0x11, 0x66,
    0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63,
    0x74, 0x6f, 0x72, 0x1a, 0x3d, 0x0a, 0x15, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72,
    0x74, 0x69, 0x63, 0x6c, 0x65, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x16, 0x0a, 0x0e,
    0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x69, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x05, 0x22, 0xb0, 0x01, 0x0a, 0x1a, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73, 0x65, 0x72,
    0x4d, 0x73, 0x67, 0x5f, 0x4f, 0x76, 0x65, 0x72, 0x68, 0x65, 0x61, 0x64, 0x45, 0x76, 0x65, 0x6e,
    0x74, 0x12, 0x2a, 0x0a, 0x0c, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x79, 0x70,
    0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x14, 0x2e, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x4f,
    0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x12, 0x0d, 0x0a,
    0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1e, 0x0a, 0x16,
    0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x65, 0x6e,
    0x74, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x17, 0x0a, 0x0f,
    0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1e, 0x0a, 0x16, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f,
    0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x05, 0x22, 0x3e, 0x0a, 0x1c, 0x43, 0x44, 0x4f, 0x54, 0x41, 0x55, 0x73,
    0x65, 0x72, 0x4d, 0x73, 0x67, 0x5f, 0x54, 0x75, 0x74, 0x6f, 0x72, 0x69, 0x61, 0x6c, 0x54, 0x69,
    0x70, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x05, 0x2a, 0xe6, 0x06, 0x0a, 0x11, 0x45, 0x44, 0x6f, 0x74, 0x61, 0x55,
    0x73, 0x65, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x1e, 0x0a, 0x1a, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x41, 0x64, 0x64, 0x55, 0x6e, 0x69, 0x74, 0x54, 0x6f,
    0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x10, 0x40, 0x12, 0x17, 0x0a, 0x13, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x41, 0x49, 0x44, 0x65, 0x62, 0x75, 0x67, 0x4c, 0x69,
    0x6e, 0x65, 0x10, 0x41, 0x12, 0x15, 0x0a, 0x11, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f,
    0x43, 0x68, 0x61, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x10, 0x42, 0x12, 0x1f, 0x0a, 0x1b, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x43, 0x6f, 0x6d, 0x62, 0x61, 0x74, 0x48, 0x65, 0x72,
    0x6f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x10, 0x43, 0x12, 0x19, 0x0a, 0x15,
    0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x43, 0x6f, 0x6d, 0x62, 0x61, 0x74, 0x4c, 0x6f,
    0x67, 0x44, 0x61, 0x74, 0x61, 0x10, 0x44, 0x12, 0x1e, 0x0a, 0x1a, 0x44, 0x4f, 0x54, 0x41, 0x5f,
    0x55, 0x4d, 0x5f, 0x43, 0x6f, 0x6d, 0x62, 0x61, 0x74, 0x4c, 0x6f, 0x67, 0x53, 0x68, 0x6f, 0x77,
    0x44, 0x65, 0x61, 0x74, 0x68, 0x10, 0x46, 0x12, 0x22, 0x0a, 0x1e, 0x44, 0x4f, 0x54, 0x41, 0x5f,
    0x55, 0x4d, 0x5f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x50,
    0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6c, 0x65, 0x10, 0x47, 0x12, 0x23, 0x0a, 0x1f, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x4c, 0x69,
    0x6e, 0x65, 0x61, 0x72, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6c, 0x65, 0x10, 0x48,
    0x12, 0x24, 0x0a, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x44, 0x6f, 0x64, 0x67,
    0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
    0x69, 0x6c, 0x65, 0x73, 0x10, 0x49, 0x12, 0x1c, 0x0a, 0x18, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55,
    0x4d, 0x5f, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x4c, 0x69, 0x67, 0x68, 0x74, 0x43, 0x6f, 0x6c,
    0x6f, 0x72, 0x10, 0x4a, 0x12, 0x20, 0x0a, 0x1c, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f,
    0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x4c, 0x69, 0x67, 0x68, 0x74, 0x44, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x10, 0x4b, 0x12, 0x1a, 0x0a, 0x16, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55,
    0x4d, 0x5f, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
    0x10, 0x4c, 0x12, 0x18, 0x0a, 0x14, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x4c, 0x6f,
    0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x69, 0x6e, 0x67, 0x10, 0x4d, 0x12, 0x13, 0x0a, 0x0f,
    0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x4d, 0x61, 0x70, 0x4c, 0x69, 0x6e, 0x65, 0x10,
    0x4e, 0x12, 0x1b, 0x0a, 0x17, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x4d, 0x69, 0x6e,
    0x69, 0x4b, 0x69, 0x6c, 0x6c, 0x43, 0x61, 0x6d, 0x49, 0x6e, 0x66, 0x6f, 0x10, 0x4f, 0x12, 0x1d,
    0x0a, 0x19, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x61,
    0x70, 0x44, 0x65, 0x62, 0x75, 0x67, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x10, 0x50, 0x12, 0x18, 0x0a,
    0x14, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x70,
    0x45, 0x76, 0x65, 0x6e, 0x74, 0x10, 0x51, 0x12, 0x1c, 0x0a, 0x18, 0x44, 0x4f, 0x54, 0x41, 0x5f,
    0x55, 0x4d, 0x5f, 0x4e, 0x65, 0x76, 0x65, 0x72, 0x6d, 0x6f, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75,
    0x69, 0x65, 0x6d, 0x10, 0x52, 0x12, 0x19, 0x0a, 0x15, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d,
    0x5f, 0x4f, 0x76, 0x65, 0x72, 0x68, 0x65, 0x61, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x10, 0x53,
    0x12, 0x1e, 0x0a, 0x1a, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x53, 0x65, 0x74, 0x4e,
    0x65, 0x78, 0x74, 0x41, 0x75, 0x74, 0x6f, 0x62, 0x75, 0x79, 0x49, 0x74, 0x65, 0x6d, 0x10, 0x54,
    0x12, 0x1a, 0x0a, 0x16, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x53, 0x68, 0x61, 0x72,
    0x65, 0x64, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x10, 0x55, 0x12, 0x20, 0x0a, 0x1c,
    0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x53, 0x70, 0x65, 0x63, 0x74, 0x61, 0x74, 0x6f,
    0x72, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x43, 0x6c, 0x69, 0x63, 0x6b, 0x10, 0x56, 0x12, 0x1b,
    0x0a, 0x17, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x54, 0x75, 0x74, 0x6f, 0x72, 0x69,
    0x61, 0x6c, 0x54, 0x69, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x10, 0x57, 0x12, 0x15, 0x0a, 0x11, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x55, 0x6e, 0x69, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74,
    0x10, 0x58, 0x12, 0x1b, 0x0a, 0x17, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x50, 0x61,
    0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x10, 0x59, 0x12,
    0x13, 0x0a, 0x0f, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x42, 0x6f, 0x74, 0x43, 0x68,
    0x61, 0x74, 0x10, 0x5a, 0x12, 0x14, 0x0a, 0x10, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f,
    0x48, 0x75, 0x64, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x10, 0x5b, 0x12, 0x19, 0x0a, 0x15, 0x44, 0x4f,
    0x54, 0x41, 0x5f, 0x55, 0x4d, 0x5f, 0x49, 0x74, 0x65, 0x6d, 0x50, 0x75, 0x72, 0x63, 0x68, 0x61,
    0x73, 0x65, 0x64, 0x10, 0x5c, 0x12, 0x10, 0x0a, 0x0c, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4d,
    0x5f, 0x50, 0x69, 0x6e, 0x67, 0x10, 0x5d, 0x12, 0x15, 0x0a, 0x11, 0x44, 0x4f, 0x54, 0x41, 0x5f,
    0x55, 0x4d, 0x5f, 0x49, 0x74, 0x65, 0x6d, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x10, 0x5e, 0x2a, 0xaa,
    0x0c, 0x0a, 0x11, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x12, 0x21, 0x0a, 0x14, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48, 0x41, 0x54, 0x5f,
    0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x48, 0x45, 0x52, 0x4f, 0x5f, 0x4b, 0x49, 0x4c,
    0x4c, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53,
    0x41, 0x47, 0x45, 0x5f, 0x48, 0x45, 0x52, 0x4f, 0x5f, 0x44, 0x45, 0x4e, 0x59, 0x10, 0x01, 0x12,
    0x1e, 0x0a, 0x1a, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f,
    0x42, 0x41, 0x52, 0x52, 0x41, 0x43, 0x4b, 0x53, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x10, 0x02, 0x12,
    0x1b, 0x0a, 0x17, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f,
    0x54, 0x4f, 0x57, 0x45, 0x52, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x10, 0x03, 0x12, 0x1b, 0x0a, 0x17,
    0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x54, 0x4f, 0x57,
    0x45, 0x52, 0x5f, 0x44, 0x45, 0x4e, 0x59, 0x10, 0x04, 0x12, 0x1b, 0x0a, 0x17, 0x43, 0x48, 0x41,
    0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x46, 0x49, 0x52, 0x53, 0x54, 0x42,
    0x4c, 0x4f, 0x4f, 0x44, 0x10, 0x05, 0x12, 0x1c, 0x0a, 0x18, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d,
    0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4b, 0x5f, 0x4b, 0x49,
    0x4c, 0x4c, 0x10, 0x06, 0x12, 0x18, 0x0a, 0x14, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x42, 0x55, 0x59, 0x42, 0x41, 0x43, 0x4b, 0x10, 0x07, 0x12, 0x16,
    0x0a, 0x12, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x41,
    0x45, 0x47, 0x49, 0x53, 0x10, 0x08, 0x12, 0x1c, 0x0a, 0x18, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d,
    0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x52, 0x4f, 0x53, 0x48, 0x41, 0x4e, 0x5f, 0x4b, 0x49,
    0x4c, 0x4c, 0x10, 0x09, 0x12, 0x1d, 0x0a, 0x19, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f, 0x55, 0x52, 0x49, 0x45, 0x52, 0x5f, 0x4c, 0x4f, 0x53,
    0x54, 0x10, 0x0a, 0x12, 0x22, 0x0a, 0x1e, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53,
    0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f, 0x55, 0x52, 0x49, 0x45, 0x52, 0x5f, 0x52, 0x45, 0x53, 0x50,
    0x41, 0x57, 0x4e, 0x45, 0x44, 0x10, 0x0b, 0x12, 0x1b, 0x0a, 0x17, 0x43, 0x48, 0x41, 0x54, 0x5f,
    0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x47, 0x4c, 0x59, 0x50, 0x48, 0x5f, 0x55, 0x53,
    0x45, 0x44, 0x10, 0x0c, 0x12, 0x1e, 0x0a, 0x1a, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x49, 0x54, 0x45, 0x4d, 0x5f, 0x50, 0x55, 0x52, 0x43, 0x48, 0x41,
    0x53, 0x45, 0x10, 0x0d, 0x12, 0x18, 0x0a, 0x14, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x10, 0x0e, 0x12, 0x1b,
    0x0a, 0x17, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x44,
    0x49, 0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x10, 0x0f, 0x12, 0x2e, 0x0a, 0x2a, 0x43,
    0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x44, 0x49, 0x53, 0x43,
    0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x5f, 0x57, 0x41, 0x49, 0x54, 0x5f, 0x46, 0x4f, 0x52, 0x5f,
    0x52, 0x45, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x10, 0x10, 0x12, 0x2a, 0x0a, 0x26, 0x43,
    0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x44, 0x49, 0x53, 0x43,
    0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x52, 0x45, 0x4d, 0x41,
    0x49, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x11, 0x12, 0x31, 0x0a, 0x2d, 0x43, 0x48, 0x41, 0x54, 0x5f,
    0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x44, 0x49, 0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45,
    0x43, 0x54, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x52, 0x45, 0x4d, 0x41, 0x49, 0x4e, 0x49, 0x4e,
    0x47, 0x5f, 0x50, 0x4c, 0x55, 0x52, 0x41, 0x4c, 0x10, 0x12, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48,
    0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x52, 0x45, 0x43, 0x4f, 0x4e,
    0x4e, 0x45, 0x43, 0x54, 0x10, 0x13, 0x12, 0x18, 0x0a, 0x14, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d,
    0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x41, 0x42, 0x41, 0x4e, 0x44, 0x4f, 0x4e, 0x10, 0x14,
    0x12, 0x1e, 0x0a, 0x1a, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45,
    0x5f, 0x53, 0x41, 0x46, 0x45, 0x5f, 0x54, 0x4f, 0x5f, 0x4c, 0x45, 0x41, 0x56, 0x45, 0x10, 0x15,
    0x12, 0x1c, 0x0a, 0x18, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45,
    0x5f, 0x52, 0x55, 0x4e, 0x45, 0x5f, 0x50, 0x49, 0x43, 0x4b, 0x55, 0x50, 0x10, 0x16, 0x12, 0x1c,
    0x0a, 0x18, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x52,
    0x55, 0x4e, 0x45, 0x5f, 0x42, 0x4f, 0x54, 0x54, 0x4c, 0x45, 0x10, 0x17, 0x12, 0x19, 0x0a, 0x15,
    0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x49, 0x4e, 0x54,
    0x48, 0x45, 0x42, 0x41, 0x47, 0x10, 0x18, 0x12, 0x1b, 0x0a, 0x17, 0x43, 0x48, 0x41, 0x54, 0x5f,
    0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x53, 0x45, 0x43, 0x52, 0x45, 0x54, 0x53, 0x48,
    0x4f, 0x50, 0x10, 0x19, 0x12, 0x23, 0x0a, 0x1f, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x49, 0x54, 0x45, 0x4d, 0x5f, 0x41, 0x55, 0x54, 0x4f, 0x50, 0x55,
    0x52, 0x43, 0x48, 0x41, 0x53, 0x45, 0x44, 0x10, 0x1a, 0x12, 0x1f, 0x0a, 0x1b, 0x43, 0x48, 0x41,
    0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x49, 0x54, 0x45, 0x4d, 0x53, 0x5f,
    0x43, 0x4f, 0x4d, 0x42, 0x49, 0x4e, 0x45, 0x44, 0x10, 0x1b, 0x12, 0x1d, 0x0a, 0x19, 0x43, 0x48,
    0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x53, 0x55, 0x50, 0x45, 0x52,
    0x5f, 0x43, 0x52, 0x45, 0x45, 0x50, 0x53, 0x10, 0x1c, 0x12, 0x25, 0x0a, 0x21, 0x43, 0x48, 0x41,
    0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x41, 0x4e, 0x54, 0x5f, 0x55,
    0x53, 0x45, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x49, 0x54, 0x45, 0x4d, 0x10, 0x1d,
    0x12, 0x22, 0x0a, 0x1e, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45,
    0x5f, 0x43, 0x48, 0x41, 0x52, 0x47, 0x45, 0x53, 0x5f, 0x45, 0x58, 0x48, 0x41, 0x55, 0x53, 0x54,
    0x45, 0x44, 0x10, 0x1e, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x41, 0x4e, 0x54, 0x50, 0x41, 0x55, 0x53, 0x45, 0x10, 0x1f,
    0x12, 0x1d, 0x0a, 0x19, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45,
    0x5f, 0x4e, 0x4f, 0x50, 0x41, 0x55, 0x53, 0x45, 0x53, 0x4c, 0x45, 0x46, 0x54, 0x10, 0x20, 0x12,
    0x1d, 0x0a, 0x19, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f,
    0x43, 0x41, 0x4e, 0x54, 0x50, 0x41, 0x55, 0x53, 0x45, 0x59, 0x45, 0x54, 0x10, 0x21, 0x12, 0x17,
    0x0a, 0x13, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x50,
    0x41, 0x55, 0x53, 0x45, 0x44, 0x10, 0x22, 0x12, 0x22, 0x0a, 0x1e, 0x43, 0x48, 0x41, 0x54, 0x5f,
    0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x55, 0x4e, 0x50, 0x41, 0x55, 0x53, 0x45, 0x5f,
    0x43, 0x4f, 0x55, 0x4e, 0x54, 0x44, 0x4f, 0x57, 0x4e, 0x10, 0x23, 0x12, 0x19, 0x0a, 0x15, 0x43,
    0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x55, 0x4e, 0x50, 0x41,
    0x55, 0x53, 0x45, 0x44, 0x10, 0x24, 0x12, 0x1e, 0x0a, 0x1a, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d,
    0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x41, 0x55, 0x54, 0x4f, 0x5f, 0x55, 0x4e, 0x50, 0x41,
    0x55, 0x53, 0x45, 0x44, 0x10, 0x25, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d,
    0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x59, 0x4f, 0x55, 0x50, 0x41, 0x55, 0x53, 0x45, 0x44,
    0x10, 0x26, 0x12, 0x20, 0x0a, 0x1c, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41,
    0x47, 0x45, 0x5f, 0x43, 0x41, 0x4e, 0x54, 0x55, 0x4e, 0x50, 0x41, 0x55, 0x53, 0x45, 0x54, 0x45,
    0x41, 0x4d, 0x10, 0x27, 0x12, 0x28, 0x0a, 0x24, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x53, 0x41, 0x46, 0x45, 0x5f, 0x54, 0x4f, 0x5f, 0x4c, 0x45, 0x41,
    0x56, 0x45, 0x5f, 0x41, 0x42, 0x41, 0x4e, 0x44, 0x4f, 0x4e, 0x45, 0x52, 0x10, 0x28, 0x12, 0x22,
    0x0a, 0x1e, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x56,
    0x4f, 0x49, 0x43, 0x45, 0x5f, 0x54, 0x45, 0x58, 0x54, 0x5f, 0x42, 0x41, 0x4e, 0x4e, 0x45, 0x44,
    0x10, 0x29, 0x12, 0x2e, 0x0a, 0x2a, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41,
    0x47, 0x45, 0x5f, 0x53, 0x50, 0x45, 0x43, 0x54, 0x41, 0x54, 0x4f, 0x52, 0x53, 0x5f, 0x57, 0x41,
    0x54, 0x43, 0x48, 0x49, 0x4e, 0x47, 0x5f, 0x54, 0x48, 0x49, 0x53, 0x5f, 0x47, 0x41, 0x4d, 0x45,
    0x10, 0x2a, 0x12, 0x20, 0x0a, 0x1c, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41,
    0x47, 0x45, 0x5f, 0x52, 0x45, 0x50, 0x4f, 0x52, 0x54, 0x5f, 0x52, 0x45, 0x4d, 0x49, 0x4e, 0x44,
    0x45, 0x52, 0x10, 0x2b, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53,
    0x53, 0x41, 0x47, 0x45, 0x5f, 0x45, 0x43, 0x4f, 0x4e, 0x5f, 0x49, 0x54, 0x45, 0x4d, 0x10, 0x2c,
    0x12, 0x16, 0x0a, 0x12, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45,
    0x5f, 0x54, 0x41, 0x55, 0x4e, 0x54, 0x10, 0x2d, 0x12, 0x17, 0x0a, 0x13, 0x43, 0x48, 0x41, 0x54,
    0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x52, 0x41, 0x4e, 0x44, 0x4f, 0x4d, 0x10,
    0x2e, 0x12, 0x18, 0x0a, 0x14, 0x43, 0x48, 0x41, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47,
    0x45, 0x5f, 0x52, 0x44, 0x5f, 0x54, 0x55, 0x52, 0x4e, 0x10, 0x2f, 0x2a, 0xbe, 0x01, 0x0a, 0x13,
    0x45, 0x44, 0x6f, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x10, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4e, 0x49, 0x54,
    0x5f, 0x53, 0x50, 0x45, 0x45, 0x43, 0x48, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x44, 0x4f, 0x54,
    0x41, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x5f, 0x53, 0x50, 0x45, 0x45, 0x43, 0x48, 0x5f, 0x4d, 0x55,
    0x54, 0x45, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4e, 0x49,
    0x54, 0x5f, 0x41, 0x44, 0x44, 0x5f, 0x47, 0x45, 0x53, 0x54, 0x55, 0x52, 0x45, 0x10, 0x02, 0x12,
    0x1c, 0x0a, 0x18, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x5f, 0x52, 0x45, 0x4d,
    0x4f, 0x56, 0x45, 0x5f, 0x47, 0x45, 0x53, 0x54, 0x55, 0x52, 0x45, 0x10, 0x03, 0x12, 0x21, 0x0a,
    0x1d, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x5f, 0x52, 0x45, 0x4d, 0x4f, 0x56,
    0x45, 0x5f, 0x41, 0x4c, 0x4c, 0x5f, 0x47, 0x45, 0x53, 0x54, 0x55, 0x52, 0x45, 0x53, 0x10, 0x04,
    0x12, 0x1a, 0x0a, 0x16, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x5f, 0x46, 0x41,
    0x44, 0x45, 0x5f, 0x47, 0x45, 0x53, 0x54, 0x55, 0x52, 0x45, 0x10, 0x06, 0x2a, 0x85, 0x04, 0x0a,
    0x15, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d,
    0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x12, 0x26, 0x0a, 0x22, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50,
    0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f,
    0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x10, 0x00, 0x12, 0x26,
    0x0a, 0x22, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f,
    0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50,
    0x44, 0x41, 0x54, 0x45, 0x10, 0x01, 0x12, 0x2e, 0x0a, 0x2a, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50,
    0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f,
    0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x46, 0x4f, 0x52,
    0x57, 0x41, 0x52, 0x44, 0x10, 0x02, 0x12, 0x32, 0x0a, 0x2e, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50,
    0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f,
    0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x4f, 0x52, 0x49,
    0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x12, 0x2f, 0x0a, 0x2b, 0x44, 0x4f,
    0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41,
    0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45,
    0x5f, 0x46, 0x41, 0x4c, 0x4c, 0x42, 0x41, 0x43, 0x4b, 0x10, 0x04, 0x12, 0x2a, 0x0a, 0x26, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e,
    0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54,
    0x45, 0x5f, 0x45, 0x4e, 0x54, 0x10, 0x05, 0x12, 0x2d, 0x0a, 0x29, 0x44, 0x4f, 0x54, 0x41, 0x5f,
    0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52,
    0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x4f, 0x46,
    0x46, 0x53, 0x45, 0x54, 0x10, 0x06, 0x12, 0x27, 0x0a, 0x23, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50,
    0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f,
    0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x44, 0x45, 0x53, 0x54, 0x52, 0x4f, 0x59, 0x10, 0x07, 0x12,
    0x31, 0x0a, 0x2d, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45,
    0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x44,
    0x45, 0x53, 0x54, 0x52, 0x4f, 0x59, 0x5f, 0x49, 0x4e, 0x56, 0x4f, 0x4c, 0x56, 0x49, 0x4e, 0x47,
    0x10, 0x08, 0x12, 0x27, 0x0a, 0x23, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49,
    0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e,
    0x54, 0x5f, 0x52, 0x45, 0x4c, 0x45, 0x41, 0x53, 0x45, 0x10, 0x09, 0x12, 0x27, 0x0a, 0x23, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e,
    0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x4c, 0x41, 0x54, 0x45, 0x4e,
    0x43, 0x59, 0x10, 0x0a, 0x2a, 0xb2, 0x02, 0x0a, 0x13, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x4f, 0x56,
    0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x12, 0x17, 0x0a, 0x13,
    0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x5f, 0x47,
    0x4f, 0x4c, 0x44, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x13, 0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41,
    0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x5f, 0x44, 0x45, 0x4e, 0x59, 0x10, 0x01, 0x12, 0x1b,
    0x0a, 0x17, 0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54,
    0x5f, 0x43, 0x52, 0x49, 0x54, 0x49, 0x43, 0x41, 0x4c, 0x10, 0x02, 0x12, 0x15, 0x0a, 0x11, 0x4f,
    0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x5f, 0x58, 0x50,
    0x10, 0x03, 0x12, 0x25, 0x0a, 0x21, 0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41,
    0x4c, 0x45, 0x52, 0x54, 0x5f, 0x42, 0x4f, 0x4e, 0x55, 0x53, 0x5f, 0x53, 0x50, 0x45, 0x4c, 0x4c,
    0x5f, 0x44, 0x41, 0x4d, 0x41, 0x47, 0x45, 0x10, 0x04, 0x12, 0x17, 0x0a, 0x13, 0x4f, 0x56, 0x45,
    0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x5f, 0x4d, 0x49, 0x53, 0x53,
    0x10, 0x05, 0x12, 0x19, 0x0a, 0x15, 0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41,
    0x4c, 0x45, 0x52, 0x54, 0x5f, 0x44, 0x41, 0x4d, 0x41, 0x47, 0x45, 0x10, 0x06, 0x12, 0x18, 0x0a,
    0x14, 0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x5f,
    0x45, 0x56, 0x41, 0x44, 0x45, 0x10, 0x07, 0x12, 0x18, 0x0a, 0x14, 0x4f, 0x56, 0x45, 0x52, 0x48,
    0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c, 0x45, 0x52, 0x54, 0x5f, 0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x10,
    0x08, 0x12, 0x26, 0x0a, 0x22, 0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x4c,
    0x45, 0x52, 0x54, 0x5f, 0x42, 0x4f, 0x4e, 0x55, 0x53, 0x5f, 0x50, 0x4f, 0x49, 0x53, 0x4f, 0x4e,
    0x5f, 0x44, 0x41, 0x4d, 0x41, 0x47, 0x45, 0x10, 0x09, 0x42, 0x05, 0x48, 0x01, 0x80, 0x01, 0x00,
    0x4a, 0xf3, 0x8f, 0x01, 0x0a, 0x07, 0x12, 0x05, 0x1e, 0x00, 0x98, 0x04, 0x01, 0x0a, 0x08, 0x0a,
    0x01, 0x08, 0x12, 0x03, 0x1e, 0x00, 0x1c, 0x0a, 0x37, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12,
    0x03, 0x1e, 0x00, 0x1c, 0x1a, 0x2a, 0x20, 0x57, 0x65, 0x20, 0x63, 0x61, 0x72, 0x65, 0x20, 0x6d,
    0x6f, 0x72, 0x65, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x73, 0x70, 0x65, 0x65, 0x64, 0x20,
    0x74, 0x68, 0x61, 0x6e, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x0d, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x1e, 0x07, 0x13, 0x0a, 0x0d,
    0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x1e, 0x07, 0x13, 0x0a, 0x0e, 0x0a,
    0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x1e, 0x07, 0x13, 0x0a, 0x0c, 0x0a,
    0x05, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x03, 0x1e, 0x16, 0x1b, 0x0a, 0x08, 0x0a, 0x01, 0x08,
    0x12, 0x03, 0x21, 0x00, 0x23, 0x0a, 0x41, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x01, 0x12, 0x03, 0x21,
    0x00, 0x23, 0x1a, 0x34, 0x20, 0x57, 0x65, 0x20, 0x64, 0x6f, 0x6e, 0x27, 0x74, 0x20, 0x75, 0x73,
    0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x67, 0x65,
    0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x0d, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01,
    0x02, 0x12, 0x03, 0x21, 0x07, 0x1a, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00,
    0x12, 0x03, 0x21, 0x07, 0x1a, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x21, 0x07, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x03, 0x12, 0x03,
    0x21, 0x1d, 0x22, 0x0a, 0x09, 0x0a, 0x02, 0x03, 0x00, 0x12, 0x03, 0x3a, 0x07, 0x29, 0x0a, 0x22,
    0x0a, 0x02, 0x03, 0x01, 0x12, 0x03, 0x3d, 0x07, 0x1a, 0x1a, 0x17, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x43, 0x4d, 0x73, 0x67, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e,
    0x0d, 0x0a, 0x0a, 0x1a, 0x0a, 0x02, 0x03, 0x02, 0x12, 0x03, 0x40, 0x07, 0x1a, 0x1a, 0x0f, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x0d, 0x0a, 0x0a, 0x44,
    0x0a, 0x02, 0x03, 0x03, 0x12, 0x03, 0x43, 0x07, 0x22, 0x1a, 0x39, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65,
    0x64, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x73, 0x0d, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x00, 0x12, 0x04, 0x49, 0x00, 0x69, 0x01,
    0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01, 0x12, 0x03, 0x49, 0x05, 0x16, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x4b, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x4b, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x02,
    0x12, 0x03, 0x4b, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x01, 0x12, 0x03, 0x4c,
    0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x4c, 0x08, 0x1b,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x4c, 0x3b, 0x3d, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12, 0x03, 0x4d, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x4d, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x02, 0x02, 0x12, 0x03, 0x4d, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x03, 0x12,
    0x03, 0x4e, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x4e,
    0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x02, 0x12, 0x03, 0x4e, 0x33, 0x35,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x04, 0x12, 0x03, 0x4f, 0x08, 0x3e, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x4f, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x4f, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02,
    0x05, 0x12, 0x03, 0x50, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x05, 0x01, 0x12,
    0x03, 0x50, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x05, 0x02, 0x12, 0x03, 0x50,
    0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x06, 0x12, 0x03, 0x51, 0x08, 0x36, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03, 0x51, 0x08, 0x26, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x51, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x00, 0x02, 0x07, 0x12, 0x03, 0x52, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x07,
    0x01, 0x12, 0x03, 0x52, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x07, 0x02, 0x12,
    0x03, 0x52, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x08, 0x12, 0x03, 0x53, 0x08,
    0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x01, 0x12, 0x03, 0x53, 0x08, 0x28, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x02, 0x12, 0x03, 0x53, 0x33, 0x35, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x00, 0x02, 0x09, 0x12, 0x03, 0x54, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x09, 0x01, 0x12, 0x03, 0x54, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x09,
    0x02, 0x12, 0x03, 0x54, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0a, 0x12, 0x03,
    0x55, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x03, 0x55, 0x08,
    0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0a, 0x02, 0x12, 0x03, 0x55, 0x33, 0x35, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0b, 0x12, 0x03, 0x56, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x03, 0x56, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x0b, 0x02, 0x12, 0x03, 0x56, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0c,
    0x12, 0x03, 0x57, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0c, 0x01, 0x12, 0x03,
    0x57, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0c, 0x02, 0x12, 0x03, 0x57, 0x3b,
    0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0d, 0x12, 0x03, 0x58, 0x08, 0x46, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x03, 0x58, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x0d, 0x02, 0x12, 0x03, 0x58, 0x43, 0x45, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00,
    0x02, 0x0e, 0x12, 0x03, 0x59, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0e, 0x01,
    0x12, 0x03, 0x59, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0e, 0x02, 0x12, 0x03,
    0x59, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0f, 0x12, 0x03, 0x5a, 0x08, 0x36,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0f, 0x01, 0x12, 0x03, 0x5a, 0x08, 0x21, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x0f, 0x02, 0x12, 0x03, 0x5a, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x10, 0x12, 0x03, 0x5b, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x10, 0x01, 0x12, 0x03, 0x5b, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x10, 0x02,
    0x12, 0x03, 0x5b, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x11, 0x12, 0x03, 0x5c,
    0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x11, 0x01, 0x12, 0x03, 0x5c, 0x08, 0x20,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x11, 0x02, 0x12, 0x03, 0x5c, 0x33, 0x35, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x12, 0x12, 0x03, 0x5d, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x12, 0x01, 0x12, 0x03, 0x5d, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x12, 0x02, 0x12, 0x03, 0x5d, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x13, 0x12,
    0x03, 0x5e, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x13, 0x01, 0x12, 0x03, 0x5e,
    0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x13, 0x02, 0x12, 0x03, 0x5e, 0x33, 0x35,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x14, 0x12, 0x03, 0x5f, 0x08, 0x3e, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x14, 0x01, 0x12, 0x03, 0x5f, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x14, 0x02, 0x12, 0x03, 0x5f, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02,
    0x15, 0x12, 0x03, 0x60, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x15, 0x01, 0x12,
    0x03, 0x60, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x15, 0x02, 0x12, 0x03, 0x60,
    0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x16, 0x12, 0x03, 0x61, 0x08, 0x3e, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x16, 0x01, 0x12, 0x03, 0x61, 0x08, 0x1f, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x16, 0x02, 0x12, 0x03, 0x61, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x00, 0x02, 0x17, 0x12, 0x03, 0x62, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x17,
    0x01, 0x12, 0x03, 0x62, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x17, 0x02, 0x12,
    0x03, 0x62, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x18, 0x12, 0x03, 0x63, 0x08,
    0x3e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x18, 0x01, 0x12, 0x03, 0x63, 0x08, 0x1f, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x18, 0x02, 0x12, 0x03, 0x63, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x00, 0x02, 0x19, 0x12, 0x03, 0x64, 0x08, 0x46, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x19, 0x01, 0x12, 0x03, 0x64, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x19,
    0x02, 0x12, 0x03, 0x64, 0x43, 0x45, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x1a, 0x12, 0x03,
    0x65, 0x08, 0x46, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1a, 0x01, 0x12, 0x03, 0x65, 0x08,
    0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1a, 0x02, 0x12, 0x03, 0x65, 0x43, 0x45, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x1b, 0x12, 0x03, 0x66, 0x08, 0x3e, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x1b, 0x01, 0x12, 0x03, 0x66, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x1b, 0x02, 0x12, 0x03, 0x66, 0x3b, 0x3d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x1c,
    0x12, 0x03, 0x67, 0x08, 0x46, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1c, 0x01, 0x12, 0x03,
    0x67, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x1c, 0x02, 0x12, 0x03, 0x67, 0x43,
    0x45, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x1d, 0x12, 0x03, 0x68, 0x08, 0x46, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x1d, 0x01, 0x12, 0x03, 0x68, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x1d, 0x02, 0x12, 0x03, 0x68, 0x43, 0x45, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x00,
    0x12, 0x04, 0x6d, 0x00, 0x70, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x6d,
    0x08, 0x20, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x6f, 0x08, 0x24, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x6f, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x6f, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x6f, 0x18, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x00, 0x03, 0x12, 0x03, 0x6f, 0x22, 0x23, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x72,
    0x00, 0x75, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x72, 0x08, 0x19, 0x0a,
    0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03, 0x74, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x74, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01,
    0x02, 0x00, 0x05, 0x12, 0x03, 0x74, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x74, 0x18, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12,
    0x03, 0x74, 0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x02, 0x05, 0x01, 0x12, 0x05, 0x77, 0x00, 0xab, 0x01,
    0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x01, 0x01, 0x12, 0x03, 0x77, 0x05, 0x16, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x01, 0x02, 0x00, 0x12, 0x03, 0x79, 0x08, 0x55, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x79, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00,
    0x02, 0x12, 0x03, 0x79, 0x52, 0x54, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x01, 0x12, 0x03,
    0x7b, 0x08, 0x54, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x7b, 0x08,
    0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x02, 0x12, 0x03, 0x7b, 0x52, 0x53, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x02, 0x12, 0x03, 0x7c, 0x08, 0x54, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x02, 0x01, 0x12, 0x03, 0x7c, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01,
    0x02, 0x02, 0x02, 0x12, 0x03, 0x7c, 0x52, 0x53, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x03,
    0x12, 0x03, 0x7d, 0x08, 0x4c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x01, 0x12, 0x03,
    0x7d, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x02, 0x12, 0x03, 0x7d, 0x4a,
    0x4b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x04, 0x12, 0x03, 0x7e, 0x08, 0x54, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x01, 0x02, 0x04, 0x01, 0x12, 0x03, 0x7e, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x04, 0x02, 0x12, 0x03, 0x7e, 0x52, 0x53, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01,
    0x02, 0x05, 0x12, 0x03, 0x7f, 0x08, 0x54, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05, 0x01,
    0x12, 0x03, 0x7f, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05, 0x02, 0x12, 0x03,
    0x7f, 0x52, 0x53, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x06, 0x12, 0x04, 0x80, 0x01, 0x08,
    0x54, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0x80, 0x01, 0x08, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06, 0x02, 0x12, 0x04, 0x80, 0x01, 0x52, 0x53, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x07, 0x12, 0x04, 0x81, 0x01, 0x08, 0x54, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x07, 0x01, 0x12, 0x04, 0x81, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x07, 0x02, 0x12, 0x04, 0x81, 0x01, 0x52, 0x53, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x08, 0x12, 0x04, 0x82, 0x01, 0x08, 0x54, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x08, 0x01, 0x12, 0x04, 0x82, 0x01, 0x08, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x08,
    0x02, 0x12, 0x04, 0x82, 0x01, 0x52, 0x53, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x09, 0x12,
    0x04, 0x83, 0x01, 0x08, 0x54, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x09, 0x01, 0x12, 0x04,
    0x83, 0x01, 0x08, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x09, 0x02, 0x12, 0x04, 0x83,
    0x01, 0x52, 0x53, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x0a, 0x12, 0x04, 0x84, 0x01, 0x08,
    0x54, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x84, 0x01, 0x08, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x0a, 0x02, 0x12, 0x04, 0x84, 0x01, 0x52, 0x53, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x0b, 0x12, 0x04, 0x85, 0x01, 0x08, 0x4d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x0b, 0x01, 0x12, 0x04, 0x85, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x0b, 0x02, 0x12, 0x04, 0x85, 0x01, 0x4a, 0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x0c, 0x12, 0x04, 0x86, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x0c, 0x01, 0x12, 0x04, 0x86, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x0c,
    0x02, 0x12, 0x04, 0x86, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x0d, 0x12,
    0x04, 0x87, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x0d, 0x01, 0x12, 0x04,
    0x87, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x0d, 0x02, 0x12, 0x04, 0x87,
    0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x0e, 0x12, 0x04, 0x88, 0x01, 0x08,
    0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x0e, 0x01, 0x12, 0x04, 0x88, 0x01, 0x08, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x0e, 0x02, 0x12, 0x04, 0x88, 0x01, 0x4a, 0x4c, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x0f, 0x12, 0x04, 0x89, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x0f, 0x01, 0x12, 0x04, 0x89, 0x01, 0x08, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x0f, 0x02, 0x12, 0x04, 0x89, 0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x10, 0x12, 0x04, 0x8a, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x10, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x10,
    0x02, 0x12, 0x04, 0x8a, 0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x11, 0x12,
    0x04, 0x8b, 0x01, 0x08, 0x45, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x11, 0x01, 0x12, 0x04,
    0x8b, 0x01, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x11, 0x02, 0x12, 0x04, 0x8b,
    0x01, 0x42, 0x44, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x12, 0x12, 0x04, 0x8c, 0x01, 0x08,
    0x45, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x12, 0x01, 0x12, 0x04, 0x8c, 0x01, 0x08, 0x2e,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x12, 0x02, 0x12, 0x04, 0x8c, 0x01, 0x42, 0x44, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x13, 0x12, 0x04, 0x8d, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x13, 0x01, 0x12, 0x04, 0x8d, 0x01, 0x08, 0x35, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x13, 0x02, 0x12, 0x04, 0x8d, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x14, 0x12, 0x04, 0x8e, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x14, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x14,
    0x02, 0x12, 0x04, 0x8e, 0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x15, 0x12,
    0x04, 0x8f, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x15, 0x01, 0x12, 0x04,
    0x8f, 0x01, 0x08, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x15, 0x02, 0x12, 0x04, 0x8f,
    0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x16, 0x12, 0x04, 0x90, 0x01, 0x08,
    0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x16, 0x01, 0x12, 0x04, 0x90, 0x01, 0x08, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x16, 0x02, 0x12, 0x04, 0x90, 0x01, 0x52, 0x54, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x17, 0x12, 0x04, 0x91, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x17, 0x01, 0x12, 0x04, 0x91, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x17, 0x02, 0x12, 0x04, 0x91, 0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x18, 0x12, 0x04, 0x92, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x18, 0x01, 0x12, 0x04, 0x92, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x18,
    0x02, 0x12, 0x04, 0x92, 0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x19, 0x12,
    0x04, 0x93, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x19, 0x01, 0x12, 0x04,
    0x93, 0x01, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x19, 0x02, 0x12, 0x04, 0x93,
    0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x1a, 0x12, 0x04, 0x94, 0x01, 0x08,
    0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x1a, 0x01, 0x12, 0x04, 0x94, 0x01, 0x08, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x1a, 0x02, 0x12, 0x04, 0x94, 0x01, 0x52, 0x54, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x1b, 0x12, 0x04, 0x95, 0x01, 0x08, 0x4d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x1b, 0x01, 0x12, 0x04, 0x95, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x1b, 0x02, 0x12, 0x04, 0x95, 0x01, 0x4a, 0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x1c, 0x12, 0x04, 0x96, 0x01, 0x08, 0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x1c, 0x01, 0x12, 0x04, 0x96, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x1c,
    0x02, 0x12, 0x04, 0x96, 0x01, 0x4a, 0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x1d, 0x12,
    0x04, 0x97, 0x01, 0x08, 0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x1d, 0x01, 0x12, 0x04,
    0x97, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x1d, 0x02, 0x12, 0x04, 0x97,
    0x01, 0x4a, 0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x1e, 0x12, 0x04, 0x98, 0x01, 0x08,
    0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x1e, 0x01, 0x12, 0x04, 0x98, 0x01, 0x08, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x1e, 0x02, 0x12, 0x04, 0x98, 0x01, 0x4a, 0x4c, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x1f, 0x12, 0x04, 0x99, 0x01, 0x08, 0x4d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x1f, 0x01, 0x12, 0x04, 0x99, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x1f, 0x02, 0x12, 0x04, 0x99, 0x01, 0x4a, 0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x20, 0x12, 0x04, 0x9a, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x20, 0x01, 0x12, 0x04, 0x9a, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x20,
    0x02, 0x12, 0x04, 0x9a, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x21, 0x12,
    0x04, 0x9b, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x21, 0x01, 0x12, 0x04,
    0x9b, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x21, 0x02, 0x12, 0x04, 0x9b,
    0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x22, 0x12, 0x04, 0x9c, 0x01, 0x08,
    0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x22, 0x01, 0x12, 0x04, 0x9c, 0x01, 0x08, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x22, 0x02, 0x12, 0x04, 0x9c, 0x01, 0x3a, 0x3c, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x23, 0x12, 0x04, 0x9d, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x23, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x23, 0x02, 0x12, 0x04, 0x9d, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x24, 0x12, 0x04, 0x9e, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x24, 0x01, 0x12, 0x04, 0x9e, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x24,
    0x02, 0x12, 0x04, 0x9e, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x25, 0x12,
    0x04, 0x9f, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x25, 0x01, 0x12, 0x04,
    0x9f, 0x01, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x25, 0x02, 0x12, 0x04, 0x9f,
    0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x26, 0x12, 0x04, 0xa0, 0x01, 0x08,
    0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x26, 0x01, 0x12, 0x04, 0xa0, 0x01, 0x08, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x26, 0x02, 0x12, 0x04, 0xa0, 0x01, 0x3a, 0x3c, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x27, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x27, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x27, 0x02, 0x12, 0x04, 0xa1, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x28, 0x12, 0x04, 0xa2, 0x01, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x28, 0x01, 0x12, 0x04, 0xa2, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x28,
    0x02, 0x12, 0x04, 0xa2, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x29, 0x12,
    0x04, 0xa3, 0x01, 0x08, 0x45, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x29, 0x01, 0x12, 0x04,
    0xa3, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x29, 0x02, 0x12, 0x04, 0xa3,
    0x01, 0x42, 0x44, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x2a, 0x12, 0x04, 0xa4, 0x01, 0x08,
    0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x2a, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x08, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x2a, 0x02, 0x12, 0x04, 0xa4, 0x01, 0x4a, 0x4c, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x2b, 0x12, 0x04, 0xa5, 0x01, 0x08, 0x45, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x2b, 0x01, 0x12, 0x04, 0xa5, 0x01, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x2b, 0x02, 0x12, 0x04, 0xa5, 0x01, 0x42, 0x44, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x2c, 0x12, 0x04, 0xa6, 0x01, 0x08, 0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x2c, 0x01, 0x12, 0x04, 0xa6, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x2c,
    0x02, 0x12, 0x04, 0xa6, 0x01, 0x4a, 0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x2d, 0x12,
    0x04, 0xa7, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x2d, 0x01, 0x12, 0x04,
    0xa7, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x2d, 0x02, 0x12, 0x04, 0xa7,
    0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x2e, 0x12, 0x04, 0xa8, 0x01, 0x08,
    0x5d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x2e, 0x01, 0x12, 0x04, 0xa8, 0x01, 0x08, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x2e, 0x02, 0x12, 0x04, 0xa8, 0x01, 0x5a, 0x5c, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x2f, 0x12, 0x04, 0xa9, 0x01, 0x08, 0x5d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x2f, 0x01, 0x12, 0x04, 0xa9, 0x01, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x2f, 0x02, 0x12, 0x04, 0xa9, 0x01, 0x5a, 0x5c, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x30, 0x12, 0x04, 0xaa, 0x01, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x30, 0x01, 0x12, 0x04, 0xaa, 0x01, 0x08, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x30,
    0x02, 0x12, 0x04, 0xaa, 0x01, 0x52, 0x54, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x06, 0xad,
    0x01, 0x00, 0xba, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x04, 0xad, 0x01,
    0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x01, 0x08, 0x2c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xaf, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0xaf, 0x01, 0x11, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x01, 0x23, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaf, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xb1, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xb1, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xb1, 0x01, 0x20, 0x21, 0x0a, 0x14, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x02, 0x12, 0x04,
    0xb4, 0x01, 0x08, 0x38, 0x1a, 0x06, 0x20, 0x75, 0x67, 0x68, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb4, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb4, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xb4, 0x01, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xb4, 0x01, 0x25, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02,
    0x08, 0x12, 0x04, 0xb4, 0x01, 0x27, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x07,
    0x12, 0x04, 0xb4, 0x01, 0x33, 0x35, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xb5, 0x01, 0x08, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb5,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb5, 0x01,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x18,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb5, 0x01, 0x25, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x08, 0x12, 0x04, 0xb5, 0x01, 0x27, 0x37, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x07, 0x12, 0x04, 0xb5, 0x01, 0x33, 0x35, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x38, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb6, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xb6, 0x01, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xb6, 0x01, 0x25, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04,
    0x08, 0x12, 0x04, 0xb6, 0x01, 0x27, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x07,
    0x12, 0x04, 0xb6, 0x01, 0x33, 0x35, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x05, 0x12, 0x04,
    0xb7, 0x01, 0x08, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x04, 0x12, 0x04, 0xb7,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x05, 0x12, 0x04, 0xb7, 0x01,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x01, 0x12, 0x04, 0xb7, 0x01, 0x18,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x03, 0x12, 0x04, 0xb7, 0x01, 0x25, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x08, 0x12, 0x04, 0xb7, 0x01, 0x27, 0x37, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x07, 0x12, 0x04, 0xb7, 0x01, 0x33, 0x35, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb8, 0x01, 0x08, 0x38, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x06, 0x05, 0x12, 0x04, 0xb8, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x06, 0x01, 0x12, 0x04, 0xb8, 0x01, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x06, 0x03, 0x12, 0x04, 0xb8, 0x01, 0x25, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x06,
    0x08, 0x12, 0x04, 0xb8, 0x01, 0x27, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x06, 0x07,
    0x12, 0x04, 0xb8, 0x01, 0x33, 0x35, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x07, 0x12, 0x04,
    0xb9, 0x01, 0x08, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x04, 0x12, 0x04, 0xb9,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x05, 0x12, 0x04, 0xb9, 0x01,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x01, 0x12, 0x04, 0xb9, 0x01, 0x18,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x03, 0x12, 0x04, 0xb9, 0x01, 0x25, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x08, 0x12, 0x04, 0xb9, 0x01, 0x27, 0x37, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x07, 0x12, 0x04, 0xb9, 0x01, 0x33, 0x35, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x03, 0x12, 0x06, 0xbc, 0x01, 0x00, 0xc7, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x03, 0x01, 0x12, 0x04, 0xbc, 0x01, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02,
    0x00, 0x12, 0x04, 0xbe, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xbe, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xbe, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xbe, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbe,
    0x01, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x08,
    0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbf, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x18, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbf, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x03, 0x02, 0x02, 0x12, 0x04, 0xc0, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc0, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xc0, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xc0, 0x01, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xc0, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x03, 0x12,
    0x04, 0xc1, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xc1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc1,
    0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc1, 0x01,
    0x16, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc1, 0x01, 0x2a,
    0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x04, 0x12, 0x04, 0xc2, 0x01, 0x08, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc2, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x05, 0x12, 0x04, 0xc2, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc2, 0x01, 0x16, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc2, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x03, 0x02, 0x05, 0x12, 0x04, 0xc3, 0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x05, 0x04, 0x12, 0x04, 0xc3, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x05,
    0x05, 0x12, 0x04, 0xc3, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xc3, 0x01, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x05, 0x03, 0x12,
    0x04, 0xc3, 0x01, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x06, 0x12, 0x04, 0xc4,
    0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04, 0x12, 0x04, 0xc4, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x05, 0x12, 0x04, 0xc4, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x01, 0x12, 0x04, 0xc4, 0x01, 0x17, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x03, 0x12, 0x04, 0xc4, 0x01, 0x1f, 0x20, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x07, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x07, 0x04, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x07, 0x05, 0x12, 0x04, 0xc5, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x07, 0x01, 0x12, 0x04, 0xc5, 0x01, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x07, 0x03, 0x12, 0x04, 0xc5, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02,
    0x08, 0x12, 0x04, 0xc6, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x08, 0x04,
    0x12, 0x04, 0xc6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x08, 0x05, 0x12,
    0x04, 0xc6, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xc6, 0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x08, 0x03, 0x12, 0x04, 0xc6,
    0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x06, 0xc9, 0x01, 0x00, 0xcb, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x04, 0x01, 0x12, 0x04, 0xc9, 0x01, 0x08, 0x27, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x05, 0x12, 0x06, 0xcd, 0x01, 0x00, 0xd3, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x05, 0x01, 0x12, 0x04, 0xcd, 0x01, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02,
    0x00, 0x12, 0x04, 0xcf, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xcf, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xcf, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xcf, 0x01, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcf,
    0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd0, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd0, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x18, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd0, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x05, 0x02, 0x02, 0x12, 0x04, 0xd1, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xd1, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xd1, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xd1, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x03, 0x12,
    0x04, 0xd2, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xd2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x05, 0x12, 0x04, 0xd2,
    0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd2, 0x01,
    0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd2, 0x01, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x06, 0x12, 0x06, 0xd5, 0x01, 0x00, 0xdb, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12, 0x04, 0xd5, 0x01, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x06, 0x02, 0x00, 0x12, 0x04, 0xd7, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xd7, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xd7, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xd7, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xd7, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x01, 0x12, 0x04,
    0xd8, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd8,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd8, 0x01,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x17,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd8, 0x01, 0x1e, 0x1f,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x02, 0x12, 0x04, 0xd9, 0x01, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x02, 0x06, 0x12, 0x04, 0xd9, 0x01, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd9, 0x01, 0x1e, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd9, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06,
    0x02, 0x03, 0x12, 0x04, 0xda, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xda, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xda, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xda, 0x01, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xda, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x07, 0x12, 0x06, 0xdd, 0x01, 0x00, 0xec,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x04, 0xdd, 0x01, 0x08, 0x24, 0x0a,
    0x0e, 0x0a, 0x04, 0x04, 0x07, 0x03, 0x00, 0x12, 0x06, 0xdf, 0x01, 0x08, 0xea, 0x01, 0x09, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x07, 0x03, 0x00, 0x01, 0x12, 0x04, 0xdf, 0x01, 0x10, 0x18, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x07, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xe1, 0x01, 0x10, 0x2d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe1, 0x01, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe1, 0x01, 0x19, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe1, 0x01, 0x20,
    0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe1, 0x01,
    0x2b, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x07, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xe2, 0x01,
    0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe2,
    0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xe2, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xe2, 0x01, 0x1f, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xe2, 0x01, 0x2e, 0x2f, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x07, 0x03, 0x00, 0x03, 0x00,
    0x12, 0x06, 0xe4, 0x01, 0x10, 0xe8, 0x01, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00,
    0x03, 0x00, 0x01, 0x12, 0x04, 0xe4, 0x01, 0x18, 0x1f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x07, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xe6, 0x01, 0x18, 0x34, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x07, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe6, 0x01, 0x18, 0x20, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x07, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe6, 0x01, 0x21,
    0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x07, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xe6, 0x01, 0x28, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x07, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xe6, 0x01, 0x32, 0x33, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x07, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xe7, 0x01, 0x18, 0x32, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x07, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe7, 0x01, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x07, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe7, 0x01, 0x21, 0x26, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x07, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe7, 0x01,
    0x27, 0x2d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x07, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xe7, 0x01, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x07, 0x03, 0x00, 0x02, 0x02, 0x12,
    0x04, 0xe9, 0x01, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xe9, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02, 0x02,
    0x06, 0x12, 0x04, 0xe9, 0x01, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xe9, 0x01, 0x21, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x03, 0x00,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xe9, 0x01, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x07, 0x02,
    0x00, 0x12, 0x04, 0xeb, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xeb, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x06, 0x12,
    0x04, 0xeb, 0x01, 0x11, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xeb, 0x01, 0x1a, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x03, 0x12, 0x04, 0xeb,
    0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0xee, 0x01, 0x00, 0xf2, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x04, 0xee, 0x01, 0x08, 0x25, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x08, 0x02, 0x00, 0x12, 0x04, 0xf0, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf0, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf0, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xf0, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xf0, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x01,
    0x12, 0x04, 0xf1, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xf1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xf1, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf1,
    0x01, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf1, 0x01,
    0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0xf4, 0x01, 0x00, 0xf8, 0x01, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x04, 0xf4, 0x01, 0x08, 0x29, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x09, 0x02, 0x00, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xf6, 0x01, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xf6, 0x01, 0x1c, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xf6, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x01, 0x12,
    0x04, 0xf7, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xf7, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf7,
    0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf7, 0x01,
    0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf7, 0x01, 0x22,
    0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0xfa, 0x01, 0x00, 0xfe, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0xfa, 0x01, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0a, 0x02, 0x00, 0x12, 0x04, 0xfc, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xfc, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xfc, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xfc, 0x01, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xfc, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x01, 0x12, 0x04,
    0xfd, 0x01, 0x08, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xfd,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x06, 0x12, 0x04, 0xfd, 0x01,
    0x11, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfd, 0x01, 0x27,
    0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xfd, 0x01, 0x37, 0x38,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06, 0x80, 0x02, 0x00, 0x87, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12, 0x04, 0x80, 0x02, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0b, 0x02, 0x00, 0x12, 0x04, 0x82, 0x02, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x82, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x82, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x82, 0x02, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x82, 0x02, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12, 0x04, 0x83,
    0x02, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04, 0x83, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x05, 0x12, 0x04, 0x83, 0x02, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0x83, 0x02, 0x17, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x03, 0x12, 0x04, 0x83, 0x02, 0x27, 0x28, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x02, 0x12, 0x04, 0x84, 0x02, 0x08, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x02, 0x04, 0x12, 0x04, 0x84, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x02, 0x05, 0x12, 0x04, 0x84, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x02, 0x01, 0x12, 0x04, 0x84, 0x02, 0x17, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x02, 0x03, 0x12, 0x04, 0x84, 0x02, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02,
    0x03, 0x12, 0x04, 0x85, 0x02, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x04,
    0x12, 0x04, 0x85, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x05, 0x12,
    0x04, 0x85, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x01, 0x12, 0x04,
    0x85, 0x02, 0x17, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x03, 0x12, 0x04, 0x85,
    0x02, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x04, 0x12, 0x04, 0x86, 0x02, 0x08,
    0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x04, 0x12, 0x04, 0x86, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x05, 0x12, 0x04, 0x86, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x01, 0x12, 0x04, 0x86, 0x02, 0x17, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x03, 0x12, 0x04, 0x86, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x0c, 0x12, 0x06, 0x89, 0x02, 0x00, 0x8d, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x0c, 0x01, 0x12, 0x04, 0x89, 0x02, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x00,
    0x12, 0x04, 0x8b, 0x02, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x8b, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x05, 0x12, 0x04,
    0x8b, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8b,
    0x02, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8b, 0x02,
    0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x01, 0x12, 0x04, 0x8c, 0x02, 0x08, 0x2e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8c, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x06, 0x12, 0x04, 0x8c, 0x02, 0x11, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8c, 0x02, 0x22, 0x29, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8c, 0x02, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x0d, 0x12, 0x06, 0x8f, 0x02, 0x00, 0x95, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0d,
    0x01, 0x12, 0x04, 0x8f, 0x02, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x00, 0x12,
    0x04, 0x91, 0x02, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x91, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x06, 0x12, 0x04, 0x91,
    0x02, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x01, 0x12, 0x04, 0x91, 0x02,
    0x1c, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03, 0x12, 0x04, 0x91, 0x02, 0x27,
    0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04, 0x92, 0x02, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x04, 0x12, 0x04, 0x92, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x05, 0x12, 0x04, 0x92, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0x92, 0x02, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x01, 0x03, 0x12, 0x04, 0x92, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0d, 0x02, 0x02, 0x12, 0x04, 0x93, 0x02, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x93, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02,
    0x05, 0x12, 0x04, 0x93, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x01,
    0x12, 0x04, 0x93, 0x02, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x03, 0x12,
    0x04, 0x93, 0x02, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x03, 0x12, 0x04, 0x94,
    0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x04, 0x12, 0x04, 0x94, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x05, 0x12, 0x04, 0x94, 0x02, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x01, 0x12, 0x04, 0x94, 0x02, 0x17, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x03, 0x12, 0x04, 0x94, 0x02, 0x22, 0x23, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06, 0x97, 0x02, 0x00, 0x9f, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x0e, 0x01, 0x12, 0x04, 0x97, 0x02, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e,
    0x02, 0x00, 0x12, 0x04, 0x99, 0x02, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x99, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x06,
    0x12, 0x04, 0x99, 0x02, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x99, 0x02, 0x1c, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x99, 0x02, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x01, 0x12, 0x04, 0x9a, 0x02,
    0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9a, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x06, 0x12, 0x04, 0x9a, 0x02, 0x11, 0x1d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9a, 0x02, 0x1e, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9a, 0x02, 0x29, 0x2a, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0e, 0x02, 0x02, 0x12, 0x04, 0x9b, 0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9b, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9b, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x02, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02,
    0x02, 0x03, 0x12, 0x04, 0x9b, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x03,
    0x12, 0x04, 0x9c, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x04, 0x12,
    0x04, 0x9c, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x05, 0x12, 0x04,
    0x9c, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9c,
    0x02, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9c, 0x02,
    0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x04, 0x12, 0x04, 0x9d, 0x02, 0x08, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9d, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x04, 0x05, 0x12, 0x04, 0x9d, 0x02, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9d, 0x02, 0x17, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x04, 0x03, 0x12, 0x04, 0x9d, 0x02, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0e, 0x02, 0x05, 0x12, 0x04, 0x9e, 0x02, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x05, 0x04, 0x12, 0x04, 0x9e, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02,
    0x05, 0x05, 0x12, 0x04, 0x9e, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x05,
    0x01, 0x12, 0x04, 0x9e, 0x02, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x05, 0x03,
    0x12, 0x04, 0x9e, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0f, 0x12, 0x06, 0xa1, 0x02,
    0x00, 0xa4, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0xa1, 0x02, 0x08,
    0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x00, 0x12, 0x04, 0xa3, 0x02, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa3, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa3, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa3, 0x02, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa3, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x10, 0x12, 0x06, 0xa6, 0x02, 0x00, 0xa9, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x10, 0x01,
    0x12, 0x04, 0xa6, 0x02, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x00, 0x12, 0x04,
    0xa8, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa8,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa8, 0x02,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa8, 0x02, 0x17,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa8, 0x02, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0xab, 0x02, 0x00, 0xb0, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xab, 0x02, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x11, 0x02, 0x00, 0x12, 0x04, 0xad, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xad, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xad, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xad, 0x02, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xad, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x01, 0x12, 0x04, 0xae,
    0x02, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x04, 0x12, 0x04, 0xae, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x05, 0x12, 0x04, 0xae, 0x02, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x01, 0x12, 0x04, 0xae, 0x02, 0x17, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x03, 0x12, 0x04, 0xae, 0x02, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x02, 0x12, 0x04, 0xaf, 0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x02, 0x04, 0x12, 0x04, 0xaf, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x02, 0x05, 0x12, 0x04, 0xaf, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x02, 0x01, 0x12, 0x04, 0xaf, 0x02, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xaf, 0x02, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x12, 0x12,
    0x06, 0xb2, 0x02, 0x00, 0xb7, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x12, 0x01, 0x12, 0x04,
    0xb2, 0x02, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x00, 0x12, 0x04, 0xb4, 0x02,
    0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb4, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb4, 0x02, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb4, 0x02, 0x17, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb4, 0x02, 0x27, 0x28, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x01, 0x12, 0x04, 0xb5, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb5, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xb5, 0x02, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xb5, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x02,
    0x12, 0x04, 0xb6, 0x02, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xb6, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x06, 0x12, 0x04,
    0xb6, 0x02, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb6,
    0x02, 0x1c, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb6, 0x02,
    0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x13, 0x12, 0x06, 0xb9, 0x02, 0x00, 0xbc, 0x02, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01, 0x12, 0x04, 0xb9, 0x02, 0x08, 0x23, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x13, 0x02, 0x00, 0x12, 0x04, 0xbb, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x13, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbb, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xbb, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xbb, 0x02, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xbb, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x14, 0x12, 0x06, 0xbe,
    0x02, 0x00, 0xc1, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04, 0xbe, 0x02,
    0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x02, 0x08, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc0, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc0, 0x02, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc0, 0x02, 0x17, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc0, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x15, 0x12, 0x06, 0xc3, 0x02, 0x00, 0xc9, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x15,
    0x01, 0x12, 0x04, 0xc3, 0x02, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x00, 0x12,
    0x04, 0xc5, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xc5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc5,
    0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc5, 0x02,
    0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc5, 0x02, 0x22,
    0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x01, 0x12, 0x04, 0xc6, 0x02, 0x08, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc6, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc6, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x15, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc6, 0x02, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc6, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x15, 0x02, 0x02, 0x12, 0x04, 0xc7, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xc7, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xc7, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xc7, 0x02, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xc7, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x03, 0x12, 0x04, 0xc8,
    0x02, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc8, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc8, 0x02, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc8, 0x02, 0x17, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc8, 0x02, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x16, 0x12, 0x06, 0xcb, 0x02, 0x00, 0xce, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xcb, 0x02, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16,
    0x02, 0x00, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xcd, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xcd, 0x02, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xcd, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x02, 0x12, 0x06, 0xd0, 0x02, 0x00, 0xd8,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x02, 0x05, 0x18, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x00, 0x12, 0x04, 0xd2, 0x02, 0x08, 0x3c, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd2, 0x02, 0x08, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x00, 0x02, 0x12, 0x04, 0xd2, 0x02, 0x3a, 0x3b, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xd3, 0x02, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xd3, 0x02, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x01,
    0x02, 0x12, 0x04, 0xd3, 0x02, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x02, 0x12,
    0x04, 0xd4, 0x02, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xd4, 0x02, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x02, 0x12, 0x04, 0xd4,
    0x02, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd5, 0x02, 0x08,
    0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd5, 0x02, 0x08, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x03, 0x02, 0x12, 0x04, 0xd5, 0x02, 0x32, 0x33, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd6, 0x02, 0x08, 0x2c, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd6, 0x02, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x04, 0x02, 0x12, 0x04, 0xd6, 0x02, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x05, 0x01, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x05,
    0x02, 0x12, 0x04, 0xd7, 0x02, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x17, 0x12, 0x06, 0xda,
    0x02, 0x00, 0x90, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01, 0x12, 0x04, 0xda, 0x02,
    0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x00, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x32,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x06, 0x12, 0x04, 0xdc, 0x02, 0x11, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdc, 0x02, 0x25, 0x2d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdc, 0x02, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x17, 0x02, 0x01, 0x12, 0x04, 0xdd, 0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xdd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xdd, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xdd, 0x02, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xdd, 0x02, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x17, 0x03, 0x00, 0x12, 0x06,
    0xdf, 0x02, 0x08, 0xe5, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xdf, 0x02, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xe1, 0x02, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xe1, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xe1, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xe1, 0x02, 0x1f, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xe1, 0x02, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xe2, 0x02, 0x10, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe2, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe2, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe2, 0x02, 0x20, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe2, 0x02, 0x2b, 0x2c, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xe3, 0x02, 0x10, 0x32, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe3, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe3, 0x02, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe3, 0x02, 0x1f, 0x2d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe3, 0x02, 0x30,
    0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xe4, 0x02, 0x10,
    0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe4, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xe4,
    0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xe4, 0x02, 0x1f, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xe4, 0x02, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x02, 0x12, 0x04, 0xe7,
    0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe7, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x06, 0x12, 0x04, 0xe7, 0x02, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe7, 0x02, 0x18, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe7, 0x02, 0x21, 0x22, 0x0a,
    0x0e, 0x0a, 0x04, 0x04, 0x17, 0x03, 0x01, 0x12, 0x06, 0xe9, 0x02, 0x08, 0xec, 0x02, 0x09, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x03, 0x01, 0x01, 0x12, 0x04, 0xe9, 0x02, 0x10, 0x1a, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x17, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xeb, 0x02, 0x10, 0x39, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xeb, 0x02, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xeb, 0x02, 0x19, 0x1e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xeb, 0x02, 0x1f,
    0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xeb, 0x02,
    0x27, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0xeb,
    0x02, 0x29, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x01, 0x02, 0x00, 0x07, 0x12, 0x04,
    0xeb, 0x02, 0x34, 0x37, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x03, 0x12, 0x04, 0xee, 0x02,
    0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x04, 0x12, 0x04, 0xee, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x06, 0x12, 0x04, 0xee, 0x02, 0x11, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x01, 0x12, 0x04, 0xee, 0x02, 0x1c, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x03, 0x12, 0x04, 0xee, 0x02, 0x2a, 0x2b, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x17, 0x03, 0x02, 0x12, 0x06, 0xf0, 0x02, 0x08, 0xf6, 0x02, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x03, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x02, 0x10, 0x1a, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x17, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0xf2, 0x02, 0x10, 0x2f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf2, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0xf2, 0x02, 0x19, 0x21, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2, 0x02, 0x22, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf2, 0x02, 0x2d,
    0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf3, 0x02, 0x10,
    0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf3, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf3,
    0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xf3, 0x02, 0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xf3, 0x02, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x02, 0x02, 0x02, 0x12,
    0x04, 0xf4, 0x02, 0x10, 0x39, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xf4, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xf4, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xf4, 0x02, 0x1f, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xf4, 0x02, 0x29, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x02, 0x02, 0x02, 0x08, 0x12, 0x04, 0xf4, 0x02, 0x2b, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x02, 0x02, 0x02, 0x07, 0x12, 0x04, 0xf4, 0x02, 0x36, 0x37, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x17, 0x03, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf5, 0x02, 0x10, 0x3c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x02, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf5, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x02, 0x02, 0x03, 0x05, 0x12, 0x04, 0xf5, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf5, 0x02, 0x1f, 0x27, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf5, 0x02, 0x2a, 0x2b, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x03, 0x08, 0x12, 0x04, 0xf5, 0x02, 0x2c, 0x3b,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x02, 0x02, 0x03, 0x07, 0x12, 0x04, 0xf5, 0x02, 0x37,
    0x3a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x04, 0x12, 0x04, 0xf8, 0x02, 0x08, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf8, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x06, 0x12, 0x04, 0xf8, 0x02, 0x11, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x04, 0x01, 0x12, 0x04, 0xf8, 0x02, 0x1c, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x04, 0x03, 0x12, 0x04, 0xf8, 0x02, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x04, 0x04,
    0x17, 0x03, 0x03, 0x12, 0x06, 0xfa, 0x02, 0x08, 0xfd, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x03, 0x03, 0x01, 0x12, 0x04, 0xfa, 0x02, 0x10, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17,
    0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xfc, 0x02, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfc, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x03, 0x02, 0x00, 0x06, 0x12, 0x04, 0xfc, 0x02, 0x19, 0x21, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfc, 0x02, 0x22, 0x2a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0xfc, 0x02, 0x2d, 0x2e, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x17, 0x02, 0x05, 0x12, 0x04, 0xff, 0x02, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x05, 0x04, 0x12, 0x04, 0xff, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x05, 0x06, 0x12, 0x04, 0xff, 0x02, 0x11, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xff, 0x02, 0x1f, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xff, 0x02, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x17, 0x03, 0x04,
    0x12, 0x06, 0x81, 0x03, 0x08, 0x86, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x03, 0x04,
    0x01, 0x12, 0x04, 0x81, 0x03, 0x10, 0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x04, 0x02,
    0x00, 0x12, 0x04, 0x83, 0x03, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x04, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x83, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x04,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x83, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0x83, 0x03, 0x1f, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x04, 0x02, 0x00, 0x03, 0x12, 0x04, 0x83, 0x03, 0x27, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x17, 0x03, 0x04, 0x02, 0x01, 0x12, 0x04, 0x84, 0x03, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x04, 0x02, 0x01, 0x04, 0x12, 0x04, 0x84, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x04, 0x02, 0x01, 0x05, 0x12, 0x04, 0x84, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0x84, 0x03, 0x1f, 0x27, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0x84, 0x03, 0x2a, 0x2b, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x04, 0x02, 0x02, 0x12, 0x04, 0x85, 0x03, 0x10, 0x2c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x04, 0x02, 0x02, 0x04, 0x12, 0x04, 0x85, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x04, 0x02, 0x02, 0x05, 0x12, 0x04, 0x85, 0x03, 0x19,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x04, 0x02, 0x02, 0x01, 0x12, 0x04, 0x85, 0x03,
    0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x04, 0x02, 0x02, 0x03, 0x12, 0x04, 0x85,
    0x03, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x06, 0x12, 0x04, 0x88, 0x03, 0x08,
    0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x04, 0x12, 0x04, 0x88, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x06, 0x12, 0x04, 0x88, 0x03, 0x11, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x01, 0x12, 0x04, 0x88, 0x03, 0x1d, 0x29, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x03, 0x12, 0x04, 0x88, 0x03, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x17, 0x03, 0x05, 0x12, 0x06, 0x8a, 0x03, 0x08, 0x8d, 0x03, 0x09, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x03, 0x05, 0x01, 0x12, 0x04, 0x8a, 0x03, 0x10, 0x1b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x17, 0x03, 0x05, 0x02, 0x00, 0x12, 0x04, 0x8c, 0x03, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8c, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x05, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8c, 0x03, 0x19, 0x21, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8c, 0x03, 0x22, 0x2a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8c, 0x03, 0x2d, 0x2e,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x07, 0x12, 0x04, 0x8f, 0x03, 0x08, 0x2e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x07, 0x04, 0x12, 0x04, 0x8f, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x07, 0x06, 0x12, 0x04, 0x8f, 0x03, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x07, 0x01, 0x12, 0x04, 0x8f, 0x03, 0x1d, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x07, 0x03, 0x12, 0x04, 0x8f, 0x03, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x18,
    0x12, 0x06, 0x92, 0x03, 0x00, 0x95, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01, 0x12,
    0x04, 0x92, 0x03, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04, 0x94,
    0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94, 0x03, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x03, 0x17, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x03, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06, 0x97, 0x03, 0x00, 0x9e, 0x03, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x19, 0x01, 0x12, 0x04, 0x97, 0x03, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19,
    0x02, 0x00, 0x12, 0x04, 0x99, 0x03, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x99, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x05,
    0x12, 0x04, 0x99, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x99, 0x03, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x99, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x01, 0x12, 0x04, 0x9a, 0x03,
    0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9a, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9a, 0x03, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9a, 0x03, 0x17, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9a, 0x03, 0x21, 0x22, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x19, 0x02, 0x02, 0x12, 0x04, 0x9b, 0x03, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9b, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9b, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x03, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x02, 0x03, 0x12, 0x04, 0x9b, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x03,
    0x12, 0x04, 0x9c, 0x03, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03, 0x04, 0x12,
    0x04, 0x9c, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03, 0x05, 0x12, 0x04,
    0x9c, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9c,
    0x03, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9c, 0x03,
    0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x04, 0x12, 0x04, 0x9d, 0x03, 0x08, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9d, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x04, 0x05, 0x12, 0x04, 0x9d, 0x03, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9d, 0x03, 0x17, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x04, 0x03, 0x12, 0x04, 0x9d, 0x03, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02,
    0x05, 0x03, 0x12, 0x06, 0xa0, 0x03, 0x00, 0xad, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x03,
    0x01, 0x12, 0x04, 0xa0, 0x03, 0x05, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x00, 0x12,
    0x04, 0xa2, 0x03, 0x08, 0x4c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xa2, 0x03, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x00, 0x02, 0x12, 0x04, 0xa2,
    0x03, 0x4a, 0x4b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x08,
    0x4c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x08, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x02, 0x12, 0x04, 0xa3, 0x03, 0x4a, 0x4b, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x02, 0x12, 0x04, 0xa4, 0x03, 0x08, 0x44, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa4, 0x03, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x03, 0x02, 0x02, 0x02, 0x12, 0x04, 0xa4, 0x03, 0x42, 0x43, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x03, 0x02, 0x03, 0x12, 0x04, 0xa5, 0x03, 0x08, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xa5, 0x03, 0x08, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x03,
    0x02, 0x12, 0x04, 0xa5, 0x03, 0x3a, 0x3b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x04, 0x12,
    0x04, 0xa6, 0x03, 0x08, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xa6, 0x03, 0x08, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x04, 0x02, 0x12, 0x04, 0xa6,
    0x03, 0x42, 0x43, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x05, 0x12, 0x04, 0xa7, 0x03, 0x08,
    0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x05, 0x01, 0x12, 0x04, 0xa7, 0x03, 0x08, 0x2e,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x05, 0x02, 0x12, 0x04, 0xa7, 0x03, 0x42, 0x43, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x06, 0x12, 0x04, 0xa8, 0x03, 0x08, 0x44, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x03, 0x02, 0x06, 0x01, 0x12, 0x04, 0xa8, 0x03, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x03, 0x02, 0x06, 0x02, 0x12, 0x04, 0xa8, 0x03, 0x42, 0x43, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x03, 0x02, 0x07, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x4c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02,
    0x07, 0x01, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x07,
    0x02, 0x12, 0x04, 0xa9, 0x03, 0x4a, 0x4b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x08, 0x12,
    0x04, 0xaa, 0x03, 0x08, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xaa, 0x03, 0x08, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x08, 0x02, 0x12, 0x04, 0xaa,
    0x03, 0x3a, 0x3b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x09, 0x12, 0x04, 0xab, 0x03, 0x08,
    0x4c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x09, 0x01, 0x12, 0x04, 0xab, 0x03, 0x08, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x09, 0x02, 0x12, 0x04, 0xab, 0x03, 0x4a, 0x4b, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x0a, 0x12, 0x04, 0xac, 0x03, 0x08, 0x4d, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x03, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xac, 0x03, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x03, 0x02, 0x0a, 0x02, 0x12, 0x04, 0xac, 0x03, 0x4a, 0x4c, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x1a, 0x12, 0x06, 0xaf, 0x03, 0x00, 0xfa, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1a, 0x01,
    0x12, 0x04, 0xaf, 0x03, 0x08, 0x24, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x00, 0x12, 0x06,
    0xb1, 0x03, 0x08, 0xb3, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xb1, 0x03, 0x10, 0x24, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x01, 0x12, 0x06, 0xb4,
    0x03, 0x08, 0xb9, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x01, 0x01, 0x12, 0x04,
    0xb4, 0x03, 0x10, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xb6, 0x03, 0x10, 0x37, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xb6, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x01, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xb6, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xb6, 0x03, 0x1f, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x01, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xb6, 0x03, 0x35, 0x36, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x01,
    0x02, 0x01, 0x12, 0x04, 0xb7, 0x03, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x01,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xb7, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb7, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a,
    0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb7, 0x03, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1a, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb7, 0x03, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x1a, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xb8, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1a, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb8, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb8, 0x03, 0x19, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1a, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb8, 0x03, 0x1f, 0x2c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb8, 0x03, 0x2f, 0x30,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x02, 0x12, 0x06, 0xba, 0x03, 0x08, 0xbd, 0x03, 0x09,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x02, 0x01, 0x12, 0x04, 0xba, 0x03, 0x10, 0x1f, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0xbc, 0x03, 0x10, 0x36, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbc, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x02, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbc, 0x03, 0x19,
    0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbc, 0x03,
    0x1e, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbc,
    0x03, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x03, 0x12, 0x06, 0xbe, 0x03, 0x08,
    0xc2, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x03, 0x01, 0x12, 0x04, 0xbe, 0x03,
    0x10, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x03,
    0x10, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc0,
    0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x03, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xc0, 0x03, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xc0, 0x03, 0x1e, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x03, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xc0, 0x03, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x03, 0x02, 0x01,
    0x12, 0x04, 0xc1, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x03, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xc1, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x03, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xc1, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x03,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xc1, 0x03, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x03, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc1, 0x03, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a,
    0x03, 0x04, 0x12, 0x06, 0xc3, 0x03, 0x08, 0xc7, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x03, 0x04, 0x01, 0x12, 0x04, 0xc3, 0x03, 0x10, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03,
    0x04, 0x02, 0x00, 0x12, 0x04, 0xc5, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x04, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc5, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a,
    0x03, 0x04, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc5, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1a, 0x03, 0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1a, 0x03, 0x04, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc5, 0x03, 0x2f, 0x30, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x1a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x04, 0xc6, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x04, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc6, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1a, 0x03, 0x04, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc6, 0x03, 0x19, 0x23, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc6, 0x03, 0x24, 0x2c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc6, 0x03, 0x2f,
    0x30, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x05, 0x12, 0x06, 0xc8, 0x03, 0x08, 0xcc, 0x03,
    0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x05, 0x01, 0x12, 0x04, 0xc8, 0x03, 0x10, 0x21,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x00, 0x12, 0x04, 0xca, 0x03, 0x10, 0x31,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0xca, 0x03, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x00, 0x05, 0x12, 0x04, 0xca, 0x03,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0xca,
    0x03, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xca, 0x03, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x01, 0x12, 0x04,
    0xcb, 0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xcb, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x01, 0x06,
    0x12, 0x04, 0xcb, 0x03, 0x19, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xcb, 0x03, 0x24, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x05, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xcb, 0x03, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x06,
    0x12, 0x06, 0xcd, 0x03, 0x08, 0xd3, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x06,
    0x01, 0x12, 0x04, 0xcd, 0x03, 0x10, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x06, 0x02,
    0x00, 0x12, 0x04, 0xcf, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xcf, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xcf, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcf, 0x03, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a,
    0x03, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcf, 0x03, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x1a, 0x03, 0x06, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1a, 0x03, 0x06, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd0, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1a, 0x03, 0x06, 0x02, 0x01, 0x06, 0x12, 0x04, 0xd0, 0x03, 0x19, 0x23, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd0, 0x03, 0x24, 0x2b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd0, 0x03, 0x2e, 0x2f, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x02, 0x12, 0x04, 0xd1, 0x03, 0x10, 0x2e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd1, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x02, 0x06, 0x12, 0x04, 0xd1, 0x03, 0x19,
    0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x03,
    0x24, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd1,
    0x03, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x03, 0x12, 0x04, 0xd2,
    0x03, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xd2, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x03, 0x06, 0x12,
    0x04, 0xd2, 0x03, 0x19, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xd2, 0x03, 0x24, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x06, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xd2, 0x03, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x07, 0x12,
    0x06, 0xd4, 0x03, 0x08, 0xd8, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x07, 0x01,
    0x12, 0x04, 0xd4, 0x03, 0x10, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x07, 0x02, 0x00,
    0x12, 0x04, 0xd6, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x07, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xd6, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x07, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xd6, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x07,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xd6, 0x03, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x07, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd6, 0x03, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a,
    0x03, 0x07, 0x02, 0x01, 0x12, 0x04, 0xd7, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a,
    0x03, 0x07, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd7, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1a, 0x03, 0x07, 0x02, 0x01, 0x06, 0x12, 0x04, 0xd7, 0x03, 0x19, 0x23, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1a, 0x03, 0x07, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd7, 0x03, 0x24, 0x2c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x07, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd7, 0x03, 0x2f, 0x30, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x1a, 0x03, 0x08, 0x12, 0x06, 0xd9, 0x03, 0x08, 0xdd, 0x03, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1a, 0x03, 0x08, 0x01, 0x12, 0x04, 0xd9, 0x03, 0x10, 0x24, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x00, 0x12, 0x04, 0xdb, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdb, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdb, 0x03, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdb, 0x03, 0x1f, 0x2c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdb, 0x03, 0x2f,
    0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x01, 0x12, 0x04, 0xdc, 0x03, 0x10,
    0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdc, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x01, 0x06, 0x12, 0x04, 0xdc,
    0x03, 0x19, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xdc, 0x03, 0x24, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x08, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xdc, 0x03, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x09, 0x12, 0x06, 0xde,
    0x03, 0x08, 0xe5, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x09, 0x01, 0x12, 0x04,
    0xde, 0x03, 0x10, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x00, 0x12, 0x04,
    0xe0, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xe0, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xe0, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xe0, 0x03, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xe0, 0x03, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x09,
    0x02, 0x01, 0x12, 0x04, 0xe1, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xe1, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x09, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe1, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a,
    0x03, 0x09, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe1, 0x03, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1a, 0x03, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe1, 0x03, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x1a, 0x03, 0x09, 0x02, 0x02, 0x12, 0x04, 0xe2, 0x03, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1a, 0x03, 0x09, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe2, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe2, 0x03, 0x19, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe2, 0x03, 0x1f, 0x2a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe2, 0x03, 0x2d, 0x2e,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x03, 0x12, 0x04, 0xe3, 0x03, 0x10, 0x2e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe3, 0x03, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x03, 0x05, 0x12, 0x04, 0xe3, 0x03,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe3,
    0x03, 0x1f, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xe3, 0x03, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x04, 0x12, 0x04,
    0xe4, 0x03, 0x10, 0x3a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x04, 0x04, 0x12,
    0x04, 0xe4, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x04, 0x06,
    0x12, 0x04, 0xe4, 0x03, 0x19, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02, 0x04,
    0x01, 0x12, 0x04, 0xe4, 0x03, 0x24, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x09, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xe4, 0x03, 0x38, 0x39, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1a, 0x03, 0x0a,
    0x12, 0x06, 0xe6, 0x03, 0x08, 0xea, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x03, 0x0a,
    0x01, 0x12, 0x04, 0xe6, 0x03, 0x10, 0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1a, 0x03, 0x0a, 0x02,
    0x00, 0x12, 0x04, 0xe8, 0x03, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x0a, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xe8, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03, 0x0a,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xe8, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a, 0x03,
    0x0a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe8, 0x03, 0x1f, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1a,
    0x03, 0x0a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe8, 0x03, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x1a, 0x03, 0x0a, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x03, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1a, 0x03, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe9, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1a, 0x03, 0x0a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe9, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1a, 0x03, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe9, 0x03, 0x1f, 0x23, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1a, 0x03, 0x0a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe9, 0x03, 0x26, 0x27, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x00, 0x12, 0x04, 0xec, 0x03, 0x08, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xec, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1a, 0x02, 0x00, 0x06, 0x12, 0x04, 0xec, 0x03, 0x11, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xec, 0x03, 0x27, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xec, 0x03, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02,
    0x01, 0x12, 0x04, 0xed, 0x03, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xed, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xed, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xed, 0x03, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xed,
    0x03, 0x20, 0x21, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x02, 0x12, 0x04, 0xef, 0x03, 0x08,
    0x4b, 0x22, 0x26, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c,
    0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f,
    0x52, 0x45, 0x4c, 0x45, 0x41, 0x53, 0x45, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xef, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x02,
    0x06, 0x12, 0x04, 0xef, 0x03, 0x11, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xef, 0x03, 0x30, 0x46, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xef, 0x03, 0x49, 0x4a, 0x0a, 0x33, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x03, 0x12, 0x04, 0xf0,
    0x03, 0x08, 0x4c, 0x22, 0x25, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49,
    0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e,
    0x54, 0x5f, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xf0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x03, 0x06, 0x12, 0x04, 0xf0, 0x03, 0x11, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xf0, 0x03, 0x38, 0x47, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xf0, 0x03, 0x4a, 0x4b, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x04, 0x12, 0x04,
    0xf1, 0x03, 0x08, 0x4d, 0x22, 0x26, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54,
    0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45,
    0x4e, 0x54, 0x5f, 0x44, 0x45, 0x53, 0x54, 0x52, 0x4f, 0x59, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1a, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf1, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1a, 0x02, 0x04, 0x06, 0x12, 0x04, 0xf1, 0x03, 0x11, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xf1, 0x03, 0x38, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xf1, 0x03, 0x4b, 0x4c, 0x0a, 0x3e, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x05,
    0x12, 0x04, 0xf2, 0x03, 0x08, 0x4f, 0x22, 0x30, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41,
    0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45,
    0x56, 0x45, 0x4e, 0x54, 0x5f, 0x44, 0x45, 0x53, 0x54, 0x52, 0x4f, 0x59, 0x5f, 0x49, 0x4e, 0x56,
    0x4f, 0x4c, 0x56, 0x49, 0x4e, 0x47, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x05,
    0x04, 0x12, 0x04, 0xf2, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x05, 0x06,
    0x12, 0x04, 0xf2, 0x03, 0x11, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x05, 0x01, 0x12,
    0x04, 0xf2, 0x03, 0x30, 0x4a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x05, 0x03, 0x12, 0x04,
    0xf2, 0x03, 0x4d, 0x4e, 0x0a, 0x33, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x06, 0x12, 0x04, 0xf3, 0x03,
    0x08, 0x4c, 0x22, 0x25, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43,
    0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54,
    0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x06, 0x04, 0x12, 0x04, 0xf3, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x06,
    0x06, 0x12, 0x04, 0xf3, 0x03, 0x11, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x06, 0x01,
    0x12, 0x04, 0xf3, 0x03, 0x38, 0x47, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x06, 0x03, 0x12,
    0x04, 0xf3, 0x03, 0x4a, 0x4b, 0x0a, 0x3b, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x07, 0x12, 0x04, 0xf4,
    0x03, 0x08, 0x50, 0x22, 0x2d, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49,
    0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e,
    0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x46, 0x4f, 0x52, 0x57, 0x41, 0x52, 0x44,
    0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x04, 0x12, 0x04, 0xf4, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x06, 0x12, 0x04, 0xf4, 0x03, 0x11, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x01, 0x12, 0x04, 0xf4, 0x03, 0x38, 0x4b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x03, 0x12, 0x04, 0xf4, 0x03, 0x4e, 0x4f, 0x0a, 0x3f,
    0x0a, 0x04, 0x04, 0x1a, 0x02, 0x08, 0x12, 0x04, 0xf5, 0x03, 0x08, 0x4b, 0x22, 0x31, 0x20, 0x44,
    0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e,
    0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54,
    0x45, 0x5f, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x0d, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x08, 0x04, 0x12, 0x04, 0xf5, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1a, 0x02, 0x08, 0x06, 0x12, 0x04, 0xf5, 0x03, 0x11, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1a, 0x02, 0x08, 0x01, 0x12, 0x04, 0xf5, 0x03, 0x30, 0x46, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1a, 0x02, 0x08, 0x03, 0x12, 0x04, 0xf5, 0x03, 0x49, 0x4a, 0x0a, 0x3c, 0x0a, 0x04, 0x04,
    0x1a, 0x02, 0x09, 0x12, 0x04, 0xf6, 0x03, 0x08, 0x4e, 0x22, 0x2e, 0x20, 0x44, 0x4f, 0x54, 0x41,
    0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45,
    0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x46,
    0x41, 0x4c, 0x4c, 0x42, 0x41, 0x43, 0x4b, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x09, 0x04, 0x12, 0x04, 0xf6, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x09,
    0x06, 0x12, 0x04, 0xf6, 0x03, 0x11, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x09, 0x01,
    0x12, 0x04, 0xf6, 0x03, 0x30, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x09, 0x03, 0x12,
    0x04, 0xf6, 0x03, 0x4b, 0x4d, 0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x0a, 0x12, 0x04, 0xf7,
    0x03, 0x08, 0x4c, 0x22, 0x2c, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49,
    0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e,
    0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x4f, 0x46, 0x46, 0x53, 0x45, 0x54, 0x0d,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xf7, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0a, 0x06, 0x12, 0x04, 0xf7, 0x03, 0x11, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xf7, 0x03, 0x30, 0x46, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xf7, 0x03, 0x49, 0x4b, 0x0a, 0x37, 0x0a,
    0x04, 0x04, 0x1a, 0x02, 0x0b, 0x12, 0x04, 0xf8, 0x03, 0x08, 0x51, 0x22, 0x29, 0x20, 0x44, 0x4f,
    0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45, 0x5f, 0x4d, 0x41, 0x4e, 0x41,
    0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45,
    0x5f, 0x45, 0x4e, 0x54, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0b, 0x04, 0x12,
    0x04, 0xf8, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0b, 0x06, 0x12, 0x04,
    0xf8, 0x03, 0x11, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xf8,
    0x03, 0x38, 0x4b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xf8, 0x03,
    0x4e, 0x50, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x0c, 0x12, 0x04, 0xf9, 0x03, 0x08, 0x4d,
    0x22, 0x26, 0x20, 0x44, 0x4f, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x43, 0x4c, 0x45,
    0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x52, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x4c,
    0x41, 0x54, 0x45, 0x4e, 0x43, 0x59, 0x0d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0c,
    0x04, 0x12, 0x04, 0xf9, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0c, 0x06,
    0x12, 0x04, 0xf9, 0x03, 0x11, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0c, 0x01, 0x12,
    0x04, 0xf9, 0x03, 0x30, 0x47, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x0c, 0x03, 0x12, 0x04,
    0xf9, 0x03, 0x4a, 0x4c, 0x0a, 0x50, 0x0a, 0x02, 0x05, 0x04, 0x12, 0x06, 0xfd, 0x03, 0x00, 0x89,
    0x04, 0x01, 0x1a, 0x42, 0x20, 0x49, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x6f, 0x64, 0x69,
    0x66, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x2c, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x73, 0x75,
    0x72, 0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x67, 0x5f,
    0x4f, 0x76, 0x65, 0x72, 0x68, 0x65, 0x61, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54,
    0x79, 0x70, 0x65, 0x21, 0x0d, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x04, 0x01, 0x12, 0x04, 0xfd,
    0x03, 0x05, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x00, 0x12, 0x04, 0xff, 0x03, 0x08,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0xff, 0x03, 0x08, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00, 0x02, 0x12, 0x04, 0xff, 0x03, 0x2f, 0x30, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x01, 0x12, 0x04, 0x80, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0x80, 0x04, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x04, 0x02, 0x01, 0x02, 0x12, 0x04, 0x80, 0x04, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x04, 0x02, 0x02, 0x12, 0x04, 0x81, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x81, 0x04, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x02,
    0x02, 0x12, 0x04, 0x81, 0x04, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x03, 0x12,
    0x04, 0x82, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x03, 0x01, 0x12, 0x04,
    0x82, 0x04, 0x08, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x03, 0x02, 0x12, 0x04, 0x82,
    0x04, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x04, 0x12, 0x04, 0x83, 0x04, 0x08,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x04, 0x01, 0x12, 0x04, 0x83, 0x04, 0x08, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x04, 0x02, 0x12, 0x04, 0x83, 0x04, 0x2f, 0x30, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x05, 0x12, 0x04, 0x84, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x04, 0x02, 0x05, 0x01, 0x12, 0x04, 0x84, 0x04, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x04, 0x02, 0x05, 0x02, 0x12, 0x04, 0x84, 0x04, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x04, 0x02, 0x06, 0x12, 0x04, 0x85, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02,
    0x06, 0x01, 0x12, 0x04, 0x85, 0x04, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x06,
    0x02, 0x12, 0x04, 0x85, 0x04, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x07, 0x12,
    0x04, 0x86, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x07, 0x01, 0x12, 0x04,
    0x86, 0x04, 0x08, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x07, 0x02, 0x12, 0x04, 0x86,
    0x04, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x08, 0x12, 0x04, 0x87, 0x04, 0x08,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x08, 0x01, 0x12, 0x04, 0x87, 0x04, 0x08, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x08, 0x02, 0x12, 0x04, 0x87, 0x04, 0x2f, 0x30, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x09, 0x12, 0x04, 0x88, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x04, 0x02, 0x09, 0x01, 0x12, 0x04, 0x88, 0x04, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x04, 0x02, 0x09, 0x02, 0x12, 0x04, 0x88, 0x04, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x1b, 0x12, 0x06, 0x8b, 0x04, 0x00, 0x92, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1b, 0x01,
    0x12, 0x04, 0x8b, 0x04, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x00, 0x12, 0x04,
    0x8d, 0x04, 0x08, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8d,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8d, 0x04,
    0x11, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8d, 0x04, 0x25,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8d, 0x04, 0x34, 0x35,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x04, 0x08, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8e, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1b, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8e, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1b, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8e, 0x04, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1b, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8e, 0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b,
    0x02, 0x02, 0x12, 0x04, 0x8f, 0x04, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x8f, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x8f, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x8f, 0x04, 0x17, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x8f, 0x04, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x03, 0x12, 0x04, 0x90, 0x04,
    0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x04, 0x12, 0x04, 0x90, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x05, 0x12, 0x04, 0x90, 0x04, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x01, 0x12, 0x04, 0x90, 0x04, 0x17, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x03, 0x12, 0x04, 0x90, 0x04, 0x29, 0x2a, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1b, 0x02, 0x04, 0x12, 0x04, 0x91, 0x04, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1b, 0x02, 0x04, 0x04, 0x12, 0x04, 0x91, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1b, 0x02, 0x04, 0x05, 0x12, 0x04, 0x91, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b,
    0x02, 0x04, 0x01, 0x12, 0x04, 0x91, 0x04, 0x17, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02,
    0x04, 0x03, 0x12, 0x04, 0x91, 0x04, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06,
    0x94, 0x04, 0x00, 0x98, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1c, 0x01, 0x12, 0x04, 0x94,
    0x04, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x00, 0x12, 0x04, 0x96, 0x04, 0x08,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x04, 0x12, 0x04, 0x96, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x05, 0x12, 0x04, 0x96, 0x04, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x96, 0x04, 0x18, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x96, 0x04, 0x1f, 0x20, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1c, 0x02, 0x01, 0x12, 0x04, 0x97, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x01, 0x04, 0x12, 0x04, 0x97, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x97, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x97, 0x04, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x97, 0x04, 0x22, 0x23,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto };

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data)
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_AIDebugLine {
    message: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_AIDebugLine {
    pub fn new() -> CDOTAUserMsg_AIDebugLine {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_AIDebugLine {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_AIDebugLine> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_AIDebugLine };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_AIDebugLine {
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&'a mut self) -> &'a mut String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    pub fn get_message(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AIDebugLine {
    fn new() -> CDOTAUserMsg_AIDebugLine {
        CDOTAUserMsg_AIDebugLine::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.message.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.message.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_AIDebugLine>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_AIDebugLine>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_AIDebugLine_message_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_AIDebugLine>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_AIDebugLine>(
                    "CDOTAUserMsg_AIDebugLine",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_AIDebugLine>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_AIDebugLine {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_AIDebugLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_AIDebugLine_message_acc_type;
static CDOTAUserMsg_AIDebugLine_message_acc: CDOTAUserMsg_AIDebugLine_message_acc_type = CDOTAUserMsg_AIDebugLine_message_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_AIDebugLine> for CDOTAUserMsg_AIDebugLine_message_acc_type {
    fn name(&self) -> &'static str {
        "message"
    }

    fn has_field(&self, m: &CDOTAUserMsg_AIDebugLine) -> bool {
        m.has_message()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_AIDebugLine) -> &'a str {
        m.get_message()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_Ping {
    message: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_Ping {
    pub fn new() -> CDOTAUserMsg_Ping {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_Ping {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_Ping> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_Ping };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_Ping {
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&'a mut self) -> &'a mut String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    pub fn get_message(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_Ping {
    fn new() -> CDOTAUserMsg_Ping {
        CDOTAUserMsg_Ping::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.message.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.message.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_Ping>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_Ping>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_Ping_message_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_Ping>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_Ping>(
                    "CDOTAUserMsg_Ping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_Ping>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_Ping {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_Ping_message_acc_type;
static CDOTAUserMsg_Ping_message_acc: CDOTAUserMsg_Ping_message_acc_type = CDOTAUserMsg_Ping_message_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_Ping> for CDOTAUserMsg_Ping_message_acc_type {
    fn name(&self) -> &'static str {
        "message"
    }

    fn has_field(&self, m: &CDOTAUserMsg_Ping) -> bool {
        m.has_message()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_Ping) -> &'a str {
        m.get_message()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ChatEvent {
    field_type: Option<DOTA_CHAT_MESSAGE>,
    value: Option<u32>,
    playerid_1: Option<i32>,
    playerid_2: Option<i32>,
    playerid_3: Option<i32>,
    playerid_4: Option<i32>,
    playerid_5: Option<i32>,
    playerid_6: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ChatEvent {
    pub fn new() -> CDOTAUserMsg_ChatEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ChatEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ChatEvent> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ChatEvent };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ChatEvent {
                    field_type: None,
                    value: None,
                    playerid_1: None,
                    playerid_2: None,
                    playerid_3: None,
                    playerid_4: None,
                    playerid_5: None,
                    playerid_6: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DOTA_CHAT_MESSAGE) {
        self.field_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&'a mut self) -> &'a mut DOTA_CHAT_MESSAGE {
        if self.field_type.is_none() {
            self.field_type = Some(DOTA_CHAT_MESSAGE::new(0));
        };
        self.field_type.as_mut().unwrap()
    }

    pub fn get_field_type(&self) -> DOTA_CHAT_MESSAGE {
        self.field_type.unwrap_or_else(|| DOTA_CHAT_MESSAGE::new(0))
    }

    pub fn clear_value(&mut self) {
        self.value = None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&'a mut self) -> &'a mut u32 {
        if self.value.is_none() {
            self.value = Some(0);
        };
        self.value.as_mut().unwrap()
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or_else(|| 0)
    }

    pub fn clear_playerid_1(&mut self) {
        self.playerid_1 = None;
    }

    pub fn has_playerid_1(&self) -> bool {
        self.playerid_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_1(&mut self, v: i32) {
        self.playerid_1 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playerid_1(&'a mut self) -> &'a mut i32 {
        if self.playerid_1.is_none() {
            self.playerid_1 = Some(0);
        };
        self.playerid_1.as_mut().unwrap()
    }

    pub fn get_playerid_1(&self) -> i32 {
        self.playerid_1.unwrap_or_else(|| 0)
    }

    pub fn clear_playerid_2(&mut self) {
        self.playerid_2 = None;
    }

    pub fn has_playerid_2(&self) -> bool {
        self.playerid_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_2(&mut self, v: i32) {
        self.playerid_2 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playerid_2(&'a mut self) -> &'a mut i32 {
        if self.playerid_2.is_none() {
            self.playerid_2 = Some(0);
        };
        self.playerid_2.as_mut().unwrap()
    }

    pub fn get_playerid_2(&self) -> i32 {
        self.playerid_2.unwrap_or_else(|| 0)
    }

    pub fn clear_playerid_3(&mut self) {
        self.playerid_3 = None;
    }

    pub fn has_playerid_3(&self) -> bool {
        self.playerid_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_3(&mut self, v: i32) {
        self.playerid_3 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playerid_3(&'a mut self) -> &'a mut i32 {
        if self.playerid_3.is_none() {
            self.playerid_3 = Some(0);
        };
        self.playerid_3.as_mut().unwrap()
    }

    pub fn get_playerid_3(&self) -> i32 {
        self.playerid_3.unwrap_or_else(|| 0)
    }

    pub fn clear_playerid_4(&mut self) {
        self.playerid_4 = None;
    }

    pub fn has_playerid_4(&self) -> bool {
        self.playerid_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_4(&mut self, v: i32) {
        self.playerid_4 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playerid_4(&'a mut self) -> &'a mut i32 {
        if self.playerid_4.is_none() {
            self.playerid_4 = Some(0);
        };
        self.playerid_4.as_mut().unwrap()
    }

    pub fn get_playerid_4(&self) -> i32 {
        self.playerid_4.unwrap_or_else(|| 0)
    }

    pub fn clear_playerid_5(&mut self) {
        self.playerid_5 = None;
    }

    pub fn has_playerid_5(&self) -> bool {
        self.playerid_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_5(&mut self, v: i32) {
        self.playerid_5 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playerid_5(&'a mut self) -> &'a mut i32 {
        if self.playerid_5.is_none() {
            self.playerid_5 = Some(0);
        };
        self.playerid_5.as_mut().unwrap()
    }

    pub fn get_playerid_5(&self) -> i32 {
        self.playerid_5.unwrap_or_else(|| 0)
    }

    pub fn clear_playerid_6(&mut self) {
        self.playerid_6 = None;
    }

    pub fn has_playerid_6(&self) -> bool {
        self.playerid_6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_6(&mut self, v: i32) {
        self.playerid_6 = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playerid_6(&'a mut self) -> &'a mut i32 {
        if self.playerid_6.is_none() {
            self.playerid_6 = Some(0);
        };
        self.playerid_6.as_mut().unwrap()
    }

    pub fn get_playerid_6(&self) -> i32 {
        self.playerid_6.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatEvent {
    fn new() -> CDOTAUserMsg_ChatEvent {
        CDOTAUserMsg_ChatEvent::new()
    }

    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = DOTA_CHAT_MESSAGE::new(is.read_int32());
                    self.field_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.value = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.playerid_1 = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.playerid_2 = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.playerid_3 = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.playerid_4 = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.playerid_5 = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_sint32();
                    self.playerid_6 = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.playerid_1.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.playerid_2.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.playerid_3.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.playerid_4.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.playerid_5.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.playerid_6.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.field_type {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        match self.value {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.playerid_1 {
            Some(ref v) => {
                os.write_sint32(3, *v);
            },
            None => {},
        };
        match self.playerid_2 {
            Some(ref v) => {
                os.write_sint32(4, *v);
            },
            None => {},
        };
        match self.playerid_3 {
            Some(ref v) => {
                os.write_sint32(5, *v);
            },
            None => {},
        };
        match self.playerid_4 {
            Some(ref v) => {
                os.write_sint32(6, *v);
            },
            None => {},
        };
        match self.playerid_5 {
            Some(ref v) => {
                os.write_sint32(7, *v);
            },
            None => {},
        };
        match self.playerid_6 {
            Some(ref v) => {
                os.write_sint32(8, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ChatEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_field_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_value_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_playerid_1_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_playerid_2_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_playerid_3_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_playerid_4_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_playerid_5_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ChatEvent_playerid_6_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ChatEvent>(
                    "CDOTAUserMsg_ChatEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ChatEvent>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ChatEvent {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_value();
        self.clear_playerid_1();
        self.clear_playerid_2();
        self.clear_playerid_3();
        self.clear_playerid_4();
        self.clear_playerid_5();
        self.clear_playerid_6();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ChatEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_field_type_acc_type;
static CDOTAUserMsg_ChatEvent_field_type_acc: CDOTAUserMsg_ChatEvent_field_type_acc_type = CDOTAUserMsg_ChatEvent_field_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_field_type_acc_type {
    fn name(&self) -> &'static str {
        "field_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_field_type()
    }

    fn get_enum<'a>(&self, m: &CDOTAUserMsg_ChatEvent) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_field_type().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_value_acc_type;
static CDOTAUserMsg_ChatEvent_value_acc: CDOTAUserMsg_ChatEvent_value_acc_type = CDOTAUserMsg_ChatEvent_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_value()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_ChatEvent) -> u32 {
        m.get_value()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_playerid_1_acc_type;
static CDOTAUserMsg_ChatEvent_playerid_1_acc: CDOTAUserMsg_ChatEvent_playerid_1_acc_type = CDOTAUserMsg_ChatEvent_playerid_1_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_playerid_1_acc_type {
    fn name(&self) -> &'static str {
        "playerid_1"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_playerid_1()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ChatEvent) -> i32 {
        m.get_playerid_1()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_playerid_2_acc_type;
static CDOTAUserMsg_ChatEvent_playerid_2_acc: CDOTAUserMsg_ChatEvent_playerid_2_acc_type = CDOTAUserMsg_ChatEvent_playerid_2_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_playerid_2_acc_type {
    fn name(&self) -> &'static str {
        "playerid_2"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_playerid_2()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ChatEvent) -> i32 {
        m.get_playerid_2()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_playerid_3_acc_type;
static CDOTAUserMsg_ChatEvent_playerid_3_acc: CDOTAUserMsg_ChatEvent_playerid_3_acc_type = CDOTAUserMsg_ChatEvent_playerid_3_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_playerid_3_acc_type {
    fn name(&self) -> &'static str {
        "playerid_3"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_playerid_3()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ChatEvent) -> i32 {
        m.get_playerid_3()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_playerid_4_acc_type;
static CDOTAUserMsg_ChatEvent_playerid_4_acc: CDOTAUserMsg_ChatEvent_playerid_4_acc_type = CDOTAUserMsg_ChatEvent_playerid_4_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_playerid_4_acc_type {
    fn name(&self) -> &'static str {
        "playerid_4"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_playerid_4()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ChatEvent) -> i32 {
        m.get_playerid_4()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_playerid_5_acc_type;
static CDOTAUserMsg_ChatEvent_playerid_5_acc: CDOTAUserMsg_ChatEvent_playerid_5_acc_type = CDOTAUserMsg_ChatEvent_playerid_5_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_playerid_5_acc_type {
    fn name(&self) -> &'static str {
        "playerid_5"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_playerid_5()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ChatEvent) -> i32 {
        m.get_playerid_5()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ChatEvent_playerid_6_acc_type;
static CDOTAUserMsg_ChatEvent_playerid_6_acc: CDOTAUserMsg_ChatEvent_playerid_6_acc_type = CDOTAUserMsg_ChatEvent_playerid_6_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ChatEvent> for CDOTAUserMsg_ChatEvent_playerid_6_acc_type {
    fn name(&self) -> &'static str {
        "playerid_6"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ChatEvent) -> bool {
        m.has_playerid_6()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ChatEvent) -> i32 {
        m.get_playerid_6()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_CombatLogData {
    field_type: Option<u32>,
    target_name: Option<u32>,
    attacker_name: Option<u32>,
    attacker_illusion: Option<bool>,
    target_illusion: Option<bool>,
    inflictor_name: Option<u32>,
    value: Option<i32>,
    health: Option<i32>,
    time: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_CombatLogData {
    pub fn new() -> CDOTAUserMsg_CombatLogData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CombatLogData {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CombatLogData> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_CombatLogData };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_CombatLogData {
                    field_type: None,
                    target_name: None,
                    attacker_name: None,
                    attacker_illusion: None,
                    target_illusion: None,
                    inflictor_name: None,
                    value: None,
                    health: None,
                    time: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&'a mut self) -> &'a mut u32 {
        if self.field_type.is_none() {
            self.field_type = Some(0);
        };
        self.field_type.as_mut().unwrap()
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or_else(|| 0)
    }

    pub fn clear_target_name(&mut self) {
        self.target_name = None;
    }

    pub fn has_target_name(&self) -> bool {
        self.target_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_name(&mut self, v: u32) {
        self.target_name = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_name(&'a mut self) -> &'a mut u32 {
        if self.target_name.is_none() {
            self.target_name = Some(0);
        };
        self.target_name.as_mut().unwrap()
    }

    pub fn get_target_name(&self) -> u32 {
        self.target_name.unwrap_or_else(|| 0)
    }

    pub fn clear_attacker_name(&mut self) {
        self.attacker_name = None;
    }

    pub fn has_attacker_name(&self) -> bool {
        self.attacker_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_name(&mut self, v: u32) {
        self.attacker_name = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attacker_name(&'a mut self) -> &'a mut u32 {
        if self.attacker_name.is_none() {
            self.attacker_name = Some(0);
        };
        self.attacker_name.as_mut().unwrap()
    }

    pub fn get_attacker_name(&self) -> u32 {
        self.attacker_name.unwrap_or_else(|| 0)
    }

    pub fn clear_attacker_illusion(&mut self) {
        self.attacker_illusion = None;
    }

    pub fn has_attacker_illusion(&self) -> bool {
        self.attacker_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_illusion(&mut self, v: bool) {
        self.attacker_illusion = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attacker_illusion(&'a mut self) -> &'a mut bool {
        if self.attacker_illusion.is_none() {
            self.attacker_illusion = Some(false);
        };
        self.attacker_illusion.as_mut().unwrap()
    }

    pub fn get_attacker_illusion(&self) -> bool {
        self.attacker_illusion.unwrap_or_else(|| false)
    }

    pub fn clear_target_illusion(&mut self) {
        self.target_illusion = None;
    }

    pub fn has_target_illusion(&self) -> bool {
        self.target_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_illusion(&mut self, v: bool) {
        self.target_illusion = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_illusion(&'a mut self) -> &'a mut bool {
        if self.target_illusion.is_none() {
            self.target_illusion = Some(false);
        };
        self.target_illusion.as_mut().unwrap()
    }

    pub fn get_target_illusion(&self) -> bool {
        self.target_illusion.unwrap_or_else(|| false)
    }

    pub fn clear_inflictor_name(&mut self) {
        self.inflictor_name = None;
    }

    pub fn has_inflictor_name(&self) -> bool {
        self.inflictor_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_name(&mut self, v: u32) {
        self.inflictor_name = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inflictor_name(&'a mut self) -> &'a mut u32 {
        if self.inflictor_name.is_none() {
            self.inflictor_name = Some(0);
        };
        self.inflictor_name.as_mut().unwrap()
    }

    pub fn get_inflictor_name(&self) -> u32 {
        self.inflictor_name.unwrap_or_else(|| 0)
    }

    pub fn clear_value(&mut self) {
        self.value = None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&'a mut self) -> &'a mut i32 {
        if self.value.is_none() {
            self.value = Some(0);
        };
        self.value.as_mut().unwrap()
    }

    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or_else(|| 0)
    }

    pub fn clear_health(&mut self) {
        self.health = None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_health(&'a mut self) -> &'a mut i32 {
        if self.health.is_none() {
            self.health = Some(0);
        };
        self.health.as_mut().unwrap()
    }

    pub fn get_health(&self) -> i32 {
        self.health.unwrap_or_else(|| 0)
    }

    pub fn clear_time(&mut self) {
        self.time = None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f32) {
        self.time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&'a mut self) -> &'a mut f32 {
        if self.time.is_none() {
            self.time = Some(0.);
        };
        self.time.as_mut().unwrap()
    }

    pub fn get_time(&self) -> f32 {
        self.time.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CombatLogData {
    fn new() -> CDOTAUserMsg_CombatLogData {
        CDOTAUserMsg_CombatLogData::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.field_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.target_name = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.attacker_name = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.attacker_illusion = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.target_illusion = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.inflictor_name = Some(tmp);
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.value = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.health = Some(tmp);
                },
                9 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.time = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.target_name.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.attacker_name.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.attacker_illusion.is_some() {
            my_size += 2;
        };
        if self.target_illusion.is_some() {
            my_size += 2;
        };
        for value in self.inflictor_name.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.health.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.time.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.field_type {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.target_name {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.attacker_name {
            Some(ref v) => {
                os.write_uint32(3, *v);
            },
            None => {},
        };
        match self.attacker_illusion {
            Some(ref v) => {
                os.write_bool(4, *v);
            },
            None => {},
        };
        match self.target_illusion {
            Some(ref v) => {
                os.write_bool(5, *v);
            },
            None => {},
        };
        match self.inflictor_name {
            Some(ref v) => {
                os.write_uint32(6, *v);
            },
            None => {},
        };
        match self.value {
            Some(ref v) => {
                os.write_int32(7, *v);
            },
            None => {},
        };
        match self.health {
            Some(ref v) => {
                os.write_int32(8, *v);
            },
            None => {},
        };
        match self.time {
            Some(ref v) => {
                os.write_float(9, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_CombatLogData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_field_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_target_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_attacker_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_attacker_illusion_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_target_illusion_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_inflictor_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_value_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_health_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatLogData_time_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CombatLogData>(
                    "CDOTAUserMsg_CombatLogData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_CombatLogData>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CombatLogData {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_target_name();
        self.clear_attacker_name();
        self.clear_attacker_illusion();
        self.clear_target_illusion();
        self.clear_inflictor_name();
        self.clear_value();
        self.clear_health();
        self.clear_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_CombatLogData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_field_type_acc_type;
static CDOTAUserMsg_CombatLogData_field_type_acc: CDOTAUserMsg_CombatLogData_field_type_acc_type = CDOTAUserMsg_CombatLogData_field_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_field_type_acc_type {
    fn name(&self) -> &'static str {
        "field_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_field_type()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_CombatLogData) -> u32 {
        m.get_field_type()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_target_name_acc_type;
static CDOTAUserMsg_CombatLogData_target_name_acc: CDOTAUserMsg_CombatLogData_target_name_acc_type = CDOTAUserMsg_CombatLogData_target_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_target_name_acc_type {
    fn name(&self) -> &'static str {
        "target_name"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_target_name()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_CombatLogData) -> u32 {
        m.get_target_name()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_attacker_name_acc_type;
static CDOTAUserMsg_CombatLogData_attacker_name_acc: CDOTAUserMsg_CombatLogData_attacker_name_acc_type = CDOTAUserMsg_CombatLogData_attacker_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_attacker_name_acc_type {
    fn name(&self) -> &'static str {
        "attacker_name"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_attacker_name()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_CombatLogData) -> u32 {
        m.get_attacker_name()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_attacker_illusion_acc_type;
static CDOTAUserMsg_CombatLogData_attacker_illusion_acc: CDOTAUserMsg_CombatLogData_attacker_illusion_acc_type = CDOTAUserMsg_CombatLogData_attacker_illusion_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_attacker_illusion_acc_type {
    fn name(&self) -> &'static str {
        "attacker_illusion"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_attacker_illusion()
    }

    fn get_bool(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.get_attacker_illusion()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_target_illusion_acc_type;
static CDOTAUserMsg_CombatLogData_target_illusion_acc: CDOTAUserMsg_CombatLogData_target_illusion_acc_type = CDOTAUserMsg_CombatLogData_target_illusion_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_target_illusion_acc_type {
    fn name(&self) -> &'static str {
        "target_illusion"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_target_illusion()
    }

    fn get_bool(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.get_target_illusion()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_inflictor_name_acc_type;
static CDOTAUserMsg_CombatLogData_inflictor_name_acc: CDOTAUserMsg_CombatLogData_inflictor_name_acc_type = CDOTAUserMsg_CombatLogData_inflictor_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_inflictor_name_acc_type {
    fn name(&self) -> &'static str {
        "inflictor_name"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_inflictor_name()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_CombatLogData) -> u32 {
        m.get_inflictor_name()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_value_acc_type;
static CDOTAUserMsg_CombatLogData_value_acc: CDOTAUserMsg_CombatLogData_value_acc_type = CDOTAUserMsg_CombatLogData_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_value()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CombatLogData) -> i32 {
        m.get_value()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_health_acc_type;
static CDOTAUserMsg_CombatLogData_health_acc: CDOTAUserMsg_CombatLogData_health_acc_type = CDOTAUserMsg_CombatLogData_health_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_health_acc_type {
    fn name(&self) -> &'static str {
        "health"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_health()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CombatLogData) -> i32 {
        m.get_health()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatLogData_time_acc_type;
static CDOTAUserMsg_CombatLogData_time_acc: CDOTAUserMsg_CombatLogData_time_acc_type = CDOTAUserMsg_CombatLogData_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogData> for CDOTAUserMsg_CombatLogData_time_acc_type {
    fn name(&self) -> &'static str {
        "time"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatLogData) -> bool {
        m.has_time()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_CombatLogData) -> f32 {
        m.get_time()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_CombatLogShowDeath {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_CombatLogShowDeath {
    pub fn new() -> CDOTAUserMsg_CombatLogShowDeath {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CombatLogShowDeath {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CombatLogShowDeath> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_CombatLogShowDeath };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_CombatLogShowDeath {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CombatLogShowDeath {
    fn new() -> CDOTAUserMsg_CombatLogShowDeath {
        CDOTAUserMsg_CombatLogShowDeath::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_CombatLogShowDeath>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatLogShowDeath>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CombatLogShowDeath>(
                    "CDOTAUserMsg_CombatLogShowDeath",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_CombatLogShowDeath>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CombatLogShowDeath {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_CombatLogShowDeath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_BotChat {
    player_id: Option<u32>,
    format: ::protobuf::SingularField<String>,
    message: ::protobuf::SingularField<String>,
    target: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_BotChat {
    pub fn new() -> CDOTAUserMsg_BotChat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_BotChat {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_BotChat> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_BotChat };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_BotChat {
                    player_id: None,
                    format: ::protobuf::SingularField::none(),
                    message: ::protobuf::SingularField::none(),
                    target: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_id(&'a mut self) -> &'a mut u32 {
        if self.player_id.is_none() {
            self.player_id = Some(0);
        };
        self.player_id.as_mut().unwrap()
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or_else(|| 0)
    }

    pub fn clear_format(&mut self) {
        self.format.clear();
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: String) {
        self.format = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&'a mut self) -> &'a mut String {
        if self.format.is_none() {
            self.format.set_default();
        };
        self.format.as_mut().unwrap()
    }

    pub fn get_format(&'a self) -> &'a str {
        match self.format.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&'a mut self) -> &'a mut String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    pub fn get_message(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&'a mut self) -> &'a mut String {
        if self.target.is_none() {
            self.target.set_default();
        };
        self.target.as_mut().unwrap()
    }

    pub fn get_target(&'a self) -> &'a str {
        match self.target.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BotChat {
    fn new() -> CDOTAUserMsg_BotChat {
        CDOTAUserMsg_BotChat::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.player_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.format.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.message.set_default();
                    is.read_string_into(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.target.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.player_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.format.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        for value in self.target.iter() {
            my_size += ::protobuf::rt::string_size(4, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.player_id {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.format.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.message.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        match self.target.as_ref() {
            Some(ref v) => {
                os.write_string(4, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_BotChat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_BotChat_player_id_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_BotChat_format_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_BotChat_message_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_BotChat_target_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_BotChat>(
                    "CDOTAUserMsg_BotChat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_BotChat>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_BotChat {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_format();
        self.clear_message();
        self.clear_target();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_BotChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_BotChat_player_id_acc_type;
static CDOTAUserMsg_BotChat_player_id_acc: CDOTAUserMsg_BotChat_player_id_acc_type = CDOTAUserMsg_BotChat_player_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat> for CDOTAUserMsg_BotChat_player_id_acc_type {
    fn name(&self) -> &'static str {
        "player_id"
    }

    fn has_field(&self, m: &CDOTAUserMsg_BotChat) -> bool {
        m.has_player_id()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_BotChat) -> u32 {
        m.get_player_id()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_BotChat_format_acc_type;
static CDOTAUserMsg_BotChat_format_acc: CDOTAUserMsg_BotChat_format_acc_type = CDOTAUserMsg_BotChat_format_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat> for CDOTAUserMsg_BotChat_format_acc_type {
    fn name(&self) -> &'static str {
        "format"
    }

    fn has_field(&self, m: &CDOTAUserMsg_BotChat) -> bool {
        m.has_format()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_BotChat) -> &'a str {
        m.get_format()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_BotChat_message_acc_type;
static CDOTAUserMsg_BotChat_message_acc: CDOTAUserMsg_BotChat_message_acc_type = CDOTAUserMsg_BotChat_message_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat> for CDOTAUserMsg_BotChat_message_acc_type {
    fn name(&self) -> &'static str {
        "message"
    }

    fn has_field(&self, m: &CDOTAUserMsg_BotChat) -> bool {
        m.has_message()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_BotChat) -> &'a str {
        m.get_message()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_BotChat_target_acc_type;
static CDOTAUserMsg_BotChat_target_acc: CDOTAUserMsg_BotChat_target_acc_type = CDOTAUserMsg_BotChat_target_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_BotChat> for CDOTAUserMsg_BotChat_target_acc_type {
    fn name(&self) -> &'static str {
        "target"
    }

    fn has_field(&self, m: &CDOTAUserMsg_BotChat) -> bool {
        m.has_target()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_BotChat) -> &'a str {
        m.get_target()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_CombatHeroPositions {
    index: Option<u32>,
    time: Option<i32>,
    world_pos: ::protobuf::SingularPtrField<CMsgVector2D>,
    health: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_CombatHeroPositions {
    pub fn new() -> CDOTAUserMsg_CombatHeroPositions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CombatHeroPositions {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CombatHeroPositions> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_CombatHeroPositions };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_CombatHeroPositions {
                    index: None,
                    time: None,
                    world_pos: ::protobuf::SingularPtrField::none(),
                    health: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_index(&mut self) {
        self.index = None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&'a mut self) -> &'a mut u32 {
        if self.index.is_none() {
            self.index = Some(0);
        };
        self.index.as_mut().unwrap()
    }

    pub fn get_index(&self) -> u32 {
        self.index.unwrap_or_else(|| 0)
    }

    pub fn clear_time(&mut self) {
        self.time = None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&'a mut self) -> &'a mut i32 {
        if self.time.is_none() {
            self.time = Some(0);
        };
        self.time.as_mut().unwrap()
    }

    pub fn get_time(&self) -> i32 {
        self.time.unwrap_or_else(|| 0)
    }

    pub fn clear_world_pos(&mut self) {
        self.world_pos.clear();
    }

    pub fn has_world_pos(&self) -> bool {
        self.world_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_pos(&mut self, v: CMsgVector2D) {
        self.world_pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_pos(&'a mut self) -> &'a mut CMsgVector2D {
        if self.world_pos.is_none() {
            self.world_pos.set_default();
        };
        self.world_pos.as_mut().unwrap()
    }

    pub fn get_world_pos(&'a self) -> &'a CMsgVector2D {
        self.world_pos.as_ref().unwrap_or_else(|| CMsgVector2D::default_instance())
    }

    pub fn clear_health(&mut self) {
        self.health = None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_health(&'a mut self) -> &'a mut i32 {
        if self.health.is_none() {
            self.health = Some(0);
        };
        self.health.as_mut().unwrap()
    }

    pub fn get_health(&self) -> i32 {
        self.health.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CombatHeroPositions {
    fn new() -> CDOTAUserMsg_CombatHeroPositions {
        CDOTAUserMsg_CombatHeroPositions::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.index = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.time = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.world_pos.set_default();
                    is.merge_message(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.health = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.time.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.world_pos.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.health.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.index {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.time {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.world_pos.as_ref() {
            Some(ref v) => {
                os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.health {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_CombatHeroPositions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatHeroPositions_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatHeroPositions_time_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatHeroPositions_world_pos_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CombatHeroPositions_health_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CombatHeroPositions>(
                    "CDOTAUserMsg_CombatHeroPositions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_CombatHeroPositions>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CombatHeroPositions {
    fn clear(&mut self) {
        self.clear_index();
        self.clear_time();
        self.clear_world_pos();
        self.clear_health();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_CombatHeroPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatHeroPositions_index_acc_type;
static CDOTAUserMsg_CombatHeroPositions_index_acc: CDOTAUserMsg_CombatHeroPositions_index_acc_type = CDOTAUserMsg_CombatHeroPositions_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions> for CDOTAUserMsg_CombatHeroPositions_index_acc_type {
    fn name(&self) -> &'static str {
        "index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatHeroPositions) -> bool {
        m.has_index()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_CombatHeroPositions) -> u32 {
        m.get_index()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatHeroPositions_time_acc_type;
static CDOTAUserMsg_CombatHeroPositions_time_acc: CDOTAUserMsg_CombatHeroPositions_time_acc_type = CDOTAUserMsg_CombatHeroPositions_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions> for CDOTAUserMsg_CombatHeroPositions_time_acc_type {
    fn name(&self) -> &'static str {
        "time"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatHeroPositions) -> bool {
        m.has_time()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CombatHeroPositions) -> i32 {
        m.get_time()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatHeroPositions_world_pos_acc_type;
static CDOTAUserMsg_CombatHeroPositions_world_pos_acc: CDOTAUserMsg_CombatHeroPositions_world_pos_acc_type = CDOTAUserMsg_CombatHeroPositions_world_pos_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions> for CDOTAUserMsg_CombatHeroPositions_world_pos_acc_type {
    fn name(&self) -> &'static str {
        "world_pos"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatHeroPositions) -> bool {
        m.has_world_pos()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_CombatHeroPositions) -> &'a ::protobuf::Message {
        m.get_world_pos() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CombatHeroPositions_health_acc_type;
static CDOTAUserMsg_CombatHeroPositions_health_acc: CDOTAUserMsg_CombatHeroPositions_health_acc_type = CDOTAUserMsg_CombatHeroPositions_health_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CombatHeroPositions> for CDOTAUserMsg_CombatHeroPositions_health_acc_type {
    fn name(&self) -> &'static str {
        "health"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CombatHeroPositions) -> bool {
        m.has_health()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CombatHeroPositions) -> i32 {
        m.get_health()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_MiniKillCamInfo {
    attackers: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_MiniKillCamInfo {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MiniKillCamInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_MiniKillCamInfo };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_MiniKillCamInfo {
                    attackers: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_attackers(&mut self) {
        self.attackers.clear();
    }

    // Param is passed by value, moved
    pub fn set_attackers(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker>) {
        self.attackers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attackers(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker> {
        &mut self.attackers
    }

    pub fn get_attackers(&'a self) -> &'a [CDOTAUserMsg_MiniKillCamInfo_Attacker] {
        self.attackers.as_slice()
    }

    pub fn add_attackers(&mut self, v: CDOTAUserMsg_MiniKillCamInfo_Attacker) {
        self.attackers.push(v);
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo {
    fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        CDOTAUserMsg_MiniKillCamInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.attackers.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.attackers.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.attackers.iter() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_MiniKillCamInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MiniKillCamInfo_attackers_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MiniKillCamInfo>(
                    "CDOTAUserMsg_MiniKillCamInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_MiniKillCamInfo>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MiniKillCamInfo {
    fn clear(&mut self) {
        self.clear_attackers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_MiniKillCamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MiniKillCamInfo_attackers_acc_type;
static CDOTAUserMsg_MiniKillCamInfo_attackers_acc: CDOTAUserMsg_MiniKillCamInfo_attackers_acc_type = CDOTAUserMsg_MiniKillCamInfo_attackers_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo> for CDOTAUserMsg_MiniKillCamInfo_attackers_acc_type {
    fn name(&self) -> &'static str {
        "attackers"
    }

    fn len_field(&self, m: &CDOTAUserMsg_MiniKillCamInfo) -> uint {
        m.get_attackers().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CDOTAUserMsg_MiniKillCamInfo, index: uint) -> &'a ::protobuf::Message {
        &m.get_attackers()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_MiniKillCamInfo_Attacker {
    attacker: Option<u32>,
    total_damage: Option<i32>,
    abilities: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_MiniKillCamInfo_Attacker {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo_Attacker {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MiniKillCamInfo_Attacker> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_MiniKillCamInfo_Attacker };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_MiniKillCamInfo_Attacker {
                    attacker: None,
                    total_damage: None,
                    abilities: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_attacker(&mut self) {
        self.attacker = None;
    }

    pub fn has_attacker(&self) -> bool {
        self.attacker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker(&mut self, v: u32) {
        self.attacker = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attacker(&'a mut self) -> &'a mut u32 {
        if self.attacker.is_none() {
            self.attacker = Some(0);
        };
        self.attacker.as_mut().unwrap()
    }

    pub fn get_attacker(&self) -> u32 {
        self.attacker.unwrap_or_else(|| 0)
    }

    pub fn clear_total_damage(&mut self) {
        self.total_damage = None;
    }

    pub fn has_total_damage(&self) -> bool {
        self.total_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_damage(&mut self, v: i32) {
        self.total_damage = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_damage(&'a mut self) -> &'a mut i32 {
        if self.total_damage.is_none() {
            self.total_damage = Some(0);
        };
        self.total_damage.as_mut().unwrap()
    }

    pub fn get_total_damage(&self) -> i32 {
        self.total_damage.unwrap_or_else(|| 0)
    }

    pub fn clear_abilities(&mut self) {
        self.abilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_abilities(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>) {
        self.abilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abilities(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> {
        &mut self.abilities
    }

    pub fn get_abilities(&'a self) -> &'a [CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability] {
        self.abilities.as_slice()
    }

    pub fn add_abilities(&mut self, v: CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability) {
        self.abilities.push(v);
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker {
        CDOTAUserMsg_MiniKillCamInfo_Attacker::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.attacker = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.total_damage = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.abilities.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.attacker.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.total_damage.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.abilities.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.attacker {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.total_damage {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        for v in self.abilities.iter() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_MiniKillCamInfo_Attacker>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MiniKillCamInfo_Attacker_attacker_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MiniKillCamInfo_Attacker_total_damage_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MiniKillCamInfo_Attacker_abilities_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MiniKillCamInfo_Attacker>(
                    "CDOTAUserMsg_MiniKillCamInfo_Attacker",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_MiniKillCamInfo_Attacker>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn clear(&mut self) {
        self.clear_attacker();
        self.clear_total_damage();
        self.clear_abilities();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MiniKillCamInfo_Attacker_attacker_acc_type;
static CDOTAUserMsg_MiniKillCamInfo_Attacker_attacker_acc: CDOTAUserMsg_MiniKillCamInfo_Attacker_attacker_acc_type = CDOTAUserMsg_MiniKillCamInfo_Attacker_attacker_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker> for CDOTAUserMsg_MiniKillCamInfo_Attacker_attacker_acc_type {
    fn name(&self) -> &'static str {
        "attacker"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker) -> bool {
        m.has_attacker()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker) -> u32 {
        m.get_attacker()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MiniKillCamInfo_Attacker_total_damage_acc_type;
static CDOTAUserMsg_MiniKillCamInfo_Attacker_total_damage_acc: CDOTAUserMsg_MiniKillCamInfo_Attacker_total_damage_acc_type = CDOTAUserMsg_MiniKillCamInfo_Attacker_total_damage_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker> for CDOTAUserMsg_MiniKillCamInfo_Attacker_total_damage_acc_type {
    fn name(&self) -> &'static str {
        "total_damage"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker) -> bool {
        m.has_total_damage()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker) -> i32 {
        m.get_total_damage()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MiniKillCamInfo_Attacker_abilities_acc_type;
static CDOTAUserMsg_MiniKillCamInfo_Attacker_abilities_acc: CDOTAUserMsg_MiniKillCamInfo_Attacker_abilities_acc_type = CDOTAUserMsg_MiniKillCamInfo_Attacker_abilities_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker> for CDOTAUserMsg_MiniKillCamInfo_Attacker_abilities_acc_type {
    fn name(&self) -> &'static str {
        "abilities"
    }

    fn len_field(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker) -> uint {
        m.get_abilities().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CDOTAUserMsg_MiniKillCamInfo_Attacker, index: uint) -> &'a ::protobuf::Message {
        &m.get_abilities()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    ability: Option<u32>,
    damage: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
                    ability: None,
                    damage: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_ability(&mut self) {
        self.ability = None;
    }

    pub fn has_ability(&self) -> bool {
        self.ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability(&mut self, v: u32) {
        self.ability = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ability(&'a mut self) -> &'a mut u32 {
        if self.ability.is_none() {
            self.ability = Some(0);
        };
        self.ability.as_mut().unwrap()
    }

    pub fn get_ability(&self) -> u32 {
        self.ability.unwrap_or_else(|| 0)
    }

    pub fn clear_damage(&mut self) {
        self.damage = None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: i32) {
        self.damage = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_damage(&'a mut self) -> &'a mut i32 {
        if self.damage.is_none() {
            self.damage = Some(0);
        };
        self.damage.as_mut().unwrap()
    }

    pub fn get_damage(&self) -> i32 {
        self.damage.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
        CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.ability = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.damage = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.ability.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.damage.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.ability {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.damage {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_ability_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_damage_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>(
                    "CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn clear(&mut self) {
        self.clear_ability();
        self.clear_damage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_ability_acc_type;
static CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_ability_acc: CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_ability_acc_type = CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_ability_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_ability_acc_type {
    fn name(&self) -> &'static str {
        "ability"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability) -> bool {
        m.has_ability()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability) -> u32 {
        m.get_ability()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_damage_acc_type;
static CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_damage_acc: CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_damage_acc_type = CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_damage_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability_damage_acc_type {
    fn name(&self) -> &'static str {
        "damage"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability) -> bool {
        m.has_damage()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability) -> i32 {
        m.get_damage()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_GlobalLightColor {
    color: Option<u32>,
    duration: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_GlobalLightColor {
    pub fn new() -> CDOTAUserMsg_GlobalLightColor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_GlobalLightColor {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_GlobalLightColor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_GlobalLightColor };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_GlobalLightColor {
                    color: None,
                    duration: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_color(&mut self) {
        self.color = None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&'a mut self) -> &'a mut u32 {
        if self.color.is_none() {
            self.color = Some(0);
        };
        self.color.as_mut().unwrap()
    }

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or_else(|| 0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut f32 {
        if self.duration.is_none() {
            self.duration = Some(0.);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlobalLightColor {
    fn new() -> CDOTAUserMsg_GlobalLightColor {
        CDOTAUserMsg_GlobalLightColor::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.color = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.duration = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.color.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.duration.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.color {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_GlobalLightColor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightColor>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_GlobalLightColor_color_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightColor>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_GlobalLightColor_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightColor>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_GlobalLightColor>(
                    "CDOTAUserMsg_GlobalLightColor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_GlobalLightColor>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_GlobalLightColor {
    fn clear(&mut self) {
        self.clear_color();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_GlobalLightColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_GlobalLightColor_color_acc_type;
static CDOTAUserMsg_GlobalLightColor_color_acc: CDOTAUserMsg_GlobalLightColor_color_acc_type = CDOTAUserMsg_GlobalLightColor_color_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightColor> for CDOTAUserMsg_GlobalLightColor_color_acc_type {
    fn name(&self) -> &'static str {
        "color"
    }

    fn has_field(&self, m: &CDOTAUserMsg_GlobalLightColor) -> bool {
        m.has_color()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_GlobalLightColor) -> u32 {
        m.get_color()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_GlobalLightColor_duration_acc_type;
static CDOTAUserMsg_GlobalLightColor_duration_acc: CDOTAUserMsg_GlobalLightColor_duration_acc_type = CDOTAUserMsg_GlobalLightColor_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightColor> for CDOTAUserMsg_GlobalLightColor_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CDOTAUserMsg_GlobalLightColor) -> bool {
        m.has_duration()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_GlobalLightColor) -> f32 {
        m.get_duration()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_GlobalLightDirection {
    direction: ::protobuf::SingularPtrField<CMsgVector>,
    duration: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_GlobalLightDirection {
    pub fn new() -> CDOTAUserMsg_GlobalLightDirection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_GlobalLightDirection {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_GlobalLightDirection> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_GlobalLightDirection };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_GlobalLightDirection {
                    direction: ::protobuf::SingularPtrField::none(),
                    duration: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: CMsgVector) {
        self.direction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&'a mut self) -> &'a mut CMsgVector {
        if self.direction.is_none() {
            self.direction.set_default();
        };
        self.direction.as_mut().unwrap()
    }

    pub fn get_direction(&'a self) -> &'a CMsgVector {
        self.direction.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut f32 {
        if self.duration.is_none() {
            self.duration = Some(0.);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlobalLightDirection {
    fn new() -> CDOTAUserMsg_GlobalLightDirection {
        CDOTAUserMsg_GlobalLightDirection::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.direction.set_default();
                    is.merge_message(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.duration = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.direction.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.duration.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.direction.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_float(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_GlobalLightDirection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightDirection>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_GlobalLightDirection_direction_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightDirection>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_GlobalLightDirection_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightDirection>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_GlobalLightDirection>(
                    "CDOTAUserMsg_GlobalLightDirection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_GlobalLightDirection>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_GlobalLightDirection {
    fn clear(&mut self) {
        self.clear_direction();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_GlobalLightDirection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_GlobalLightDirection_direction_acc_type;
static CDOTAUserMsg_GlobalLightDirection_direction_acc: CDOTAUserMsg_GlobalLightDirection_direction_acc_type = CDOTAUserMsg_GlobalLightDirection_direction_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightDirection> for CDOTAUserMsg_GlobalLightDirection_direction_acc_type {
    fn name(&self) -> &'static str {
        "direction"
    }

    fn has_field(&self, m: &CDOTAUserMsg_GlobalLightDirection) -> bool {
        m.has_direction()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_GlobalLightDirection) -> &'a ::protobuf::Message {
        m.get_direction() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_GlobalLightDirection_duration_acc_type;
static CDOTAUserMsg_GlobalLightDirection_duration_acc: CDOTAUserMsg_GlobalLightDirection_duration_acc_type = CDOTAUserMsg_GlobalLightDirection_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_GlobalLightDirection> for CDOTAUserMsg_GlobalLightDirection_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CDOTAUserMsg_GlobalLightDirection) -> bool {
        m.has_duration()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_GlobalLightDirection) -> f32 {
        m.get_duration()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_LocationPing {
    player_id: Option<u32>,
    location_ping: ::protobuf::SingularPtrField<CDOTAMsg_LocationPing>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_LocationPing {
    pub fn new() -> CDOTAUserMsg_LocationPing {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_LocationPing {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_LocationPing> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_LocationPing };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_LocationPing {
                    player_id: None,
                    location_ping: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_id(&'a mut self) -> &'a mut u32 {
        if self.player_id.is_none() {
            self.player_id = Some(0);
        };
        self.player_id.as_mut().unwrap()
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or_else(|| 0)
    }

    pub fn clear_location_ping(&mut self) {
        self.location_ping.clear();
    }

    pub fn has_location_ping(&self) -> bool {
        self.location_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_ping(&mut self, v: CDOTAMsg_LocationPing) {
        self.location_ping = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location_ping(&'a mut self) -> &'a mut CDOTAMsg_LocationPing {
        if self.location_ping.is_none() {
            self.location_ping.set_default();
        };
        self.location_ping.as_mut().unwrap()
    }

    pub fn get_location_ping(&'a self) -> &'a CDOTAMsg_LocationPing {
        self.location_ping.as_ref().unwrap_or_else(|| CDOTAMsg_LocationPing::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_LocationPing {
    fn new() -> CDOTAUserMsg_LocationPing {
        CDOTAUserMsg_LocationPing::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.player_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.location_ping.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.player_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.location_ping.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.player_id {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.location_ping.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_LocationPing>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_LocationPing>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_LocationPing_player_id_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_LocationPing>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_LocationPing_location_ping_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_LocationPing>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_LocationPing>(
                    "CDOTAUserMsg_LocationPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_LocationPing>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_LocationPing {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_location_ping();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_LocationPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_LocationPing_player_id_acc_type;
static CDOTAUserMsg_LocationPing_player_id_acc: CDOTAUserMsg_LocationPing_player_id_acc_type = CDOTAUserMsg_LocationPing_player_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_LocationPing> for CDOTAUserMsg_LocationPing_player_id_acc_type {
    fn name(&self) -> &'static str {
        "player_id"
    }

    fn has_field(&self, m: &CDOTAUserMsg_LocationPing) -> bool {
        m.has_player_id()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_LocationPing) -> u32 {
        m.get_player_id()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_LocationPing_location_ping_acc_type;
static CDOTAUserMsg_LocationPing_location_ping_acc: CDOTAUserMsg_LocationPing_location_ping_acc_type = CDOTAUserMsg_LocationPing_location_ping_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_LocationPing> for CDOTAUserMsg_LocationPing_location_ping_acc_type {
    fn name(&self) -> &'static str {
        "location_ping"
    }

    fn has_field(&self, m: &CDOTAUserMsg_LocationPing) -> bool {
        m.has_location_ping()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_LocationPing) -> &'a ::protobuf::Message {
        m.get_location_ping() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_MinimapEvent {
    event_type: Option<i32>,
    entity_handle: Option<i32>,
    x: Option<i32>,
    y: Option<i32>,
    duration: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_MinimapEvent {
    pub fn new() -> CDOTAUserMsg_MinimapEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MinimapEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MinimapEvent> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_MinimapEvent };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_MinimapEvent {
                    event_type: None,
                    entity_handle: None,
                    x: None,
                    y: None,
                    duration: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: i32) {
        self.event_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_type(&'a mut self) -> &'a mut i32 {
        if self.event_type.is_none() {
            self.event_type = Some(0);
        };
        self.event_type.as_mut().unwrap()
    }

    pub fn get_event_type(&self) -> i32 {
        self.event_type.unwrap_or_else(|| 0)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_handle(&'a mut self) -> &'a mut i32 {
        if self.entity_handle.is_none() {
            self.entity_handle = Some(0);
        };
        self.entity_handle.as_mut().unwrap()
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or_else(|| 0)
    }

    pub fn clear_x(&mut self) {
        self.x = None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&'a mut self) -> &'a mut i32 {
        if self.x.is_none() {
            self.x = Some(0);
        };
        self.x.as_mut().unwrap()
    }

    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or_else(|| 0)
    }

    pub fn clear_y(&mut self) {
        self.y = None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&'a mut self) -> &'a mut i32 {
        if self.y.is_none() {
            self.y = Some(0);
        };
        self.y.as_mut().unwrap()
    }

    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or_else(|| 0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut i32 {
        if self.duration.is_none() {
            self.duration = Some(0);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MinimapEvent {
    fn new() -> CDOTAUserMsg_MinimapEvent {
        CDOTAUserMsg_MinimapEvent::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.event_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_handle = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.x = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.y = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.duration = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.event_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entity_handle.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.x.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.y.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.duration.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.event_type {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.entity_handle {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.x {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.y {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_int32(5, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_MinimapEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapEvent_event_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapEvent_entity_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapEvent_x_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapEvent_y_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapEvent_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MinimapEvent>(
                    "CDOTAUserMsg_MinimapEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_MinimapEvent>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MinimapEvent {
    fn clear(&mut self) {
        self.clear_event_type();
        self.clear_entity_handle();
        self.clear_x();
        self.clear_y();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_MinimapEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapEvent_event_type_acc_type;
static CDOTAUserMsg_MinimapEvent_event_type_acc: CDOTAUserMsg_MinimapEvent_event_type_acc_type = CDOTAUserMsg_MinimapEvent_event_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent> for CDOTAUserMsg_MinimapEvent_event_type_acc_type {
    fn name(&self) -> &'static str {
        "event_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapEvent) -> bool {
        m.has_event_type()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MinimapEvent) -> i32 {
        m.get_event_type()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapEvent_entity_handle_acc_type;
static CDOTAUserMsg_MinimapEvent_entity_handle_acc: CDOTAUserMsg_MinimapEvent_entity_handle_acc_type = CDOTAUserMsg_MinimapEvent_entity_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent> for CDOTAUserMsg_MinimapEvent_entity_handle_acc_type {
    fn name(&self) -> &'static str {
        "entity_handle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapEvent) -> bool {
        m.has_entity_handle()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MinimapEvent) -> i32 {
        m.get_entity_handle()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapEvent_x_acc_type;
static CDOTAUserMsg_MinimapEvent_x_acc: CDOTAUserMsg_MinimapEvent_x_acc_type = CDOTAUserMsg_MinimapEvent_x_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent> for CDOTAUserMsg_MinimapEvent_x_acc_type {
    fn name(&self) -> &'static str {
        "x"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapEvent) -> bool {
        m.has_x()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MinimapEvent) -> i32 {
        m.get_x()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapEvent_y_acc_type;
static CDOTAUserMsg_MinimapEvent_y_acc: CDOTAUserMsg_MinimapEvent_y_acc_type = CDOTAUserMsg_MinimapEvent_y_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent> for CDOTAUserMsg_MinimapEvent_y_acc_type {
    fn name(&self) -> &'static str {
        "y"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapEvent) -> bool {
        m.has_y()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MinimapEvent) -> i32 {
        m.get_y()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapEvent_duration_acc_type;
static CDOTAUserMsg_MinimapEvent_duration_acc: CDOTAUserMsg_MinimapEvent_duration_acc_type = CDOTAUserMsg_MinimapEvent_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapEvent> for CDOTAUserMsg_MinimapEvent_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapEvent) -> bool {
        m.has_duration()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MinimapEvent) -> i32 {
        m.get_duration()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_MapLine {
    player_id: Option<i32>,
    mapline: ::protobuf::SingularPtrField<CDOTAMsg_MapLine>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_MapLine {
    pub fn new() -> CDOTAUserMsg_MapLine {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MapLine {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MapLine> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_MapLine };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_MapLine {
                    player_id: None,
                    mapline: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_id(&'a mut self) -> &'a mut i32 {
        if self.player_id.is_none() {
            self.player_id = Some(0);
        };
        self.player_id.as_mut().unwrap()
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or_else(|| 0)
    }

    pub fn clear_mapline(&mut self) {
        self.mapline.clear();
    }

    pub fn has_mapline(&self) -> bool {
        self.mapline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapline(&mut self, v: CDOTAMsg_MapLine) {
        self.mapline = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mapline(&'a mut self) -> &'a mut CDOTAMsg_MapLine {
        if self.mapline.is_none() {
            self.mapline.set_default();
        };
        self.mapline.as_mut().unwrap()
    }

    pub fn get_mapline(&'a self) -> &'a CDOTAMsg_MapLine {
        self.mapline.as_ref().unwrap_or_else(|| CDOTAMsg_MapLine::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MapLine {
    fn new() -> CDOTAUserMsg_MapLine {
        CDOTAUserMsg_MapLine::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.player_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.mapline.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.player_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mapline.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.player_id {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.mapline.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_MapLine>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MapLine>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MapLine_player_id_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MapLine>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MapLine_mapline_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MapLine>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MapLine>(
                    "CDOTAUserMsg_MapLine",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_MapLine>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MapLine {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_mapline();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_MapLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MapLine_player_id_acc_type;
static CDOTAUserMsg_MapLine_player_id_acc: CDOTAUserMsg_MapLine_player_id_acc_type = CDOTAUserMsg_MapLine_player_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MapLine> for CDOTAUserMsg_MapLine_player_id_acc_type {
    fn name(&self) -> &'static str {
        "player_id"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MapLine) -> bool {
        m.has_player_id()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MapLine) -> i32 {
        m.get_player_id()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MapLine_mapline_acc_type;
static CDOTAUserMsg_MapLine_mapline_acc: CDOTAUserMsg_MapLine_mapline_acc_type = CDOTAUserMsg_MapLine_mapline_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MapLine> for CDOTAUserMsg_MapLine_mapline_acc_type {
    fn name(&self) -> &'static str {
        "mapline"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MapLine) -> bool {
        m.has_mapline()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_MapLine) -> &'a ::protobuf::Message {
        m.get_mapline() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_MinimapDebugPoint {
    location: ::protobuf::SingularPtrField<CMsgVector>,
    color: Option<u32>,
    size: Option<i32>,
    duration: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_MinimapDebugPoint {
    pub fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MinimapDebugPoint {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MinimapDebugPoint> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_MinimapDebugPoint };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_MinimapDebugPoint {
                    location: ::protobuf::SingularPtrField::none(),
                    color: None,
                    size: None,
                    duration: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: CMsgVector) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&'a mut self) -> &'a mut CMsgVector {
        if self.location.is_none() {
            self.location.set_default();
        };
        self.location.as_mut().unwrap()
    }

    pub fn get_location(&'a self) -> &'a CMsgVector {
        self.location.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }

    pub fn clear_color(&mut self) {
        self.color = None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&'a mut self) -> &'a mut u32 {
        if self.color.is_none() {
            self.color = Some(0);
        };
        self.color.as_mut().unwrap()
    }

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or_else(|| 0)
    }

    pub fn clear_size(&mut self) {
        self.size = None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size(&'a mut self) -> &'a mut i32 {
        if self.size.is_none() {
            self.size = Some(0);
        };
        self.size.as_mut().unwrap()
    }

    pub fn get_size(&self) -> i32 {
        self.size.unwrap_or_else(|| 0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&'a mut self) -> &'a mut f32 {
        if self.duration.is_none() {
            self.duration = Some(0.);
        };
        self.duration.as_mut().unwrap()
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MinimapDebugPoint {
    fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        CDOTAUserMsg_MinimapDebugPoint::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.location.set_default();
                    is.merge_message(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.color = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.size = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.duration = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.location.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.color.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.size.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.duration.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.location.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.color {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.size {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.duration {
            Some(ref v) => {
                os.write_float(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_MinimapDebugPoint>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapDebugPoint_location_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapDebugPoint_color_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapDebugPoint_size_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_MinimapDebugPoint_duration_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MinimapDebugPoint>(
                    "CDOTAUserMsg_MinimapDebugPoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_MinimapDebugPoint>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MinimapDebugPoint {
    fn clear(&mut self) {
        self.clear_location();
        self.clear_color();
        self.clear_size();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_MinimapDebugPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapDebugPoint_location_acc_type;
static CDOTAUserMsg_MinimapDebugPoint_location_acc: CDOTAUserMsg_MinimapDebugPoint_location_acc_type = CDOTAUserMsg_MinimapDebugPoint_location_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint> for CDOTAUserMsg_MinimapDebugPoint_location_acc_type {
    fn name(&self) -> &'static str {
        "location"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapDebugPoint) -> bool {
        m.has_location()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_MinimapDebugPoint) -> &'a ::protobuf::Message {
        m.get_location() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapDebugPoint_color_acc_type;
static CDOTAUserMsg_MinimapDebugPoint_color_acc: CDOTAUserMsg_MinimapDebugPoint_color_acc_type = CDOTAUserMsg_MinimapDebugPoint_color_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint> for CDOTAUserMsg_MinimapDebugPoint_color_acc_type {
    fn name(&self) -> &'static str {
        "color"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapDebugPoint) -> bool {
        m.has_color()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_MinimapDebugPoint) -> u32 {
        m.get_color()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapDebugPoint_size_acc_type;
static CDOTAUserMsg_MinimapDebugPoint_size_acc: CDOTAUserMsg_MinimapDebugPoint_size_acc_type = CDOTAUserMsg_MinimapDebugPoint_size_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint> for CDOTAUserMsg_MinimapDebugPoint_size_acc_type {
    fn name(&self) -> &'static str {
        "size"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapDebugPoint) -> bool {
        m.has_size()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_MinimapDebugPoint) -> i32 {
        m.get_size()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_MinimapDebugPoint_duration_acc_type;
static CDOTAUserMsg_MinimapDebugPoint_duration_acc: CDOTAUserMsg_MinimapDebugPoint_duration_acc_type = CDOTAUserMsg_MinimapDebugPoint_duration_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_MinimapDebugPoint> for CDOTAUserMsg_MinimapDebugPoint_duration_acc_type {
    fn name(&self) -> &'static str {
        "duration"
    }

    fn has_field(&self, m: &CDOTAUserMsg_MinimapDebugPoint) -> bool {
        m.has_duration()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_MinimapDebugPoint) -> f32 {
        m.get_duration()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_CreateLinearProjectile {
    origin: ::protobuf::SingularPtrField<CMsgVector>,
    velocity: ::protobuf::SingularPtrField<CMsgVector2D>,
    latency: Option<i32>,
    entindex: Option<i32>,
    particle_index: Option<i32>,
    handle: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_CreateLinearProjectile {
    pub fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CreateLinearProjectile {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CreateLinearProjectile> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_CreateLinearProjectile };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_CreateLinearProjectile {
                    origin: ::protobuf::SingularPtrField::none(),
                    velocity: ::protobuf::SingularPtrField::none(),
                    latency: None,
                    entindex: None,
                    particle_index: None,
                    handle: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: CMsgVector) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&'a mut self) -> &'a mut CMsgVector {
        if self.origin.is_none() {
            self.origin.set_default();
        };
        self.origin.as_mut().unwrap()
    }

    pub fn get_origin(&'a self) -> &'a CMsgVector {
        self.origin.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }

    pub fn clear_velocity(&mut self) {
        self.velocity.clear();
    }

    pub fn has_velocity(&self) -> bool {
        self.velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity(&mut self, v: CMsgVector2D) {
        self.velocity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity(&'a mut self) -> &'a mut CMsgVector2D {
        if self.velocity.is_none() {
            self.velocity.set_default();
        };
        self.velocity.as_mut().unwrap()
    }

    pub fn get_velocity(&'a self) -> &'a CMsgVector2D {
        self.velocity.as_ref().unwrap_or_else(|| CMsgVector2D::default_instance())
    }

    pub fn clear_latency(&mut self) {
        self.latency = None;
    }

    pub fn has_latency(&self) -> bool {
        self.latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latency(&mut self, v: i32) {
        self.latency = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latency(&'a mut self) -> &'a mut i32 {
        if self.latency.is_none() {
            self.latency = Some(0);
        };
        self.latency.as_mut().unwrap()
    }

    pub fn get_latency(&self) -> i32 {
        self.latency.unwrap_or_else(|| 0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entindex(&'a mut self) -> &'a mut i32 {
        if self.entindex.is_none() {
            self.entindex = Some(0);
        };
        self.entindex.as_mut().unwrap()
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or_else(|| 0)
    }

    pub fn clear_particle_index(&mut self) {
        self.particle_index = None;
    }

    pub fn has_particle_index(&self) -> bool {
        self.particle_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_index(&mut self, v: i32) {
        self.particle_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_particle_index(&'a mut self) -> &'a mut i32 {
        if self.particle_index.is_none() {
            self.particle_index = Some(0);
        };
        self.particle_index.as_mut().unwrap()
    }

    pub fn get_particle_index(&self) -> i32 {
        self.particle_index.unwrap_or_else(|| 0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&'a mut self) -> &'a mut i32 {
        if self.handle.is_none() {
            self.handle = Some(0);
        };
        self.handle.as_mut().unwrap()
    }

    pub fn get_handle(&self) -> i32 {
        self.handle.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CreateLinearProjectile {
    fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        CDOTAUserMsg_CreateLinearProjectile::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.origin.set_default();
                    is.merge_message(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.velocity.set_default();
                    is.merge_message(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.latency = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entindex = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.particle_index = Some(tmp);
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.handle = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.origin.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.velocity.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.latency.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entindex.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.particle_index.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.handle.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.origin.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.velocity.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.latency {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.entindex {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.particle_index {
            Some(ref v) => {
                os.write_int32(5, *v);
            },
            None => {},
        };
        match self.handle {
            Some(ref v) => {
                os.write_int32(6, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_CreateLinearProjectile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CreateLinearProjectile_origin_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CreateLinearProjectile_velocity_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CreateLinearProjectile_latency_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CreateLinearProjectile_entindex_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CreateLinearProjectile_particle_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_CreateLinearProjectile_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CreateLinearProjectile>(
                    "CDOTAUserMsg_CreateLinearProjectile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_CreateLinearProjectile>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CreateLinearProjectile {
    fn clear(&mut self) {
        self.clear_origin();
        self.clear_velocity();
        self.clear_latency();
        self.clear_entindex();
        self.clear_particle_index();
        self.clear_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_CreateLinearProjectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CreateLinearProjectile_origin_acc_type;
static CDOTAUserMsg_CreateLinearProjectile_origin_acc: CDOTAUserMsg_CreateLinearProjectile_origin_acc_type = CDOTAUserMsg_CreateLinearProjectile_origin_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile> for CDOTAUserMsg_CreateLinearProjectile_origin_acc_type {
    fn name(&self) -> &'static str {
        "origin"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> bool {
        m.has_origin()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_CreateLinearProjectile) -> &'a ::protobuf::Message {
        m.get_origin() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CreateLinearProjectile_velocity_acc_type;
static CDOTAUserMsg_CreateLinearProjectile_velocity_acc: CDOTAUserMsg_CreateLinearProjectile_velocity_acc_type = CDOTAUserMsg_CreateLinearProjectile_velocity_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile> for CDOTAUserMsg_CreateLinearProjectile_velocity_acc_type {
    fn name(&self) -> &'static str {
        "velocity"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> bool {
        m.has_velocity()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_CreateLinearProjectile) -> &'a ::protobuf::Message {
        m.get_velocity() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CreateLinearProjectile_latency_acc_type;
static CDOTAUserMsg_CreateLinearProjectile_latency_acc: CDOTAUserMsg_CreateLinearProjectile_latency_acc_type = CDOTAUserMsg_CreateLinearProjectile_latency_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile> for CDOTAUserMsg_CreateLinearProjectile_latency_acc_type {
    fn name(&self) -> &'static str {
        "latency"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> bool {
        m.has_latency()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> i32 {
        m.get_latency()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CreateLinearProjectile_entindex_acc_type;
static CDOTAUserMsg_CreateLinearProjectile_entindex_acc: CDOTAUserMsg_CreateLinearProjectile_entindex_acc_type = CDOTAUserMsg_CreateLinearProjectile_entindex_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile> for CDOTAUserMsg_CreateLinearProjectile_entindex_acc_type {
    fn name(&self) -> &'static str {
        "entindex"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> bool {
        m.has_entindex()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> i32 {
        m.get_entindex()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CreateLinearProjectile_particle_index_acc_type;
static CDOTAUserMsg_CreateLinearProjectile_particle_index_acc: CDOTAUserMsg_CreateLinearProjectile_particle_index_acc_type = CDOTAUserMsg_CreateLinearProjectile_particle_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile> for CDOTAUserMsg_CreateLinearProjectile_particle_index_acc_type {
    fn name(&self) -> &'static str {
        "particle_index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> bool {
        m.has_particle_index()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> i32 {
        m.get_particle_index()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_CreateLinearProjectile_handle_acc_type;
static CDOTAUserMsg_CreateLinearProjectile_handle_acc: CDOTAUserMsg_CreateLinearProjectile_handle_acc_type = CDOTAUserMsg_CreateLinearProjectile_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_CreateLinearProjectile> for CDOTAUserMsg_CreateLinearProjectile_handle_acc_type {
    fn name(&self) -> &'static str {
        "handle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> bool {
        m.has_handle()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_CreateLinearProjectile) -> i32 {
        m.get_handle()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_DestroyLinearProjectile {
    handle: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_DestroyLinearProjectile {
    pub fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_DestroyLinearProjectile {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_DestroyLinearProjectile> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_DestroyLinearProjectile };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_DestroyLinearProjectile {
                    handle: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_handle(&mut self) {
        self.handle = None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&'a mut self) -> &'a mut i32 {
        if self.handle.is_none() {
            self.handle = Some(0);
        };
        self.handle.as_mut().unwrap()
    }

    pub fn get_handle(&self) -> i32 {
        self.handle.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DestroyLinearProjectile {
    fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        CDOTAUserMsg_DestroyLinearProjectile::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.handle = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.handle.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.handle {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_DestroyLinearProjectile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_DestroyLinearProjectile>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_DestroyLinearProjectile_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_DestroyLinearProjectile>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_DestroyLinearProjectile>(
                    "CDOTAUserMsg_DestroyLinearProjectile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_DestroyLinearProjectile>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_DestroyLinearProjectile {
    fn clear(&mut self) {
        self.clear_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_DestroyLinearProjectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_DestroyLinearProjectile_handle_acc_type;
static CDOTAUserMsg_DestroyLinearProjectile_handle_acc: CDOTAUserMsg_DestroyLinearProjectile_handle_acc_type = CDOTAUserMsg_DestroyLinearProjectile_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_DestroyLinearProjectile> for CDOTAUserMsg_DestroyLinearProjectile_handle_acc_type {
    fn name(&self) -> &'static str {
        "handle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_DestroyLinearProjectile) -> bool {
        m.has_handle()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_DestroyLinearProjectile) -> i32 {
        m.get_handle()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_DodgeTrackingProjectiles {
    entindex: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_DodgeTrackingProjectiles {
    pub fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_DodgeTrackingProjectiles {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_DodgeTrackingProjectiles> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_DodgeTrackingProjectiles };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_DodgeTrackingProjectiles {
                    entindex: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entindex(&'a mut self) -> &'a mut i32 {
        if self.entindex.is_none() {
            self.entindex = Some(0);
        };
        self.entindex.as_mut().unwrap()
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        CDOTAUserMsg_DodgeTrackingProjectiles::new()
    }

    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entindex = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.entindex.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.entindex {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_DodgeTrackingProjectiles>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_DodgeTrackingProjectiles>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_DodgeTrackingProjectiles_entindex_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_DodgeTrackingProjectiles>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_DodgeTrackingProjectiles>(
                    "CDOTAUserMsg_DodgeTrackingProjectiles",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_DodgeTrackingProjectiles>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn clear(&mut self) {
        self.clear_entindex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_DodgeTrackingProjectiles_entindex_acc_type;
static CDOTAUserMsg_DodgeTrackingProjectiles_entindex_acc: CDOTAUserMsg_DodgeTrackingProjectiles_entindex_acc_type = CDOTAUserMsg_DodgeTrackingProjectiles_entindex_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_DodgeTrackingProjectiles> for CDOTAUserMsg_DodgeTrackingProjectiles_entindex_acc_type {
    fn name(&self) -> &'static str {
        "entindex"
    }

    fn has_field(&self, m: &CDOTAUserMsg_DodgeTrackingProjectiles) -> bool {
        m.has_entindex()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_DodgeTrackingProjectiles) -> i32 {
        m.get_entindex()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_SpectatorPlayerClick {
    entindex: Option<i32>,
    order_type: Option<i32>,
    target_index: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_SpectatorPlayerClick {
    pub fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SpectatorPlayerClick {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SpectatorPlayerClick> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_SpectatorPlayerClick };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_SpectatorPlayerClick {
                    entindex: None,
                    order_type: None,
                    target_index: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entindex(&'a mut self) -> &'a mut i32 {
        if self.entindex.is_none() {
            self.entindex = Some(0);
        };
        self.entindex.as_mut().unwrap()
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or_else(|| 0)
    }

    pub fn clear_order_type(&mut self) {
        self.order_type = None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&'a mut self) -> &'a mut i32 {
        if self.order_type.is_none() {
            self.order_type = Some(0);
        };
        self.order_type.as_mut().unwrap()
    }

    pub fn get_order_type(&self) -> i32 {
        self.order_type.unwrap_or_else(|| 0)
    }

    pub fn clear_target_index(&mut self) {
        self.target_index = None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_index(&'a mut self) -> &'a mut i32 {
        if self.target_index.is_none() {
            self.target_index = Some(0);
        };
        self.target_index.as_mut().unwrap()
    }

    pub fn get_target_index(&self) -> i32 {
        self.target_index.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SpectatorPlayerClick {
    fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        CDOTAUserMsg_SpectatorPlayerClick::new()
    }

    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entindex = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.order_type = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.target_index = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.entindex.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.order_type.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.target_index.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.entindex {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.order_type {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.target_index {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_SpectatorPlayerClick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SpectatorPlayerClick>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SpectatorPlayerClick_entindex_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SpectatorPlayerClick>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SpectatorPlayerClick_order_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SpectatorPlayerClick>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SpectatorPlayerClick_target_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SpectatorPlayerClick>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SpectatorPlayerClick>(
                    "CDOTAUserMsg_SpectatorPlayerClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_SpectatorPlayerClick>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SpectatorPlayerClick {
    fn clear(&mut self) {
        self.clear_entindex();
        self.clear_order_type();
        self.clear_target_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_SpectatorPlayerClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SpectatorPlayerClick_entindex_acc_type;
static CDOTAUserMsg_SpectatorPlayerClick_entindex_acc: CDOTAUserMsg_SpectatorPlayerClick_entindex_acc_type = CDOTAUserMsg_SpectatorPlayerClick_entindex_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SpectatorPlayerClick> for CDOTAUserMsg_SpectatorPlayerClick_entindex_acc_type {
    fn name(&self) -> &'static str {
        "entindex"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SpectatorPlayerClick) -> bool {
        m.has_entindex()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_SpectatorPlayerClick) -> i32 {
        m.get_entindex()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SpectatorPlayerClick_order_type_acc_type;
static CDOTAUserMsg_SpectatorPlayerClick_order_type_acc: CDOTAUserMsg_SpectatorPlayerClick_order_type_acc_type = CDOTAUserMsg_SpectatorPlayerClick_order_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SpectatorPlayerClick> for CDOTAUserMsg_SpectatorPlayerClick_order_type_acc_type {
    fn name(&self) -> &'static str {
        "order_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SpectatorPlayerClick) -> bool {
        m.has_order_type()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_SpectatorPlayerClick) -> i32 {
        m.get_order_type()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SpectatorPlayerClick_target_index_acc_type;
static CDOTAUserMsg_SpectatorPlayerClick_target_index_acc: CDOTAUserMsg_SpectatorPlayerClick_target_index_acc_type = CDOTAUserMsg_SpectatorPlayerClick_target_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SpectatorPlayerClick> for CDOTAUserMsg_SpectatorPlayerClick_target_index_acc_type {
    fn name(&self) -> &'static str {
        "target_index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SpectatorPlayerClick) -> bool {
        m.has_target_index()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_SpectatorPlayerClick) -> i32 {
        m.get_target_index()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_NevermoreRequiem {
    entity_handle: Option<i32>,
    lines: Option<i32>,
    origin: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_NevermoreRequiem {
    pub fn new() -> CDOTAUserMsg_NevermoreRequiem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_NevermoreRequiem {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_NevermoreRequiem> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_NevermoreRequiem };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_NevermoreRequiem {
                    entity_handle: None,
                    lines: None,
                    origin: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_handle(&'a mut self) -> &'a mut i32 {
        if self.entity_handle.is_none() {
            self.entity_handle = Some(0);
        };
        self.entity_handle.as_mut().unwrap()
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or_else(|| 0)
    }

    pub fn clear_lines(&mut self) {
        self.lines = None;
    }

    pub fn has_lines(&self) -> bool {
        self.lines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lines(&mut self, v: i32) {
        self.lines = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lines(&'a mut self) -> &'a mut i32 {
        if self.lines.is_none() {
            self.lines = Some(0);
        };
        self.lines.as_mut().unwrap()
    }

    pub fn get_lines(&self) -> i32 {
        self.lines.unwrap_or_else(|| 0)
    }

    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: CMsgVector) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&'a mut self) -> &'a mut CMsgVector {
        if self.origin.is_none() {
            self.origin.set_default();
        };
        self.origin.as_mut().unwrap()
    }

    pub fn get_origin(&'a self) -> &'a CMsgVector {
        self.origin.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_NevermoreRequiem {
    fn new() -> CDOTAUserMsg_NevermoreRequiem {
        CDOTAUserMsg_NevermoreRequiem::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_handle = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.lines = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.origin.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.entity_handle.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lines.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.origin.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.entity_handle {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.lines {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.origin.as_ref() {
            Some(ref v) => {
                os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_NevermoreRequiem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_NevermoreRequiem>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_NevermoreRequiem_entity_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_NevermoreRequiem>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_NevermoreRequiem_lines_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_NevermoreRequiem>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_NevermoreRequiem_origin_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_NevermoreRequiem>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_NevermoreRequiem>(
                    "CDOTAUserMsg_NevermoreRequiem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_NevermoreRequiem>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_NevermoreRequiem {
    fn clear(&mut self) {
        self.clear_entity_handle();
        self.clear_lines();
        self.clear_origin();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_NevermoreRequiem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_NevermoreRequiem_entity_handle_acc_type;
static CDOTAUserMsg_NevermoreRequiem_entity_handle_acc: CDOTAUserMsg_NevermoreRequiem_entity_handle_acc_type = CDOTAUserMsg_NevermoreRequiem_entity_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_NevermoreRequiem> for CDOTAUserMsg_NevermoreRequiem_entity_handle_acc_type {
    fn name(&self) -> &'static str {
        "entity_handle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_NevermoreRequiem) -> bool {
        m.has_entity_handle()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_NevermoreRequiem) -> i32 {
        m.get_entity_handle()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_NevermoreRequiem_lines_acc_type;
static CDOTAUserMsg_NevermoreRequiem_lines_acc: CDOTAUserMsg_NevermoreRequiem_lines_acc_type = CDOTAUserMsg_NevermoreRequiem_lines_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_NevermoreRequiem> for CDOTAUserMsg_NevermoreRequiem_lines_acc_type {
    fn name(&self) -> &'static str {
        "lines"
    }

    fn has_field(&self, m: &CDOTAUserMsg_NevermoreRequiem) -> bool {
        m.has_lines()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_NevermoreRequiem) -> i32 {
        m.get_lines()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_NevermoreRequiem_origin_acc_type;
static CDOTAUserMsg_NevermoreRequiem_origin_acc: CDOTAUserMsg_NevermoreRequiem_origin_acc_type = CDOTAUserMsg_NevermoreRequiem_origin_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_NevermoreRequiem> for CDOTAUserMsg_NevermoreRequiem_origin_acc_type {
    fn name(&self) -> &'static str {
        "origin"
    }

    fn has_field(&self, m: &CDOTAUserMsg_NevermoreRequiem) -> bool {
        m.has_origin()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_NevermoreRequiem) -> &'a ::protobuf::Message {
        m.get_origin() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_InvalidCommand {
    message: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_InvalidCommand {
    pub fn new() -> CDOTAUserMsg_InvalidCommand {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_InvalidCommand {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_InvalidCommand> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_InvalidCommand };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_InvalidCommand {
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&'a mut self) -> &'a mut String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    pub fn get_message(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_InvalidCommand {
    fn new() -> CDOTAUserMsg_InvalidCommand {
        CDOTAUserMsg_InvalidCommand::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.message.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.message.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_InvalidCommand>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_InvalidCommand>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_InvalidCommand_message_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_InvalidCommand>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_InvalidCommand>(
                    "CDOTAUserMsg_InvalidCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_InvalidCommand>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_InvalidCommand {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_InvalidCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_InvalidCommand_message_acc_type;
static CDOTAUserMsg_InvalidCommand_message_acc: CDOTAUserMsg_InvalidCommand_message_acc_type = CDOTAUserMsg_InvalidCommand_message_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_InvalidCommand> for CDOTAUserMsg_InvalidCommand_message_acc_type {
    fn name(&self) -> &'static str {
        "message"
    }

    fn has_field(&self, m: &CDOTAUserMsg_InvalidCommand) -> bool {
        m.has_message()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_InvalidCommand) -> &'a str {
        m.get_message()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_HudError {
    order_id: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_HudError {
    pub fn new() -> CDOTAUserMsg_HudError {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_HudError {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_HudError> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_HudError };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_HudError {
                    order_id: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_id(&'a mut self) -> &'a mut i32 {
        if self.order_id.is_none() {
            self.order_id = Some(0);
        };
        self.order_id.as_mut().unwrap()
    }

    pub fn get_order_id(&self) -> i32 {
        self.order_id.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HudError {
    fn new() -> CDOTAUserMsg_HudError {
        CDOTAUserMsg_HudError::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.order_id = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.order_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.order_id {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_HudError>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_HudError>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_HudError_order_id_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_HudError>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_HudError>(
                    "CDOTAUserMsg_HudError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_HudError>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_HudError {
    fn clear(&mut self) {
        self.clear_order_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_HudError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_HudError_order_id_acc_type;
static CDOTAUserMsg_HudError_order_id_acc: CDOTAUserMsg_HudError_order_id_acc_type = CDOTAUserMsg_HudError_order_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_HudError> for CDOTAUserMsg_HudError_order_id_acc_type {
    fn name(&self) -> &'static str {
        "order_id"
    }

    fn has_field(&self, m: &CDOTAUserMsg_HudError) -> bool {
        m.has_order_id()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_HudError) -> i32 {
        m.get_order_id()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_SharedCooldown {
    entindex: Option<i32>,
    name: ::protobuf::SingularField<String>,
    cooldown: Option<f32>,
    name_index: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_SharedCooldown {
    pub fn new() -> CDOTAUserMsg_SharedCooldown {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SharedCooldown {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SharedCooldown> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_SharedCooldown };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_SharedCooldown {
                    entindex: None,
                    name: ::protobuf::SingularField::none(),
                    cooldown: None,
                    name_index: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entindex(&'a mut self) -> &'a mut i32 {
        if self.entindex.is_none() {
            self.entindex = Some(0);
        };
        self.entindex.as_mut().unwrap()
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or_else(|| 0)
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_cooldown(&mut self) {
        self.cooldown = None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cooldown(&'a mut self) -> &'a mut f32 {
        if self.cooldown.is_none() {
            self.cooldown = Some(0.);
        };
        self.cooldown.as_mut().unwrap()
    }

    pub fn get_cooldown(&self) -> f32 {
        self.cooldown.unwrap_or_else(|| 0.)
    }

    pub fn clear_name_index(&mut self) {
        self.name_index = None;
    }

    pub fn has_name_index(&self) -> bool {
        self.name_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_index(&mut self, v: i32) {
        self.name_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_index(&'a mut self) -> &'a mut i32 {
        if self.name_index.is_none() {
            self.name_index = Some(0);
        };
        self.name_index.as_mut().unwrap()
    }

    pub fn get_name_index(&self) -> i32 {
        self.name_index.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SharedCooldown {
    fn new() -> CDOTAUserMsg_SharedCooldown {
        CDOTAUserMsg_SharedCooldown::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entindex = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.cooldown = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.name_index = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.entindex.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        if self.cooldown.is_some() {
            my_size += 5;
        };
        for value in self.name_index.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.entindex {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.cooldown {
            Some(ref v) => {
                os.write_float(3, *v);
            },
            None => {},
        };
        match self.name_index {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_SharedCooldown>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SharedCooldown_entindex_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SharedCooldown_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SharedCooldown_cooldown_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SharedCooldown_name_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SharedCooldown>(
                    "CDOTAUserMsg_SharedCooldown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_SharedCooldown>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SharedCooldown {
    fn clear(&mut self) {
        self.clear_entindex();
        self.clear_name();
        self.clear_cooldown();
        self.clear_name_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_SharedCooldown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SharedCooldown_entindex_acc_type;
static CDOTAUserMsg_SharedCooldown_entindex_acc: CDOTAUserMsg_SharedCooldown_entindex_acc_type = CDOTAUserMsg_SharedCooldown_entindex_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown> for CDOTAUserMsg_SharedCooldown_entindex_acc_type {
    fn name(&self) -> &'static str {
        "entindex"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SharedCooldown) -> bool {
        m.has_entindex()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_SharedCooldown) -> i32 {
        m.get_entindex()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SharedCooldown_name_acc_type;
static CDOTAUserMsg_SharedCooldown_name_acc: CDOTAUserMsg_SharedCooldown_name_acc_type = CDOTAUserMsg_SharedCooldown_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown> for CDOTAUserMsg_SharedCooldown_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SharedCooldown) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_SharedCooldown) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SharedCooldown_cooldown_acc_type;
static CDOTAUserMsg_SharedCooldown_cooldown_acc: CDOTAUserMsg_SharedCooldown_cooldown_acc_type = CDOTAUserMsg_SharedCooldown_cooldown_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown> for CDOTAUserMsg_SharedCooldown_cooldown_acc_type {
    fn name(&self) -> &'static str {
        "cooldown"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SharedCooldown) -> bool {
        m.has_cooldown()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_SharedCooldown) -> f32 {
        m.get_cooldown()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SharedCooldown_name_index_acc_type;
static CDOTAUserMsg_SharedCooldown_name_index_acc: CDOTAUserMsg_SharedCooldown_name_index_acc_type = CDOTAUserMsg_SharedCooldown_name_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SharedCooldown> for CDOTAUserMsg_SharedCooldown_name_index_acc_type {
    fn name(&self) -> &'static str {
        "name_index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SharedCooldown) -> bool {
        m.has_name_index()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_SharedCooldown) -> i32 {
        m.get_name_index()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_SetNextAutobuyItem {
    name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_SetNextAutobuyItem {
    pub fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SetNextAutobuyItem {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SetNextAutobuyItem> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_SetNextAutobuyItem };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_SetNextAutobuyItem {
                    name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SetNextAutobuyItem {
    fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        CDOTAUserMsg_SetNextAutobuyItem::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_SetNextAutobuyItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SetNextAutobuyItem>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_SetNextAutobuyItem_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SetNextAutobuyItem>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SetNextAutobuyItem>(
                    "CDOTAUserMsg_SetNextAutobuyItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_SetNextAutobuyItem>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SetNextAutobuyItem {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_SetNextAutobuyItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_SetNextAutobuyItem_name_acc_type;
static CDOTAUserMsg_SetNextAutobuyItem_name_acc: CDOTAUserMsg_SetNextAutobuyItem_name_acc_type = CDOTAUserMsg_SetNextAutobuyItem_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_SetNextAutobuyItem> for CDOTAUserMsg_SetNextAutobuyItem_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CDOTAUserMsg_SetNextAutobuyItem) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_SetNextAutobuyItem) -> &'a str {
        m.get_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_UnitEvent {
    msg_type: Option<EDotaEntityMessages>,
    entity_index: Option<i32>,
    speech: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_Speech>,
    speech_mute: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_SpeechMute>,
    add_gesture: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_AddGesture>,
    remove_gesture: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_RemoveGesture>,
    blood_impact: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_BloodImpact>,
    fade_gesture: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_FadeGesture>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_UnitEvent {
    pub fn new() -> CDOTAUserMsg_UnitEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_UnitEvent };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_UnitEvent {
                    msg_type: None,
                    entity_index: None,
                    speech: ::protobuf::SingularPtrField::none(),
                    speech_mute: ::protobuf::SingularPtrField::none(),
                    add_gesture: ::protobuf::SingularPtrField::none(),
                    remove_gesture: ::protobuf::SingularPtrField::none(),
                    blood_impact: ::protobuf::SingularPtrField::none(),
                    fade_gesture: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: EDotaEntityMessages) {
        self.msg_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_type(&'a mut self) -> &'a mut EDotaEntityMessages {
        if self.msg_type.is_none() {
            self.msg_type = Some(EDotaEntityMessages::new(0));
        };
        self.msg_type.as_mut().unwrap()
    }

    pub fn get_msg_type(&self) -> EDotaEntityMessages {
        self.msg_type.unwrap_or_else(|| EDotaEntityMessages::new(0))
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_index(&'a mut self) -> &'a mut i32 {
        if self.entity_index.is_none() {
            self.entity_index = Some(0);
        };
        self.entity_index.as_mut().unwrap()
    }

    pub fn get_entity_index(&self) -> i32 {
        self.entity_index.unwrap_or_else(|| 0)
    }

    pub fn clear_speech(&mut self) {
        self.speech.clear();
    }

    pub fn has_speech(&self) -> bool {
        self.speech.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speech(&mut self, v: CDOTAUserMsg_UnitEvent_Speech) {
        self.speech = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speech(&'a mut self) -> &'a mut CDOTAUserMsg_UnitEvent_Speech {
        if self.speech.is_none() {
            self.speech.set_default();
        };
        self.speech.as_mut().unwrap()
    }

    pub fn get_speech(&'a self) -> &'a CDOTAUserMsg_UnitEvent_Speech {
        self.speech.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_Speech::default_instance())
    }

    pub fn clear_speech_mute(&mut self) {
        self.speech_mute.clear();
    }

    pub fn has_speech_mute(&self) -> bool {
        self.speech_mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speech_mute(&mut self, v: CDOTAUserMsg_UnitEvent_SpeechMute) {
        self.speech_mute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speech_mute(&'a mut self) -> &'a mut CDOTAUserMsg_UnitEvent_SpeechMute {
        if self.speech_mute.is_none() {
            self.speech_mute.set_default();
        };
        self.speech_mute.as_mut().unwrap()
    }

    pub fn get_speech_mute(&'a self) -> &'a CDOTAUserMsg_UnitEvent_SpeechMute {
        self.speech_mute.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_SpeechMute::default_instance())
    }

    pub fn clear_add_gesture(&mut self) {
        self.add_gesture.clear();
    }

    pub fn has_add_gesture(&self) -> bool {
        self.add_gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_gesture(&mut self, v: CDOTAUserMsg_UnitEvent_AddGesture) {
        self.add_gesture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_add_gesture(&'a mut self) -> &'a mut CDOTAUserMsg_UnitEvent_AddGesture {
        if self.add_gesture.is_none() {
            self.add_gesture.set_default();
        };
        self.add_gesture.as_mut().unwrap()
    }

    pub fn get_add_gesture(&'a self) -> &'a CDOTAUserMsg_UnitEvent_AddGesture {
        self.add_gesture.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_AddGesture::default_instance())
    }

    pub fn clear_remove_gesture(&mut self) {
        self.remove_gesture.clear();
    }

    pub fn has_remove_gesture(&self) -> bool {
        self.remove_gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_gesture(&mut self, v: CDOTAUserMsg_UnitEvent_RemoveGesture) {
        self.remove_gesture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remove_gesture(&'a mut self) -> &'a mut CDOTAUserMsg_UnitEvent_RemoveGesture {
        if self.remove_gesture.is_none() {
            self.remove_gesture.set_default();
        };
        self.remove_gesture.as_mut().unwrap()
    }

    pub fn get_remove_gesture(&'a self) -> &'a CDOTAUserMsg_UnitEvent_RemoveGesture {
        self.remove_gesture.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_RemoveGesture::default_instance())
    }

    pub fn clear_blood_impact(&mut self) {
        self.blood_impact.clear();
    }

    pub fn has_blood_impact(&self) -> bool {
        self.blood_impact.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blood_impact(&mut self, v: CDOTAUserMsg_UnitEvent_BloodImpact) {
        self.blood_impact = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blood_impact(&'a mut self) -> &'a mut CDOTAUserMsg_UnitEvent_BloodImpact {
        if self.blood_impact.is_none() {
            self.blood_impact.set_default();
        };
        self.blood_impact.as_mut().unwrap()
    }

    pub fn get_blood_impact(&'a self) -> &'a CDOTAUserMsg_UnitEvent_BloodImpact {
        self.blood_impact.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_BloodImpact::default_instance())
    }

    pub fn clear_fade_gesture(&mut self) {
        self.fade_gesture.clear();
    }

    pub fn has_fade_gesture(&self) -> bool {
        self.fade_gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_gesture(&mut self, v: CDOTAUserMsg_UnitEvent_FadeGesture) {
        self.fade_gesture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fade_gesture(&'a mut self) -> &'a mut CDOTAUserMsg_UnitEvent_FadeGesture {
        if self.fade_gesture.is_none() {
            self.fade_gesture.set_default();
        };
        self.fade_gesture.as_mut().unwrap()
    }

    pub fn get_fade_gesture(&'a self) -> &'a CDOTAUserMsg_UnitEvent_FadeGesture {
        self.fade_gesture.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_FadeGesture::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent {
    fn new() -> CDOTAUserMsg_UnitEvent {
        CDOTAUserMsg_UnitEvent::new()
    }

    fn is_initialized(&self) -> bool {
        if self.msg_type.is_none() {
            return false;
        };
        if self.entity_index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = EDotaEntityMessages::new(is.read_int32());
                    self.msg_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_index = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.speech.set_default();
                    is.merge_message(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.speech_mute.set_default();
                    is.merge_message(tmp)
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.add_gesture.set_default();
                    is.merge_message(tmp)
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.remove_gesture.set_default();
                    is.merge_message(tmp)
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.blood_impact.set_default();
                    is.merge_message(tmp)
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.fade_gesture.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.msg_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.entity_index.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.speech.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.speech_mute.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.add_gesture.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.remove_gesture.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.blood_impact.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.fade_gesture.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.msg_type {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        match self.entity_index {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.speech.as_ref() {
            Some(ref v) => {
                os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.speech_mute.as_ref() {
            Some(ref v) => {
                os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.add_gesture.as_ref() {
            Some(ref v) => {
                os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.remove_gesture.as_ref() {
            Some(ref v) => {
                os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.blood_impact.as_ref() {
            Some(ref v) => {
                os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.fade_gesture.as_ref() {
            Some(ref v) => {
                os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_UnitEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_msg_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_entity_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_speech_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_speech_mute_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_add_gesture_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_remove_gesture_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_blood_impact_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_fade_gesture_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent>(
                    "CDOTAUserMsg_UnitEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_UnitEvent>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent {
    fn clear(&mut self) {
        self.clear_msg_type();
        self.clear_entity_index();
        self.clear_speech();
        self.clear_speech_mute();
        self.clear_add_gesture();
        self.clear_remove_gesture();
        self.clear_blood_impact();
        self.clear_fade_gesture();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_UnitEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_msg_type_acc_type;
static CDOTAUserMsg_UnitEvent_msg_type_acc: CDOTAUserMsg_UnitEvent_msg_type_acc_type = CDOTAUserMsg_UnitEvent_msg_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_msg_type_acc_type {
    fn name(&self) -> &'static str {
        "msg_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_msg_type()
    }

    fn get_enum<'a>(&self, m: &CDOTAUserMsg_UnitEvent) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_msg_type().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_entity_index_acc_type;
static CDOTAUserMsg_UnitEvent_entity_index_acc: CDOTAUserMsg_UnitEvent_entity_index_acc_type = CDOTAUserMsg_UnitEvent_entity_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_entity_index_acc_type {
    fn name(&self) -> &'static str {
        "entity_index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_entity_index()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent) -> i32 {
        m.get_entity_index()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_speech_acc_type;
static CDOTAUserMsg_UnitEvent_speech_acc: CDOTAUserMsg_UnitEvent_speech_acc_type = CDOTAUserMsg_UnitEvent_speech_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_speech_acc_type {
    fn name(&self) -> &'static str {
        "speech"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_speech()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_UnitEvent) -> &'a ::protobuf::Message {
        m.get_speech() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_speech_mute_acc_type;
static CDOTAUserMsg_UnitEvent_speech_mute_acc: CDOTAUserMsg_UnitEvent_speech_mute_acc_type = CDOTAUserMsg_UnitEvent_speech_mute_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_speech_mute_acc_type {
    fn name(&self) -> &'static str {
        "speech_mute"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_speech_mute()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_UnitEvent) -> &'a ::protobuf::Message {
        m.get_speech_mute() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_add_gesture_acc_type;
static CDOTAUserMsg_UnitEvent_add_gesture_acc: CDOTAUserMsg_UnitEvent_add_gesture_acc_type = CDOTAUserMsg_UnitEvent_add_gesture_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_add_gesture_acc_type {
    fn name(&self) -> &'static str {
        "add_gesture"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_add_gesture()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_UnitEvent) -> &'a ::protobuf::Message {
        m.get_add_gesture() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_remove_gesture_acc_type;
static CDOTAUserMsg_UnitEvent_remove_gesture_acc: CDOTAUserMsg_UnitEvent_remove_gesture_acc_type = CDOTAUserMsg_UnitEvent_remove_gesture_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_remove_gesture_acc_type {
    fn name(&self) -> &'static str {
        "remove_gesture"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_remove_gesture()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_UnitEvent) -> &'a ::protobuf::Message {
        m.get_remove_gesture() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_blood_impact_acc_type;
static CDOTAUserMsg_UnitEvent_blood_impact_acc: CDOTAUserMsg_UnitEvent_blood_impact_acc_type = CDOTAUserMsg_UnitEvent_blood_impact_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_blood_impact_acc_type {
    fn name(&self) -> &'static str {
        "blood_impact"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_blood_impact()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_UnitEvent) -> &'a ::protobuf::Message {
        m.get_blood_impact() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_fade_gesture_acc_type;
static CDOTAUserMsg_UnitEvent_fade_gesture_acc: CDOTAUserMsg_UnitEvent_fade_gesture_acc_type = CDOTAUserMsg_UnitEvent_fade_gesture_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent> for CDOTAUserMsg_UnitEvent_fade_gesture_acc_type {
    fn name(&self) -> &'static str {
        "fade_gesture"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent) -> bool {
        m.has_fade_gesture()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_UnitEvent) -> &'a ::protobuf::Message {
        m.get_fade_gesture() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_UnitEvent_Speech {
    concept: Option<i32>,
    response: ::protobuf::SingularField<String>,
    recipient_type: Option<i32>,
    level: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_UnitEvent_Speech {
    pub fn new() -> CDOTAUserMsg_UnitEvent_Speech {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_Speech {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_Speech> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_UnitEvent_Speech };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_UnitEvent_Speech {
                    concept: None,
                    response: ::protobuf::SingularField::none(),
                    recipient_type: None,
                    level: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_concept(&mut self) {
        self.concept = None;
    }

    pub fn has_concept(&self) -> bool {
        self.concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept(&mut self, v: i32) {
        self.concept = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept(&'a mut self) -> &'a mut i32 {
        if self.concept.is_none() {
            self.concept = Some(0);
        };
        self.concept.as_mut().unwrap()
    }

    pub fn get_concept(&self) -> i32 {
        self.concept.unwrap_or_else(|| 0)
    }

    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: String) {
        self.response = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&'a mut self) -> &'a mut String {
        if self.response.is_none() {
            self.response.set_default();
        };
        self.response.as_mut().unwrap()
    }

    pub fn get_response(&'a self) -> &'a str {
        match self.response.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_recipient_type(&mut self) {
        self.recipient_type = None;
    }

    pub fn has_recipient_type(&self) -> bool {
        self.recipient_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_type(&mut self, v: i32) {
        self.recipient_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient_type(&'a mut self) -> &'a mut i32 {
        if self.recipient_type.is_none() {
            self.recipient_type = Some(0);
        };
        self.recipient_type.as_mut().unwrap()
    }

    pub fn get_recipient_type(&self) -> i32 {
        self.recipient_type.unwrap_or_else(|| 0)
    }

    pub fn clear_level(&mut self) {
        self.level = None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level(&'a mut self) -> &'a mut i32 {
        if self.level.is_none() {
            self.level = Some(0);
        };
        self.level.as_mut().unwrap()
    }

    pub fn get_level(&self) -> i32 {
        self.level.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_Speech {
    fn new() -> CDOTAUserMsg_UnitEvent_Speech {
        CDOTAUserMsg_UnitEvent_Speech::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.concept = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.response.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.recipient_type = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.level = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.concept.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.response.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.recipient_type.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.level.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.concept {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.response.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.recipient_type {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.level {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_UnitEvent_Speech>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_Speech_concept_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_Speech_response_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_Speech_recipient_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_Speech_level_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_Speech>(
                    "CDOTAUserMsg_UnitEvent_Speech",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_UnitEvent_Speech>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_Speech {
    fn clear(&mut self) {
        self.clear_concept();
        self.clear_response();
        self.clear_recipient_type();
        self.clear_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_UnitEvent_Speech {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_Speech_concept_acc_type;
static CDOTAUserMsg_UnitEvent_Speech_concept_acc: CDOTAUserMsg_UnitEvent_Speech_concept_acc_type = CDOTAUserMsg_UnitEvent_Speech_concept_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech> for CDOTAUserMsg_UnitEvent_Speech_concept_acc_type {
    fn name(&self) -> &'static str {
        "concept"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_Speech) -> bool {
        m.has_concept()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent_Speech) -> i32 {
        m.get_concept()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_Speech_response_acc_type;
static CDOTAUserMsg_UnitEvent_Speech_response_acc: CDOTAUserMsg_UnitEvent_Speech_response_acc_type = CDOTAUserMsg_UnitEvent_Speech_response_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech> for CDOTAUserMsg_UnitEvent_Speech_response_acc_type {
    fn name(&self) -> &'static str {
        "response"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_Speech) -> bool {
        m.has_response()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_UnitEvent_Speech) -> &'a str {
        m.get_response()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_Speech_recipient_type_acc_type;
static CDOTAUserMsg_UnitEvent_Speech_recipient_type_acc: CDOTAUserMsg_UnitEvent_Speech_recipient_type_acc_type = CDOTAUserMsg_UnitEvent_Speech_recipient_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech> for CDOTAUserMsg_UnitEvent_Speech_recipient_type_acc_type {
    fn name(&self) -> &'static str {
        "recipient_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_Speech) -> bool {
        m.has_recipient_type()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent_Speech) -> i32 {
        m.get_recipient_type()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_Speech_level_acc_type;
static CDOTAUserMsg_UnitEvent_Speech_level_acc: CDOTAUserMsg_UnitEvent_Speech_level_acc_type = CDOTAUserMsg_UnitEvent_Speech_level_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_Speech> for CDOTAUserMsg_UnitEvent_Speech_level_acc_type {
    fn name(&self) -> &'static str {
        "level"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_Speech) -> bool {
        m.has_level()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent_Speech) -> i32 {
        m.get_level()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_UnitEvent_SpeechMute {
    delay: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_UnitEvent_SpeechMute {
    pub fn new() -> CDOTAUserMsg_UnitEvent_SpeechMute {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_SpeechMute {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_SpeechMute> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_UnitEvent_SpeechMute };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_UnitEvent_SpeechMute {
                    delay: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_delay(&mut self) {
        self.delay = None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: f32) {
        self.delay = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delay(&'a mut self) -> &'a mut f32 {
        if self.delay.is_none() {
            self.delay = Some(0.);
        };
        self.delay.as_mut().unwrap()
    }

    pub fn get_delay(&self) -> f32 {
        self.delay.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn new() -> CDOTAUserMsg_UnitEvent_SpeechMute {
        CDOTAUserMsg_UnitEvent_SpeechMute::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.delay = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.delay.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.delay {
            Some(ref v) => {
                os.write_float(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_UnitEvent_SpeechMute>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_SpeechMute>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_SpeechMute_delay_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_SpeechMute>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_SpeechMute>(
                    "CDOTAUserMsg_UnitEvent_SpeechMute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_UnitEvent_SpeechMute>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn clear(&mut self) {
        self.clear_delay();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_SpeechMute_delay_acc_type;
static CDOTAUserMsg_UnitEvent_SpeechMute_delay_acc: CDOTAUserMsg_UnitEvent_SpeechMute_delay_acc_type = CDOTAUserMsg_UnitEvent_SpeechMute_delay_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_SpeechMute> for CDOTAUserMsg_UnitEvent_SpeechMute_delay_acc_type {
    fn name(&self) -> &'static str {
        "delay"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_SpeechMute) -> bool {
        m.has_delay()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_UnitEvent_SpeechMute) -> f32 {
        m.get_delay()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_UnitEvent_AddGesture {
    activity: Option<Activity>,
    slot: Option<i32>,
    fade_in: Option<f32>,
    fade_out: Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_UnitEvent_AddGesture {
    pub fn new() -> CDOTAUserMsg_UnitEvent_AddGesture {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_AddGesture {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_AddGesture> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_UnitEvent_AddGesture };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_UnitEvent_AddGesture {
                    activity: None,
                    slot: None,
                    fade_in: None,
                    fade_out: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_activity(&mut self) {
        self.activity = None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: Activity) {
        self.activity = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activity(&'a mut self) -> &'a mut Activity {
        if self.activity.is_none() {
            self.activity = Some(Activity::new(0));
        };
        self.activity.as_mut().unwrap()
    }

    pub fn get_activity(&self) -> Activity {
        self.activity.unwrap_or_else(|| Activity::new(0))
    }

    pub fn clear_slot(&mut self) {
        self.slot = None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot(&'a mut self) -> &'a mut i32 {
        if self.slot.is_none() {
            self.slot = Some(0);
        };
        self.slot.as_mut().unwrap()
    }

    pub fn get_slot(&self) -> i32 {
        self.slot.unwrap_or_else(|| 0)
    }

    pub fn clear_fade_in(&mut self) {
        self.fade_in = None;
    }

    pub fn has_fade_in(&self) -> bool {
        self.fade_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in(&mut self, v: f32) {
        self.fade_in = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fade_in(&'a mut self) -> &'a mut f32 {
        if self.fade_in.is_none() {
            self.fade_in = Some(0.);
        };
        self.fade_in.as_mut().unwrap()
    }

    pub fn get_fade_in(&self) -> f32 {
        self.fade_in.unwrap_or_else(|| 0.)
    }

    pub fn clear_fade_out(&mut self) {
        self.fade_out = None;
    }

    pub fn has_fade_out(&self) -> bool {
        self.fade_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out(&mut self, v: f32) {
        self.fade_out = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fade_out(&'a mut self) -> &'a mut f32 {
        if self.fade_out.is_none() {
            self.fade_out = Some(0.);
        };
        self.fade_out.as_mut().unwrap()
    }

    pub fn get_fade_out(&self) -> f32 {
        self.fade_out.unwrap_or_else(|| 0.)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_AddGesture {
    fn new() -> CDOTAUserMsg_UnitEvent_AddGesture {
        CDOTAUserMsg_UnitEvent_AddGesture::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = Activity::new(is.read_int32());
                    self.activity = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.slot = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.fade_in = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.fade_out = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.activity.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.slot.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.fade_in.is_some() {
            my_size += 5;
        };
        if self.fade_out.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.activity {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        match self.slot {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.fade_in {
            Some(ref v) => {
                os.write_float(3, *v);
            },
            None => {},
        };
        match self.fade_out {
            Some(ref v) => {
                os.write_float(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_UnitEvent_AddGesture>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_AddGesture_activity_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_AddGesture_slot_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_AddGesture_fade_in_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_AddGesture_fade_out_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_AddGesture>(
                    "CDOTAUserMsg_UnitEvent_AddGesture",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_UnitEvent_AddGesture>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_AddGesture {
    fn clear(&mut self) {
        self.clear_activity();
        self.clear_slot();
        self.clear_fade_in();
        self.clear_fade_out();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_UnitEvent_AddGesture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_AddGesture_activity_acc_type;
static CDOTAUserMsg_UnitEvent_AddGesture_activity_acc: CDOTAUserMsg_UnitEvent_AddGesture_activity_acc_type = CDOTAUserMsg_UnitEvent_AddGesture_activity_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture> for CDOTAUserMsg_UnitEvent_AddGesture_activity_acc_type {
    fn name(&self) -> &'static str {
        "activity"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> bool {
        m.has_activity()
    }

    fn get_enum<'a>(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_activity().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_AddGesture_slot_acc_type;
static CDOTAUserMsg_UnitEvent_AddGesture_slot_acc: CDOTAUserMsg_UnitEvent_AddGesture_slot_acc_type = CDOTAUserMsg_UnitEvent_AddGesture_slot_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture> for CDOTAUserMsg_UnitEvent_AddGesture_slot_acc_type {
    fn name(&self) -> &'static str {
        "slot"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> bool {
        m.has_slot()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> i32 {
        m.get_slot()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_AddGesture_fade_in_acc_type;
static CDOTAUserMsg_UnitEvent_AddGesture_fade_in_acc: CDOTAUserMsg_UnitEvent_AddGesture_fade_in_acc_type = CDOTAUserMsg_UnitEvent_AddGesture_fade_in_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture> for CDOTAUserMsg_UnitEvent_AddGesture_fade_in_acc_type {
    fn name(&self) -> &'static str {
        "fade_in"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> bool {
        m.has_fade_in()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> f32 {
        m.get_fade_in()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_AddGesture_fade_out_acc_type;
static CDOTAUserMsg_UnitEvent_AddGesture_fade_out_acc: CDOTAUserMsg_UnitEvent_AddGesture_fade_out_acc_type = CDOTAUserMsg_UnitEvent_AddGesture_fade_out_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_AddGesture> for CDOTAUserMsg_UnitEvent_AddGesture_fade_out_acc_type {
    fn name(&self) -> &'static str {
        "fade_out"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> bool {
        m.has_fade_out()
    }

    fn get_f32(&self, m: &CDOTAUserMsg_UnitEvent_AddGesture) -> f32 {
        m.get_fade_out()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_UnitEvent_RemoveGesture {
    activity: Option<Activity>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_UnitEvent_RemoveGesture {
    pub fn new() -> CDOTAUserMsg_UnitEvent_RemoveGesture {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_RemoveGesture {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_RemoveGesture> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_UnitEvent_RemoveGesture };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_UnitEvent_RemoveGesture {
                    activity: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_activity(&mut self) {
        self.activity = None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: Activity) {
        self.activity = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activity(&'a mut self) -> &'a mut Activity {
        if self.activity.is_none() {
            self.activity = Some(Activity::new(0));
        };
        self.activity.as_mut().unwrap()
    }

    pub fn get_activity(&self) -> Activity {
        self.activity.unwrap_or_else(|| Activity::new(0))
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn new() -> CDOTAUserMsg_UnitEvent_RemoveGesture {
        CDOTAUserMsg_UnitEvent_RemoveGesture::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = Activity::new(is.read_int32());
                    self.activity = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.activity.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.activity {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_UnitEvent_RemoveGesture>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_RemoveGesture>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_RemoveGesture_activity_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_RemoveGesture>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_RemoveGesture>(
                    "CDOTAUserMsg_UnitEvent_RemoveGesture",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_UnitEvent_RemoveGesture>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn clear(&mut self) {
        self.clear_activity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_RemoveGesture_activity_acc_type;
static CDOTAUserMsg_UnitEvent_RemoveGesture_activity_acc: CDOTAUserMsg_UnitEvent_RemoveGesture_activity_acc_type = CDOTAUserMsg_UnitEvent_RemoveGesture_activity_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_RemoveGesture> for CDOTAUserMsg_UnitEvent_RemoveGesture_activity_acc_type {
    fn name(&self) -> &'static str {
        "activity"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_RemoveGesture) -> bool {
        m.has_activity()
    }

    fn get_enum<'a>(&self, m: &CDOTAUserMsg_UnitEvent_RemoveGesture) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_activity().descriptor()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_UnitEvent_BloodImpact {
    scale: Option<i32>,
    x_normal: Option<i32>,
    y_normal: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_UnitEvent_BloodImpact {
    pub fn new() -> CDOTAUserMsg_UnitEvent_BloodImpact {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_BloodImpact {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_BloodImpact> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_UnitEvent_BloodImpact };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_UnitEvent_BloodImpact {
                    scale: None,
                    x_normal: None,
                    y_normal: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_scale(&mut self) {
        self.scale = None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: i32) {
        self.scale = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scale(&'a mut self) -> &'a mut i32 {
        if self.scale.is_none() {
            self.scale = Some(0);
        };
        self.scale.as_mut().unwrap()
    }

    pub fn get_scale(&self) -> i32 {
        self.scale.unwrap_or_else(|| 0)
    }

    pub fn clear_x_normal(&mut self) {
        self.x_normal = None;
    }

    pub fn has_x_normal(&self) -> bool {
        self.x_normal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normal(&mut self, v: i32) {
        self.x_normal = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x_normal(&'a mut self) -> &'a mut i32 {
        if self.x_normal.is_none() {
            self.x_normal = Some(0);
        };
        self.x_normal.as_mut().unwrap()
    }

    pub fn get_x_normal(&self) -> i32 {
        self.x_normal.unwrap_or_else(|| 0)
    }

    pub fn clear_y_normal(&mut self) {
        self.y_normal = None;
    }

    pub fn has_y_normal(&self) -> bool {
        self.y_normal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normal(&mut self, v: i32) {
        self.y_normal = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y_normal(&'a mut self) -> &'a mut i32 {
        if self.y_normal.is_none() {
            self.y_normal = Some(0);
        };
        self.y_normal.as_mut().unwrap()
    }

    pub fn get_y_normal(&self) -> i32 {
        self.y_normal.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn new() -> CDOTAUserMsg_UnitEvent_BloodImpact {
        CDOTAUserMsg_UnitEvent_BloodImpact::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.scale = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.x_normal = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.y_normal = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.scale.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.x_normal.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.y_normal.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.scale {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.x_normal {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.y_normal {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_UnitEvent_BloodImpact>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_BloodImpact>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_BloodImpact_scale_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_BloodImpact>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_BloodImpact_x_normal_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_BloodImpact>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_BloodImpact_y_normal_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_BloodImpact>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_BloodImpact>(
                    "CDOTAUserMsg_UnitEvent_BloodImpact",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_UnitEvent_BloodImpact>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn clear(&mut self) {
        self.clear_scale();
        self.clear_x_normal();
        self.clear_y_normal();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_BloodImpact_scale_acc_type;
static CDOTAUserMsg_UnitEvent_BloodImpact_scale_acc: CDOTAUserMsg_UnitEvent_BloodImpact_scale_acc_type = CDOTAUserMsg_UnitEvent_BloodImpact_scale_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_BloodImpact> for CDOTAUserMsg_UnitEvent_BloodImpact_scale_acc_type {
    fn name(&self) -> &'static str {
        "scale"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_BloodImpact) -> bool {
        m.has_scale()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent_BloodImpact) -> i32 {
        m.get_scale()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_BloodImpact_x_normal_acc_type;
static CDOTAUserMsg_UnitEvent_BloodImpact_x_normal_acc: CDOTAUserMsg_UnitEvent_BloodImpact_x_normal_acc_type = CDOTAUserMsg_UnitEvent_BloodImpact_x_normal_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_BloodImpact> for CDOTAUserMsg_UnitEvent_BloodImpact_x_normal_acc_type {
    fn name(&self) -> &'static str {
        "x_normal"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_BloodImpact) -> bool {
        m.has_x_normal()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent_BloodImpact) -> i32 {
        m.get_x_normal()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_BloodImpact_y_normal_acc_type;
static CDOTAUserMsg_UnitEvent_BloodImpact_y_normal_acc: CDOTAUserMsg_UnitEvent_BloodImpact_y_normal_acc_type = CDOTAUserMsg_UnitEvent_BloodImpact_y_normal_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_BloodImpact> for CDOTAUserMsg_UnitEvent_BloodImpact_y_normal_acc_type {
    fn name(&self) -> &'static str {
        "y_normal"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_BloodImpact) -> bool {
        m.has_y_normal()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_UnitEvent_BloodImpact) -> i32 {
        m.get_y_normal()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_UnitEvent_FadeGesture {
    activity: Option<Activity>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_UnitEvent_FadeGesture {
    pub fn new() -> CDOTAUserMsg_UnitEvent_FadeGesture {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_FadeGesture {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_FadeGesture> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_UnitEvent_FadeGesture };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_UnitEvent_FadeGesture {
                    activity: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_activity(&mut self) {
        self.activity = None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: Activity) {
        self.activity = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activity(&'a mut self) -> &'a mut Activity {
        if self.activity.is_none() {
            self.activity = Some(Activity::new(0));
        };
        self.activity.as_mut().unwrap()
    }

    pub fn get_activity(&self) -> Activity {
        self.activity.unwrap_or_else(|| Activity::new(0))
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn new() -> CDOTAUserMsg_UnitEvent_FadeGesture {
        CDOTAUserMsg_UnitEvent_FadeGesture::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = Activity::new(is.read_int32());
                    self.activity = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.activity.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.activity {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_UnitEvent_FadeGesture>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_FadeGesture>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_UnitEvent_FadeGesture_activity_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_FadeGesture>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_FadeGesture>(
                    "CDOTAUserMsg_UnitEvent_FadeGesture",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_UnitEvent_FadeGesture>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn clear(&mut self) {
        self.clear_activity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_UnitEvent_FadeGesture_activity_acc_type;
static CDOTAUserMsg_UnitEvent_FadeGesture_activity_acc: CDOTAUserMsg_UnitEvent_FadeGesture_activity_acc_type = CDOTAUserMsg_UnitEvent_FadeGesture_activity_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_UnitEvent_FadeGesture> for CDOTAUserMsg_UnitEvent_FadeGesture_activity_acc_type {
    fn name(&self) -> &'static str {
        "activity"
    }

    fn has_field(&self, m: &CDOTAUserMsg_UnitEvent_FadeGesture) -> bool {
        m.has_activity()
    }

    fn get_enum<'a>(&self, m: &CDOTAUserMsg_UnitEvent_FadeGesture) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_activity().descriptor()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ItemPurchased {
    item_index: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ItemPurchased {
    pub fn new() -> CDOTAUserMsg_ItemPurchased {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ItemPurchased {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ItemPurchased> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ItemPurchased };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ItemPurchased {
                    item_index: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_item_index(&mut self) {
        self.item_index = None;
    }

    pub fn has_item_index(&self) -> bool {
        self.item_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_index(&mut self, v: i32) {
        self.item_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_index(&'a mut self) -> &'a mut i32 {
        if self.item_index.is_none() {
            self.item_index = Some(0);
        };
        self.item_index.as_mut().unwrap()
    }

    pub fn get_item_index(&self) -> i32 {
        self.item_index.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemPurchased {
    fn new() -> CDOTAUserMsg_ItemPurchased {
        CDOTAUserMsg_ItemPurchased::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.item_index = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.item_index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.item_index {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ItemPurchased>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemPurchased>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ItemPurchased_item_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemPurchased>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ItemPurchased>(
                    "CDOTAUserMsg_ItemPurchased",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ItemPurchased>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ItemPurchased {
    fn clear(&mut self) {
        self.clear_item_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ItemPurchased {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ItemPurchased_item_index_acc_type;
static CDOTAUserMsg_ItemPurchased_item_index_acc: CDOTAUserMsg_ItemPurchased_item_index_acc_type = CDOTAUserMsg_ItemPurchased_item_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemPurchased> for CDOTAUserMsg_ItemPurchased_item_index_acc_type {
    fn name(&self) -> &'static str {
        "item_index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ItemPurchased) -> bool {
        m.has_item_index()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ItemPurchased) -> i32 {
        m.get_item_index()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ItemFound {
    player: Option<i32>,
    quality: Option<i32>,
    rarity: Option<i32>,
    method: Option<i32>,
    itemdef: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ItemFound {
    pub fn new() -> CDOTAUserMsg_ItemFound {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ItemFound {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ItemFound> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ItemFound };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ItemFound {
                    player: None,
                    quality: None,
                    rarity: None,
                    method: None,
                    itemdef: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_player(&mut self) {
        self.player = None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player(&'a mut self) -> &'a mut i32 {
        if self.player.is_none() {
            self.player = Some(0);
        };
        self.player.as_mut().unwrap()
    }

    pub fn get_player(&self) -> i32 {
        self.player.unwrap_or_else(|| 0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality(&'a mut self) -> &'a mut i32 {
        if self.quality.is_none() {
            self.quality = Some(0);
        };
        self.quality.as_mut().unwrap()
    }

    pub fn get_quality(&self) -> i32 {
        self.quality.unwrap_or_else(|| 0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: i32) {
        self.rarity = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rarity(&'a mut self) -> &'a mut i32 {
        if self.rarity.is_none() {
            self.rarity = Some(0);
        };
        self.rarity.as_mut().unwrap()
    }

    pub fn get_rarity(&self) -> i32 {
        self.rarity.unwrap_or_else(|| 0)
    }

    pub fn clear_method(&mut self) {
        self.method = None;
    }

    pub fn has_method(&self) -> bool {
        self.method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: i32) {
        self.method = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method(&'a mut self) -> &'a mut i32 {
        if self.method.is_none() {
            self.method = Some(0);
        };
        self.method.as_mut().unwrap()
    }

    pub fn get_method(&self) -> i32 {
        self.method.unwrap_or_else(|| 0)
    }

    pub fn clear_itemdef(&mut self) {
        self.itemdef = None;
    }

    pub fn has_itemdef(&self) -> bool {
        self.itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemdef(&mut self, v: i32) {
        self.itemdef = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_itemdef(&'a mut self) -> &'a mut i32 {
        if self.itemdef.is_none() {
            self.itemdef = Some(0);
        };
        self.itemdef.as_mut().unwrap()
    }

    pub fn get_itemdef(&self) -> i32 {
        self.itemdef.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemFound {
    fn new() -> CDOTAUserMsg_ItemFound {
        CDOTAUserMsg_ItemFound::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.player = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.quality = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.rarity = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.method = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.itemdef = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.player.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.quality.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.rarity.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.method.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.itemdef.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.player {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.quality {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.rarity {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.method {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.itemdef {
            Some(ref v) => {
                os.write_int32(5, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ItemFound>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ItemFound_player_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ItemFound_quality_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ItemFound_rarity_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ItemFound_method_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ItemFound_itemdef_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ItemFound>(
                    "CDOTAUserMsg_ItemFound",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ItemFound>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ItemFound {
    fn clear(&mut self) {
        self.clear_player();
        self.clear_quality();
        self.clear_rarity();
        self.clear_method();
        self.clear_itemdef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ItemFound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ItemFound_player_acc_type;
static CDOTAUserMsg_ItemFound_player_acc: CDOTAUserMsg_ItemFound_player_acc_type = CDOTAUserMsg_ItemFound_player_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound> for CDOTAUserMsg_ItemFound_player_acc_type {
    fn name(&self) -> &'static str {
        "player"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ItemFound) -> bool {
        m.has_player()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ItemFound) -> i32 {
        m.get_player()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ItemFound_quality_acc_type;
static CDOTAUserMsg_ItemFound_quality_acc: CDOTAUserMsg_ItemFound_quality_acc_type = CDOTAUserMsg_ItemFound_quality_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound> for CDOTAUserMsg_ItemFound_quality_acc_type {
    fn name(&self) -> &'static str {
        "quality"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ItemFound) -> bool {
        m.has_quality()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ItemFound) -> i32 {
        m.get_quality()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ItemFound_rarity_acc_type;
static CDOTAUserMsg_ItemFound_rarity_acc: CDOTAUserMsg_ItemFound_rarity_acc_type = CDOTAUserMsg_ItemFound_rarity_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound> for CDOTAUserMsg_ItemFound_rarity_acc_type {
    fn name(&self) -> &'static str {
        "rarity"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ItemFound) -> bool {
        m.has_rarity()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ItemFound) -> i32 {
        m.get_rarity()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ItemFound_method_acc_type;
static CDOTAUserMsg_ItemFound_method_acc: CDOTAUserMsg_ItemFound_method_acc_type = CDOTAUserMsg_ItemFound_method_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound> for CDOTAUserMsg_ItemFound_method_acc_type {
    fn name(&self) -> &'static str {
        "method"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ItemFound) -> bool {
        m.has_method()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ItemFound) -> i32 {
        m.get_method()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ItemFound_itemdef_acc_type;
static CDOTAUserMsg_ItemFound_itemdef_acc: CDOTAUserMsg_ItemFound_itemdef_acc_type = CDOTAUserMsg_ItemFound_itemdef_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ItemFound> for CDOTAUserMsg_ItemFound_itemdef_acc_type {
    fn name(&self) -> &'static str {
        "itemdef"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ItemFound) -> bool {
        m.has_itemdef()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ItemFound) -> i32 {
        m.get_itemdef()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager {
    field_type: Option<DOTA_PARTICLE_MESSAGE>,
    index: Option<u32>,
    release_particle_index: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>,
    create_particle: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_CreateParticle>,
    destroy_particle: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticle>,
    destroy_particle_involving: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>,
    update_particle: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticle>,
    update_particle_fwd: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>,
    update_particle_orient: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>,
    update_particle_fallback: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>,
    update_particle_offset: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>,
    update_particle_ent: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>,
    update_particle_latency: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleLatency>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager {
    pub fn new() -> CDOTAUserMsg_ParticleManager {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager {
                    field_type: None,
                    index: None,
                    release_particle_index: ::protobuf::SingularPtrField::none(),
                    create_particle: ::protobuf::SingularPtrField::none(),
                    destroy_particle: ::protobuf::SingularPtrField::none(),
                    destroy_particle_involving: ::protobuf::SingularPtrField::none(),
                    update_particle: ::protobuf::SingularPtrField::none(),
                    update_particle_fwd: ::protobuf::SingularPtrField::none(),
                    update_particle_orient: ::protobuf::SingularPtrField::none(),
                    update_particle_fallback: ::protobuf::SingularPtrField::none(),
                    update_particle_offset: ::protobuf::SingularPtrField::none(),
                    update_particle_ent: ::protobuf::SingularPtrField::none(),
                    update_particle_latency: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DOTA_PARTICLE_MESSAGE) {
        self.field_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&'a mut self) -> &'a mut DOTA_PARTICLE_MESSAGE {
        if self.field_type.is_none() {
            self.field_type = Some(DOTA_PARTICLE_MESSAGE::new(0));
        };
        self.field_type.as_mut().unwrap()
    }

    pub fn get_field_type(&self) -> DOTA_PARTICLE_MESSAGE {
        self.field_type.unwrap_or_else(|| DOTA_PARTICLE_MESSAGE::new(0))
    }

    pub fn clear_index(&mut self) {
        self.index = None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&'a mut self) -> &'a mut u32 {
        if self.index.is_none() {
            self.index = Some(0);
        };
        self.index.as_mut().unwrap()
    }

    pub fn get_index(&self) -> u32 {
        self.index.unwrap_or_else(|| 0)
    }

    pub fn clear_release_particle_index(&mut self) {
        self.release_particle_index.clear();
    }

    pub fn has_release_particle_index(&self) -> bool {
        self.release_particle_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release_particle_index(&mut self, v: CDOTAUserMsg_ParticleManager_ReleaseParticleIndex) {
        self.release_particle_index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release_particle_index(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        if self.release_particle_index.is_none() {
            self.release_particle_index.set_default();
        };
        self.release_particle_index.as_mut().unwrap()
    }

    pub fn get_release_particle_index(&'a self) -> &'a CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        self.release_particle_index.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_ReleaseParticleIndex::default_instance())
    }

    pub fn clear_create_particle(&mut self) {
        self.create_particle.clear();
    }

    pub fn has_create_particle(&self) -> bool {
        self.create_particle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_particle(&mut self, v: CDOTAUserMsg_ParticleManager_CreateParticle) {
        self.create_particle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_particle(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_CreateParticle {
        if self.create_particle.is_none() {
            self.create_particle.set_default();
        };
        self.create_particle.as_mut().unwrap()
    }

    pub fn get_create_particle(&'a self) -> &'a CDOTAUserMsg_ParticleManager_CreateParticle {
        self.create_particle.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_CreateParticle::default_instance())
    }

    pub fn clear_destroy_particle(&mut self) {
        self.destroy_particle.clear();
    }

    pub fn has_destroy_particle(&self) -> bool {
        self.destroy_particle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_particle(&mut self, v: CDOTAUserMsg_ParticleManager_DestroyParticle) {
        self.destroy_particle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_particle(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_DestroyParticle {
        if self.destroy_particle.is_none() {
            self.destroy_particle.set_default();
        };
        self.destroy_particle.as_mut().unwrap()
    }

    pub fn get_destroy_particle(&'a self) -> &'a CDOTAUserMsg_ParticleManager_DestroyParticle {
        self.destroy_particle.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_DestroyParticle::default_instance())
    }

    pub fn clear_destroy_particle_involving(&mut self) {
        self.destroy_particle_involving.clear();
    }

    pub fn has_destroy_particle_involving(&self) -> bool {
        self.destroy_particle_involving.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_particle_involving(&mut self, v: CDOTAUserMsg_ParticleManager_DestroyParticleInvolving) {
        self.destroy_particle_involving = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_particle_involving(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        if self.destroy_particle_involving.is_none() {
            self.destroy_particle_involving.set_default();
        };
        self.destroy_particle_involving.as_mut().unwrap()
    }

    pub fn get_destroy_particle_involving(&'a self) -> &'a CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        self.destroy_particle_involving.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::default_instance())
    }

    pub fn clear_update_particle(&mut self) {
        self.update_particle.clear();
    }

    pub fn has_update_particle(&self) -> bool {
        self.update_particle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticle) {
        self.update_particle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_UpdateParticle {
        if self.update_particle.is_none() {
            self.update_particle.set_default();
        };
        self.update_particle.as_mut().unwrap()
    }

    pub fn get_update_particle(&'a self) -> &'a CDOTAUserMsg_ParticleManager_UpdateParticle {
        self.update_particle.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticle::default_instance())
    }

    pub fn clear_update_particle_fwd(&mut self) {
        self.update_particle_fwd.clear();
    }

    pub fn has_update_particle_fwd(&self) -> bool {
        self.update_particle_fwd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_fwd(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleFwd) {
        self.update_particle_fwd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_fwd(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        if self.update_particle_fwd.is_none() {
            self.update_particle_fwd.set_default();
        };
        self.update_particle_fwd.as_mut().unwrap()
    }

    pub fn get_update_particle_fwd(&'a self) -> &'a CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        self.update_particle_fwd.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleFwd::default_instance())
    }

    pub fn clear_update_particle_orient(&mut self) {
        self.update_particle_orient.clear();
    }

    pub fn has_update_particle_orient(&self) -> bool {
        self.update_particle_orient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_orient(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleOrient) {
        self.update_particle_orient = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_orient(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        if self.update_particle_orient.is_none() {
            self.update_particle_orient.set_default();
        };
        self.update_particle_orient.as_mut().unwrap()
    }

    pub fn get_update_particle_orient(&'a self) -> &'a CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        self.update_particle_orient.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleOrient::default_instance())
    }

    pub fn clear_update_particle_fallback(&mut self) {
        self.update_particle_fallback.clear();
    }

    pub fn has_update_particle_fallback(&self) -> bool {
        self.update_particle_fallback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_fallback(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleFallback) {
        self.update_particle_fallback = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_fallback(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        if self.update_particle_fallback.is_none() {
            self.update_particle_fallback.set_default();
        };
        self.update_particle_fallback.as_mut().unwrap()
    }

    pub fn get_update_particle_fallback(&'a self) -> &'a CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        self.update_particle_fallback.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleFallback::default_instance())
    }

    pub fn clear_update_particle_offset(&mut self) {
        self.update_particle_offset.clear();
    }

    pub fn has_update_particle_offset(&self) -> bool {
        self.update_particle_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_offset(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleOffset) {
        self.update_particle_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_offset(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        if self.update_particle_offset.is_none() {
            self.update_particle_offset.set_default();
        };
        self.update_particle_offset.as_mut().unwrap()
    }

    pub fn get_update_particle_offset(&'a self) -> &'a CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        self.update_particle_offset.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleOffset::default_instance())
    }

    pub fn clear_update_particle_ent(&mut self) {
        self.update_particle_ent.clear();
    }

    pub fn has_update_particle_ent(&self) -> bool {
        self.update_particle_ent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_ent(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleEnt) {
        self.update_particle_ent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_ent(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        if self.update_particle_ent.is_none() {
            self.update_particle_ent.set_default();
        };
        self.update_particle_ent.as_mut().unwrap()
    }

    pub fn get_update_particle_ent(&'a self) -> &'a CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        self.update_particle_ent.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleEnt::default_instance())
    }

    pub fn clear_update_particle_latency(&mut self) {
        self.update_particle_latency.clear();
    }

    pub fn has_update_particle_latency(&self) -> bool {
        self.update_particle_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_latency(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleLatency) {
        self.update_particle_latency = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_latency(&'a mut self) -> &'a mut CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
        if self.update_particle_latency.is_none() {
            self.update_particle_latency.set_default();
        };
        self.update_particle_latency.as_mut().unwrap()
    }

    pub fn get_update_particle_latency(&'a self) -> &'a CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
        self.update_particle_latency.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleLatency::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager {
    fn new() -> CDOTAUserMsg_ParticleManager {
        CDOTAUserMsg_ParticleManager::new()
    }

    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        if self.index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = DOTA_PARTICLE_MESSAGE::new(is.read_int32());
                    self.field_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.index = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.release_particle_index.set_default();
                    is.merge_message(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.create_particle.set_default();
                    is.merge_message(tmp)
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.destroy_particle.set_default();
                    is.merge_message(tmp)
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.destroy_particle_involving.set_default();
                    is.merge_message(tmp)
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.update_particle.set_default();
                    is.merge_message(tmp)
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.update_particle_fwd.set_default();
                    is.merge_message(tmp)
                },
                9 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.update_particle_orient.set_default();
                    is.merge_message(tmp)
                },
                10 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.update_particle_fallback.set_default();
                    is.merge_message(tmp)
                },
                11 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.update_particle_offset.set_default();
                    is.merge_message(tmp)
                },
                12 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.update_particle_ent.set_default();
                    is.merge_message(tmp)
                },
                13 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.update_particle_latency.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.index.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.release_particle_index.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.create_particle.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.destroy_particle.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.destroy_particle_involving.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update_particle.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update_particle_fwd.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update_particle_orient.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update_particle_fallback.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update_particle_offset.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update_particle_ent.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update_particle_latency.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.field_type {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        match self.index {
            Some(ref v) => {
                os.write_uint32(2, *v);
            },
            None => {},
        };
        match self.release_particle_index.as_ref() {
            Some(ref v) => {
                os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.create_particle.as_ref() {
            Some(ref v) => {
                os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.destroy_particle.as_ref() {
            Some(ref v) => {
                os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.destroy_particle_involving.as_ref() {
            Some(ref v) => {
                os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.update_particle.as_ref() {
            Some(ref v) => {
                os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.update_particle_fwd.as_ref() {
            Some(ref v) => {
                os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.update_particle_orient.as_ref() {
            Some(ref v) => {
                os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.update_particle_fallback.as_ref() {
            Some(ref v) => {
                os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.update_particle_offset.as_ref() {
            Some(ref v) => {
                os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.update_particle_ent.as_ref() {
            Some(ref v) => {
                os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.update_particle_latency.as_ref() {
            Some(ref v) => {
                os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_field_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_release_particle_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_create_particle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_destroy_particle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_destroy_particle_involving_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_update_particle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_update_particle_fwd_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_update_particle_orient_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_update_particle_fallback_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_update_particle_offset_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_update_particle_ent_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_update_particle_latency_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager>(
                    "CDOTAUserMsg_ParticleManager",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_index();
        self.clear_release_particle_index();
        self.clear_create_particle();
        self.clear_destroy_particle();
        self.clear_destroy_particle_involving();
        self.clear_update_particle();
        self.clear_update_particle_fwd();
        self.clear_update_particle_orient();
        self.clear_update_particle_fallback();
        self.clear_update_particle_offset();
        self.clear_update_particle_ent();
        self.clear_update_particle_latency();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_field_type_acc_type;
static CDOTAUserMsg_ParticleManager_field_type_acc: CDOTAUserMsg_ParticleManager_field_type_acc_type = CDOTAUserMsg_ParticleManager_field_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_field_type_acc_type {
    fn name(&self) -> &'static str {
        "field_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_field_type()
    }

    fn get_enum<'a>(&self, m: &CDOTAUserMsg_ParticleManager) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_field_type().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_index_acc_type;
static CDOTAUserMsg_ParticleManager_index_acc: CDOTAUserMsg_ParticleManager_index_acc_type = CDOTAUserMsg_ParticleManager_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_index_acc_type {
    fn name(&self) -> &'static str {
        "index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_index()
    }

    fn get_u32(&self, m: &CDOTAUserMsg_ParticleManager) -> u32 {
        m.get_index()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_release_particle_index_acc_type;
static CDOTAUserMsg_ParticleManager_release_particle_index_acc: CDOTAUserMsg_ParticleManager_release_particle_index_acc_type = CDOTAUserMsg_ParticleManager_release_particle_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_release_particle_index_acc_type {
    fn name(&self) -> &'static str {
        "release_particle_index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_release_particle_index()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_release_particle_index() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_create_particle_acc_type;
static CDOTAUserMsg_ParticleManager_create_particle_acc: CDOTAUserMsg_ParticleManager_create_particle_acc_type = CDOTAUserMsg_ParticleManager_create_particle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_create_particle_acc_type {
    fn name(&self) -> &'static str {
        "create_particle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_create_particle()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_create_particle() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_destroy_particle_acc_type;
static CDOTAUserMsg_ParticleManager_destroy_particle_acc: CDOTAUserMsg_ParticleManager_destroy_particle_acc_type = CDOTAUserMsg_ParticleManager_destroy_particle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_destroy_particle_acc_type {
    fn name(&self) -> &'static str {
        "destroy_particle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_destroy_particle()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_destroy_particle() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_destroy_particle_involving_acc_type;
static CDOTAUserMsg_ParticleManager_destroy_particle_involving_acc: CDOTAUserMsg_ParticleManager_destroy_particle_involving_acc_type = CDOTAUserMsg_ParticleManager_destroy_particle_involving_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_destroy_particle_involving_acc_type {
    fn name(&self) -> &'static str {
        "destroy_particle_involving"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_destroy_particle_involving()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_destroy_particle_involving() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_update_particle_acc_type;
static CDOTAUserMsg_ParticleManager_update_particle_acc: CDOTAUserMsg_ParticleManager_update_particle_acc_type = CDOTAUserMsg_ParticleManager_update_particle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_update_particle_acc_type {
    fn name(&self) -> &'static str {
        "update_particle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_update_particle()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_update_particle() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_update_particle_fwd_acc_type;
static CDOTAUserMsg_ParticleManager_update_particle_fwd_acc: CDOTAUserMsg_ParticleManager_update_particle_fwd_acc_type = CDOTAUserMsg_ParticleManager_update_particle_fwd_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_update_particle_fwd_acc_type {
    fn name(&self) -> &'static str {
        "update_particle_fwd"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_update_particle_fwd()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_update_particle_fwd() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_update_particle_orient_acc_type;
static CDOTAUserMsg_ParticleManager_update_particle_orient_acc: CDOTAUserMsg_ParticleManager_update_particle_orient_acc_type = CDOTAUserMsg_ParticleManager_update_particle_orient_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_update_particle_orient_acc_type {
    fn name(&self) -> &'static str {
        "update_particle_orient"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_update_particle_orient()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_update_particle_orient() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_update_particle_fallback_acc_type;
static CDOTAUserMsg_ParticleManager_update_particle_fallback_acc: CDOTAUserMsg_ParticleManager_update_particle_fallback_acc_type = CDOTAUserMsg_ParticleManager_update_particle_fallback_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_update_particle_fallback_acc_type {
    fn name(&self) -> &'static str {
        "update_particle_fallback"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_update_particle_fallback()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_update_particle_fallback() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_update_particle_offset_acc_type;
static CDOTAUserMsg_ParticleManager_update_particle_offset_acc: CDOTAUserMsg_ParticleManager_update_particle_offset_acc_type = CDOTAUserMsg_ParticleManager_update_particle_offset_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_update_particle_offset_acc_type {
    fn name(&self) -> &'static str {
        "update_particle_offset"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_update_particle_offset()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_update_particle_offset() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_update_particle_ent_acc_type;
static CDOTAUserMsg_ParticleManager_update_particle_ent_acc: CDOTAUserMsg_ParticleManager_update_particle_ent_acc_type = CDOTAUserMsg_ParticleManager_update_particle_ent_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_update_particle_ent_acc_type {
    fn name(&self) -> &'static str {
        "update_particle_ent"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_update_particle_ent()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_update_particle_ent() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_update_particle_latency_acc_type;
static CDOTAUserMsg_ParticleManager_update_particle_latency_acc: CDOTAUserMsg_ParticleManager_update_particle_latency_acc_type = CDOTAUserMsg_ParticleManager_update_particle_latency_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager> for CDOTAUserMsg_ParticleManager_update_particle_latency_acc_type {
    fn name(&self) -> &'static str {
        "update_particle_latency"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager) -> bool {
        m.has_update_particle_latency()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager) -> &'a ::protobuf::Message {
        m.get_update_particle_latency() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    pub fn new() -> CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_ReleaseParticleIndex };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn new() -> CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        CDOTAUserMsg_ParticleManager_ReleaseParticleIndex::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>(
                    "CDOTAUserMsg_ParticleManager_ReleaseParticleIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_CreateParticle {
    particle_name_index: Option<i32>,
    attach_type: Option<i32>,
    entity_handle: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_CreateParticle {
    pub fn new() -> CDOTAUserMsg_ParticleManager_CreateParticle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_CreateParticle {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_CreateParticle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_CreateParticle };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_CreateParticle {
                    particle_name_index: None,
                    attach_type: None,
                    entity_handle: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_particle_name_index(&mut self) {
        self.particle_name_index = None;
    }

    pub fn has_particle_name_index(&self) -> bool {
        self.particle_name_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_name_index(&mut self, v: i32) {
        self.particle_name_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_particle_name_index(&'a mut self) -> &'a mut i32 {
        if self.particle_name_index.is_none() {
            self.particle_name_index = Some(0);
        };
        self.particle_name_index.as_mut().unwrap()
    }

    pub fn get_particle_name_index(&self) -> i32 {
        self.particle_name_index.unwrap_or_else(|| 0)
    }

    pub fn clear_attach_type(&mut self) {
        self.attach_type = None;
    }

    pub fn has_attach_type(&self) -> bool {
        self.attach_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_type(&mut self, v: i32) {
        self.attach_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_type(&'a mut self) -> &'a mut i32 {
        if self.attach_type.is_none() {
            self.attach_type = Some(0);
        };
        self.attach_type.as_mut().unwrap()
    }

    pub fn get_attach_type(&self) -> i32 {
        self.attach_type.unwrap_or_else(|| 0)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_handle(&'a mut self) -> &'a mut i32 {
        if self.entity_handle.is_none() {
            self.entity_handle = Some(0);
        };
        self.entity_handle.as_mut().unwrap()
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn new() -> CDOTAUserMsg_ParticleManager_CreateParticle {
        CDOTAUserMsg_ParticleManager_CreateParticle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.particle_name_index = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.attach_type = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_handle = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.particle_name_index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.attach_type.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entity_handle.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.particle_name_index {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.attach_type {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.entity_handle {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_CreateParticle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_CreateParticle>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_CreateParticle_particle_name_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_CreateParticle>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_CreateParticle_attach_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_CreateParticle>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_CreateParticle_entity_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_CreateParticle>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_CreateParticle>(
                    "CDOTAUserMsg_ParticleManager_CreateParticle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_CreateParticle>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn clear(&mut self) {
        self.clear_particle_name_index();
        self.clear_attach_type();
        self.clear_entity_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_CreateParticle_particle_name_index_acc_type;
static CDOTAUserMsg_ParticleManager_CreateParticle_particle_name_index_acc: CDOTAUserMsg_ParticleManager_CreateParticle_particle_name_index_acc_type = CDOTAUserMsg_ParticleManager_CreateParticle_particle_name_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_CreateParticle> for CDOTAUserMsg_ParticleManager_CreateParticle_particle_name_index_acc_type {
    fn name(&self) -> &'static str {
        "particle_name_index"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_CreateParticle) -> bool {
        m.has_particle_name_index()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_CreateParticle) -> i32 {
        m.get_particle_name_index()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_CreateParticle_attach_type_acc_type;
static CDOTAUserMsg_ParticleManager_CreateParticle_attach_type_acc: CDOTAUserMsg_ParticleManager_CreateParticle_attach_type_acc_type = CDOTAUserMsg_ParticleManager_CreateParticle_attach_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_CreateParticle> for CDOTAUserMsg_ParticleManager_CreateParticle_attach_type_acc_type {
    fn name(&self) -> &'static str {
        "attach_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_CreateParticle) -> bool {
        m.has_attach_type()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_CreateParticle) -> i32 {
        m.get_attach_type()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_CreateParticle_entity_handle_acc_type;
static CDOTAUserMsg_ParticleManager_CreateParticle_entity_handle_acc: CDOTAUserMsg_ParticleManager_CreateParticle_entity_handle_acc_type = CDOTAUserMsg_ParticleManager_CreateParticle_entity_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_CreateParticle> for CDOTAUserMsg_ParticleManager_CreateParticle_entity_handle_acc_type {
    fn name(&self) -> &'static str {
        "entity_handle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_CreateParticle) -> bool {
        m.has_entity_handle()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_CreateParticle) -> i32 {
        m.get_entity_handle()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_DestroyParticle {
    destroy_immediately: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_DestroyParticle {
    pub fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_DestroyParticle {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_DestroyParticle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_DestroyParticle };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_DestroyParticle {
                    destroy_immediately: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_destroy_immediately(&mut self) {
        self.destroy_immediately = None;
    }

    pub fn has_destroy_immediately(&self) -> bool {
        self.destroy_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_immediately(&mut self, v: bool) {
        self.destroy_immediately = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_immediately(&'a mut self) -> &'a mut bool {
        if self.destroy_immediately.is_none() {
            self.destroy_immediately = Some(false);
        };
        self.destroy_immediately.as_mut().unwrap()
    }

    pub fn get_destroy_immediately(&self) -> bool {
        self.destroy_immediately.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticle {
        CDOTAUserMsg_ParticleManager_DestroyParticle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.destroy_immediately = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.destroy_immediately.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.destroy_immediately {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_DestroyParticle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticle>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_DestroyParticle_destroy_immediately_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticle>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_DestroyParticle>(
                    "CDOTAUserMsg_ParticleManager_DestroyParticle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_DestroyParticle>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn clear(&mut self) {
        self.clear_destroy_immediately();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_DestroyParticle_destroy_immediately_acc_type;
static CDOTAUserMsg_ParticleManager_DestroyParticle_destroy_immediately_acc: CDOTAUserMsg_ParticleManager_DestroyParticle_destroy_immediately_acc_type = CDOTAUserMsg_ParticleManager_DestroyParticle_destroy_immediately_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticle> for CDOTAUserMsg_ParticleManager_DestroyParticle_destroy_immediately_acc_type {
    fn name(&self) -> &'static str {
        "destroy_immediately"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_DestroyParticle) -> bool {
        m.has_destroy_immediately()
    }

    fn get_bool(&self, m: &CDOTAUserMsg_ParticleManager_DestroyParticle) -> bool {
        m.get_destroy_immediately()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    destroy_immediately: Option<bool>,
    entity_handle: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    pub fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_DestroyParticleInvolving };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
                    destroy_immediately: None,
                    entity_handle: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_destroy_immediately(&mut self) {
        self.destroy_immediately = None;
    }

    pub fn has_destroy_immediately(&self) -> bool {
        self.destroy_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_immediately(&mut self, v: bool) {
        self.destroy_immediately = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_immediately(&'a mut self) -> &'a mut bool {
        if self.destroy_immediately.is_none() {
            self.destroy_immediately = Some(false);
        };
        self.destroy_immediately.as_mut().unwrap()
    }

    pub fn get_destroy_immediately(&self) -> bool {
        self.destroy_immediately.unwrap_or_else(|| false)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_handle(&'a mut self) -> &'a mut i32 {
        if self.entity_handle.is_none() {
            self.entity_handle = Some(0);
        };
        self.entity_handle.as_mut().unwrap()
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.destroy_immediately = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_handle = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.destroy_immediately.is_some() {
            my_size += 2;
        };
        for value in self.entity_handle.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.destroy_immediately {
            Some(ref v) => {
                os.write_bool(1, *v);
            },
            None => {},
        };
        match self.entity_handle {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_destroy_immediately_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_entity_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>(
                    "CDOTAUserMsg_ParticleManager_DestroyParticleInvolving",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn clear(&mut self) {
        self.clear_destroy_immediately();
        self.clear_entity_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_destroy_immediately_acc_type;
static CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_destroy_immediately_acc: CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_destroy_immediately_acc_type = CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_destroy_immediately_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving> for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_destroy_immediately_acc_type {
    fn name(&self) -> &'static str {
        "destroy_immediately"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_DestroyParticleInvolving) -> bool {
        m.has_destroy_immediately()
    }

    fn get_bool(&self, m: &CDOTAUserMsg_ParticleManager_DestroyParticleInvolving) -> bool {
        m.get_destroy_immediately()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_entity_handle_acc_type;
static CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_entity_handle_acc: CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_entity_handle_acc_type = CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_entity_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving> for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving_entity_handle_acc_type {
    fn name(&self) -> &'static str {
        "entity_handle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_DestroyParticleInvolving) -> bool {
        m.has_entity_handle()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_DestroyParticleInvolving) -> i32 {
        m.get_entity_handle()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticle {
    control_point: Option<i32>,
    position: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_UpdateParticle {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticle {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticle> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticle };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_UpdateParticle {
                    control_point: None,
                    position: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control_point(&'a mut self) -> &'a mut i32 {
        if self.control_point.is_none() {
            self.control_point = Some(0);
        };
        self.control_point.as_mut().unwrap()
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or_else(|| 0)
    }

    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: CMsgVector) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&'a mut self) -> &'a mut CMsgVector {
        if self.position.is_none() {
            self.position.set_default();
        };
        self.position.as_mut().unwrap()
    }

    pub fn get_position(&'a self) -> &'a CMsgVector {
        self.position.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticle {
        CDOTAUserMsg_ParticleManager_UpdateParticle::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.control_point = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.position.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.control_point.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.position.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.control_point {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.position.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_UpdateParticle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticle>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticle_control_point_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticle>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticle_position_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticle>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticle>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_UpdateParticle>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_position();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticle_control_point_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticle_control_point_acc: CDOTAUserMsg_ParticleManager_UpdateParticle_control_point_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticle_control_point_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticle> for CDOTAUserMsg_ParticleManager_UpdateParticle_control_point_acc_type {
    fn name(&self) -> &'static str {
        "control_point"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticle) -> bool {
        m.has_control_point()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticle) -> i32 {
        m.get_control_point()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticle_position_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticle_position_acc: CDOTAUserMsg_ParticleManager_UpdateParticle_position_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticle_position_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticle> for CDOTAUserMsg_ParticleManager_UpdateParticle_position_acc_type {
    fn name(&self) -> &'static str {
        "position"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticle) -> bool {
        m.has_position()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticle) -> &'a ::protobuf::Message {
        m.get_position() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    control_point: Option<i32>,
    forward: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleFwd> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleFwd };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
                    control_point: None,
                    forward: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control_point(&'a mut self) -> &'a mut i32 {
        if self.control_point.is_none() {
            self.control_point = Some(0);
        };
        self.control_point.as_mut().unwrap()
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or_else(|| 0)
    }

    pub fn clear_forward(&mut self) {
        self.forward.clear();
    }

    pub fn has_forward(&self) -> bool {
        self.forward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward(&mut self, v: CMsgVector) {
        self.forward = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward(&'a mut self) -> &'a mut CMsgVector {
        if self.forward.is_none() {
            self.forward.set_default();
        };
        self.forward.as_mut().unwrap()
    }

    pub fn get_forward(&'a self) -> &'a CMsgVector {
        self.forward.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        CDOTAUserMsg_ParticleManager_UpdateParticleFwd::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.control_point = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.forward.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.control_point.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.forward.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.control_point {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.forward.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleFwd_control_point_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleFwd_forward_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleFwd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_forward();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleFwd_control_point_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleFwd_control_point_acc: CDOTAUserMsg_ParticleManager_UpdateParticleFwd_control_point_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleFwd_control_point_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFwd> for CDOTAUserMsg_ParticleManager_UpdateParticleFwd_control_point_acc_type {
    fn name(&self) -> &'static str {
        "control_point"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleFwd) -> bool {
        m.has_control_point()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleFwd) -> i32 {
        m.get_control_point()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleFwd_forward_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleFwd_forward_acc: CDOTAUserMsg_ParticleManager_UpdateParticleFwd_forward_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleFwd_forward_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFwd> for CDOTAUserMsg_ParticleManager_UpdateParticleFwd_forward_acc_type {
    fn name(&self) -> &'static str {
        "forward"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleFwd) -> bool {
        m.has_forward()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticleFwd) -> &'a ::protobuf::Message {
        m.get_forward() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    control_point: Option<i32>,
    forward: ::protobuf::SingularPtrField<CMsgVector>,
    right: ::protobuf::SingularPtrField<CMsgVector>,
    up: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleOrient };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
                    control_point: None,
                    forward: ::protobuf::SingularPtrField::none(),
                    right: ::protobuf::SingularPtrField::none(),
                    up: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control_point(&'a mut self) -> &'a mut i32 {
        if self.control_point.is_none() {
            self.control_point = Some(0);
        };
        self.control_point.as_mut().unwrap()
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or_else(|| 0)
    }

    pub fn clear_forward(&mut self) {
        self.forward.clear();
    }

    pub fn has_forward(&self) -> bool {
        self.forward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward(&mut self, v: CMsgVector) {
        self.forward = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward(&'a mut self) -> &'a mut CMsgVector {
        if self.forward.is_none() {
            self.forward.set_default();
        };
        self.forward.as_mut().unwrap()
    }

    pub fn get_forward(&'a self) -> &'a CMsgVector {
        self.forward.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }

    pub fn clear_right(&mut self) {
        self.right.clear();
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: CMsgVector) {
        self.right = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right(&'a mut self) -> &'a mut CMsgVector {
        if self.right.is_none() {
            self.right.set_default();
        };
        self.right.as_mut().unwrap()
    }

    pub fn get_right(&'a self) -> &'a CMsgVector {
        self.right.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }

    pub fn clear_up(&mut self) {
        self.up.clear();
    }

    pub fn has_up(&self) -> bool {
        self.up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up(&mut self, v: CMsgVector) {
        self.up = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_up(&'a mut self) -> &'a mut CMsgVector {
        if self.up.is_none() {
            self.up.set_default();
        };
        self.up.as_mut().unwrap()
    }

    pub fn get_up(&'a self) -> &'a CMsgVector {
        self.up.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        CDOTAUserMsg_ParticleManager_UpdateParticleOrient::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.control_point = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.forward.set_default();
                    is.merge_message(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.right.set_default();
                    is.merge_message(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.up.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.control_point.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.forward.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.right.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.up.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.control_point {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.forward.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.right.as_ref() {
            Some(ref v) => {
                os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.up.as_ref() {
            Some(ref v) => {
                os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleOrient_control_point_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleOrient_forward_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleOrient_right_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleOrient_up_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleOrient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_forward();
        self.clear_right();
        self.clear_up();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleOrient_control_point_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleOrient_control_point_acc: CDOTAUserMsg_ParticleManager_UpdateParticleOrient_control_point_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleOrient_control_point_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> for CDOTAUserMsg_ParticleManager_UpdateParticleOrient_control_point_acc_type {
    fn name(&self) -> &'static str {
        "control_point"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> bool {
        m.has_control_point()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> i32 {
        m.get_control_point()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleOrient_forward_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleOrient_forward_acc: CDOTAUserMsg_ParticleManager_UpdateParticleOrient_forward_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleOrient_forward_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> for CDOTAUserMsg_ParticleManager_UpdateParticleOrient_forward_acc_type {
    fn name(&self) -> &'static str {
        "forward"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> bool {
        m.has_forward()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> &'a ::protobuf::Message {
        m.get_forward() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleOrient_right_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleOrient_right_acc: CDOTAUserMsg_ParticleManager_UpdateParticleOrient_right_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleOrient_right_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> for CDOTAUserMsg_ParticleManager_UpdateParticleOrient_right_acc_type {
    fn name(&self) -> &'static str {
        "right"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> bool {
        m.has_right()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> &'a ::protobuf::Message {
        m.get_right() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleOrient_up_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleOrient_up_acc: CDOTAUserMsg_ParticleManager_UpdateParticleOrient_up_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleOrient_up_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> for CDOTAUserMsg_ParticleManager_UpdateParticleOrient_up_acc_type {
    fn name(&self) -> &'static str {
        "up"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> bool {
        m.has_up()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticleOrient) -> &'a ::protobuf::Message {
        m.get_up() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    control_point: Option<i32>,
    position: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleFallback> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleFallback };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
                    control_point: None,
                    position: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control_point(&'a mut self) -> &'a mut i32 {
        if self.control_point.is_none() {
            self.control_point = Some(0);
        };
        self.control_point.as_mut().unwrap()
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or_else(|| 0)
    }

    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: CMsgVector) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&'a mut self) -> &'a mut CMsgVector {
        if self.position.is_none() {
            self.position.set_default();
        };
        self.position.as_mut().unwrap()
    }

    pub fn get_position(&'a self) -> &'a CMsgVector {
        self.position.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        CDOTAUserMsg_ParticleManager_UpdateParticleFallback::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.control_point = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.position.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.control_point.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.position.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.control_point {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.position.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleFallback_control_point_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleFallback_position_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleFallback",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_position();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleFallback_control_point_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleFallback_control_point_acc: CDOTAUserMsg_ParticleManager_UpdateParticleFallback_control_point_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleFallback_control_point_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFallback> for CDOTAUserMsg_ParticleManager_UpdateParticleFallback_control_point_acc_type {
    fn name(&self) -> &'static str {
        "control_point"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleFallback) -> bool {
        m.has_control_point()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleFallback) -> i32 {
        m.get_control_point()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleFallback_position_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleFallback_position_acc: CDOTAUserMsg_ParticleManager_UpdateParticleFallback_position_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleFallback_position_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleFallback> for CDOTAUserMsg_ParticleManager_UpdateParticleFallback_position_acc_type {
    fn name(&self) -> &'static str {
        "position"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleFallback) -> bool {
        m.has_position()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticleFallback) -> &'a ::protobuf::Message {
        m.get_position() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    control_point: Option<i32>,
    origin_offset: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleOffset> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleOffset };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
                    control_point: None,
                    origin_offset: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control_point(&'a mut self) -> &'a mut i32 {
        if self.control_point.is_none() {
            self.control_point = Some(0);
        };
        self.control_point.as_mut().unwrap()
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or_else(|| 0)
    }

    pub fn clear_origin_offset(&mut self) {
        self.origin_offset.clear();
    }

    pub fn has_origin_offset(&self) -> bool {
        self.origin_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_offset(&mut self, v: CMsgVector) {
        self.origin_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_offset(&'a mut self) -> &'a mut CMsgVector {
        if self.origin_offset.is_none() {
            self.origin_offset.set_default();
        };
        self.origin_offset.as_mut().unwrap()
    }

    pub fn get_origin_offset(&'a self) -> &'a CMsgVector {
        self.origin_offset.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        CDOTAUserMsg_ParticleManager_UpdateParticleOffset::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.control_point = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.origin_offset.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.control_point.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.origin_offset.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.control_point {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.origin_offset.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleOffset_control_point_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleOffset_origin_offset_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleOffset",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_origin_offset();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleOffset_control_point_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleOffset_control_point_acc: CDOTAUserMsg_ParticleManager_UpdateParticleOffset_control_point_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleOffset_control_point_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOffset> for CDOTAUserMsg_ParticleManager_UpdateParticleOffset_control_point_acc_type {
    fn name(&self) -> &'static str {
        "control_point"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOffset) -> bool {
        m.has_control_point()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOffset) -> i32 {
        m.get_control_point()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleOffset_origin_offset_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleOffset_origin_offset_acc: CDOTAUserMsg_ParticleManager_UpdateParticleOffset_origin_offset_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleOffset_origin_offset_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleOffset> for CDOTAUserMsg_ParticleManager_UpdateParticleOffset_origin_offset_acc_type {
    fn name(&self) -> &'static str {
        "origin_offset"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleOffset) -> bool {
        m.has_origin_offset()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticleOffset) -> &'a ::protobuf::Message {
        m.get_origin_offset() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    control_point: Option<i32>,
    entity_handle: Option<i32>,
    attach_type: Option<i32>,
    attachment: Option<i32>,
    fallback_position: ::protobuf::SingularPtrField<CMsgVector>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleEnt };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
                    control_point: None,
                    entity_handle: None,
                    attach_type: None,
                    attachment: None,
                    fallback_position: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control_point(&'a mut self) -> &'a mut i32 {
        if self.control_point.is_none() {
            self.control_point = Some(0);
        };
        self.control_point.as_mut().unwrap()
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or_else(|| 0)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_handle(&'a mut self) -> &'a mut i32 {
        if self.entity_handle.is_none() {
            self.entity_handle = Some(0);
        };
        self.entity_handle.as_mut().unwrap()
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or_else(|| 0)
    }

    pub fn clear_attach_type(&mut self) {
        self.attach_type = None;
    }

    pub fn has_attach_type(&self) -> bool {
        self.attach_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_type(&mut self, v: i32) {
        self.attach_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_type(&'a mut self) -> &'a mut i32 {
        if self.attach_type.is_none() {
            self.attach_type = Some(0);
        };
        self.attach_type.as_mut().unwrap()
    }

    pub fn get_attach_type(&self) -> i32 {
        self.attach_type.unwrap_or_else(|| 0)
    }

    pub fn clear_attachment(&mut self) {
        self.attachment = None;
    }

    pub fn has_attachment(&self) -> bool {
        self.attachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachment(&mut self, v: i32) {
        self.attachment = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachment(&'a mut self) -> &'a mut i32 {
        if self.attachment.is_none() {
            self.attachment = Some(0);
        };
        self.attachment.as_mut().unwrap()
    }

    pub fn get_attachment(&self) -> i32 {
        self.attachment.unwrap_or_else(|| 0)
    }

    pub fn clear_fallback_position(&mut self) {
        self.fallback_position.clear();
    }

    pub fn has_fallback_position(&self) -> bool {
        self.fallback_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallback_position(&mut self, v: CMsgVector) {
        self.fallback_position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_position(&'a mut self) -> &'a mut CMsgVector {
        if self.fallback_position.is_none() {
            self.fallback_position.set_default();
        };
        self.fallback_position.as_mut().unwrap()
    }

    pub fn get_fallback_position(&'a self) -> &'a CMsgVector {
        self.fallback_position.as_ref().unwrap_or_else(|| CMsgVector::default_instance())
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        CDOTAUserMsg_ParticleManager_UpdateParticleEnt::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.control_point = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.entity_handle = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.attach_type = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.attachment = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.fallback_position.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.control_point.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entity_handle.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.attach_type.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.attachment.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.fallback_position.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.control_point {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.entity_handle {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.attach_type {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.attachment {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.fallback_position.as_ref() {
            Some(ref v) => {
                os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleEnt_control_point_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleEnt_entity_handle_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attach_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attachment_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleEnt_fallback_position_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleEnt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_entity_handle();
        self.clear_attach_type();
        self.clear_attachment();
        self.clear_fallback_position();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleEnt_control_point_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleEnt_control_point_acc: CDOTAUserMsg_ParticleManager_UpdateParticleEnt_control_point_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleEnt_control_point_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> for CDOTAUserMsg_ParticleManager_UpdateParticleEnt_control_point_acc_type {
    fn name(&self) -> &'static str {
        "control_point"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> bool {
        m.has_control_point()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> i32 {
        m.get_control_point()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleEnt_entity_handle_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleEnt_entity_handle_acc: CDOTAUserMsg_ParticleManager_UpdateParticleEnt_entity_handle_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleEnt_entity_handle_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> for CDOTAUserMsg_ParticleManager_UpdateParticleEnt_entity_handle_acc_type {
    fn name(&self) -> &'static str {
        "entity_handle"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> bool {
        m.has_entity_handle()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> i32 {
        m.get_entity_handle()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attach_type_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attach_type_acc: CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attach_type_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attach_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> for CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attach_type_acc_type {
    fn name(&self) -> &'static str {
        "attach_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> bool {
        m.has_attach_type()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> i32 {
        m.get_attach_type()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attachment_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attachment_acc: CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attachment_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attachment_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> for CDOTAUserMsg_ParticleManager_UpdateParticleEnt_attachment_acc_type {
    fn name(&self) -> &'static str {
        "attachment"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> bool {
        m.has_attachment()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> i32 {
        m.get_attachment()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleEnt_fallback_position_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleEnt_fallback_position_acc: CDOTAUserMsg_ParticleManager_UpdateParticleEnt_fallback_position_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleEnt_fallback_position_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> for CDOTAUserMsg_ParticleManager_UpdateParticleEnt_fallback_position_acc_type {
    fn name(&self) -> &'static str {
        "fallback_position"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> bool {
        m.has_fallback_position()
    }

    fn get_message<'a>(&self, m: &'a CDOTAUserMsg_ParticleManager_UpdateParticleEnt) -> &'a ::protobuf::Message {
        m.get_fallback_position() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
    player_latency: Option<i32>,
    tick: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleLatency> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleLatency };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
                    player_latency: None,
                    tick: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_player_latency(&mut self) {
        self.player_latency = None;
    }

    pub fn has_player_latency(&self) -> bool {
        self.player_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_latency(&mut self, v: i32) {
        self.player_latency = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_latency(&'a mut self) -> &'a mut i32 {
        if self.player_latency.is_none() {
            self.player_latency = Some(0);
        };
        self.player_latency.as_mut().unwrap()
    }

    pub fn get_player_latency(&self) -> i32 {
        self.player_latency.unwrap_or_else(|| 0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tick(&'a mut self) -> &'a mut i32 {
        if self.tick.is_none() {
            self.tick = Some(0);
        };
        self.tick.as_mut().unwrap()
    }

    pub fn get_tick(&self) -> i32 {
        self.tick.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
        CDOTAUserMsg_ParticleManager_UpdateParticleLatency::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.player_latency = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.tick = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.player_latency.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.tick.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.player_latency {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.tick {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_ParticleManager_UpdateParticleLatency>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleLatency>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleLatency_player_latency_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleLatency>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_ParticleManager_UpdateParticleLatency_tick_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleLatency>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleLatency>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleLatency",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_ParticleManager_UpdateParticleLatency>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
    fn clear(&mut self) {
        self.clear_player_latency();
        self.clear_tick();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_ParticleManager_UpdateParticleLatency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleLatency_player_latency_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleLatency_player_latency_acc: CDOTAUserMsg_ParticleManager_UpdateParticleLatency_player_latency_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleLatency_player_latency_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleLatency> for CDOTAUserMsg_ParticleManager_UpdateParticleLatency_player_latency_acc_type {
    fn name(&self) -> &'static str {
        "player_latency"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleLatency) -> bool {
        m.has_player_latency()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleLatency) -> i32 {
        m.get_player_latency()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_ParticleManager_UpdateParticleLatency_tick_acc_type;
static CDOTAUserMsg_ParticleManager_UpdateParticleLatency_tick_acc: CDOTAUserMsg_ParticleManager_UpdateParticleLatency_tick_acc_type = CDOTAUserMsg_ParticleManager_UpdateParticleLatency_tick_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_ParticleManager_UpdateParticleLatency> for CDOTAUserMsg_ParticleManager_UpdateParticleLatency_tick_acc_type {
    fn name(&self) -> &'static str {
        "tick"
    }

    fn has_field(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleLatency) -> bool {
        m.has_tick()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_ParticleManager_UpdateParticleLatency) -> i32 {
        m.get_tick()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_OverheadEvent {
    message_type: Option<DOTA_OVERHEAD_ALERT>,
    value: Option<i32>,
    target_player_entindex: Option<i32>,
    target_entindex: Option<i32>,
    source_player_entindex: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_OverheadEvent {
    pub fn new() -> CDOTAUserMsg_OverheadEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_OverheadEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_OverheadEvent> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_OverheadEvent };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_OverheadEvent {
                    message_type: None,
                    value: None,
                    target_player_entindex: None,
                    target_entindex: None,
                    source_player_entindex: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: DOTA_OVERHEAD_ALERT) {
        self.message_type = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_type(&'a mut self) -> &'a mut DOTA_OVERHEAD_ALERT {
        if self.message_type.is_none() {
            self.message_type = Some(DOTA_OVERHEAD_ALERT::new(0));
        };
        self.message_type.as_mut().unwrap()
    }

    pub fn get_message_type(&self) -> DOTA_OVERHEAD_ALERT {
        self.message_type.unwrap_or_else(|| DOTA_OVERHEAD_ALERT::new(0))
    }

    pub fn clear_value(&mut self) {
        self.value = None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&'a mut self) -> &'a mut i32 {
        if self.value.is_none() {
            self.value = Some(0);
        };
        self.value.as_mut().unwrap()
    }

    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or_else(|| 0)
    }

    pub fn clear_target_player_entindex(&mut self) {
        self.target_player_entindex = None;
    }

    pub fn has_target_player_entindex(&self) -> bool {
        self.target_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_entindex(&mut self, v: i32) {
        self.target_player_entindex = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_player_entindex(&'a mut self) -> &'a mut i32 {
        if self.target_player_entindex.is_none() {
            self.target_player_entindex = Some(0);
        };
        self.target_player_entindex.as_mut().unwrap()
    }

    pub fn get_target_player_entindex(&self) -> i32 {
        self.target_player_entindex.unwrap_or_else(|| 0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_entindex(&'a mut self) -> &'a mut i32 {
        if self.target_entindex.is_none() {
            self.target_entindex = Some(0);
        };
        self.target_entindex.as_mut().unwrap()
    }

    pub fn get_target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or_else(|| 0)
    }

    pub fn clear_source_player_entindex(&mut self) {
        self.source_player_entindex = None;
    }

    pub fn has_source_player_entindex(&self) -> bool {
        self.source_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_entindex(&mut self, v: i32) {
        self.source_player_entindex = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_player_entindex(&'a mut self) -> &'a mut i32 {
        if self.source_player_entindex.is_none() {
            self.source_player_entindex = Some(0);
        };
        self.source_player_entindex.as_mut().unwrap()
    }

    pub fn get_source_player_entindex(&self) -> i32 {
        self.source_player_entindex.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_OverheadEvent {
    fn new() -> CDOTAUserMsg_OverheadEvent {
        CDOTAUserMsg_OverheadEvent::new()
    }

    fn is_initialized(&self) -> bool {
        if self.message_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = DOTA_OVERHEAD_ALERT::new(is.read_int32());
                    self.message_type = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.value = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.target_player_entindex = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.target_entindex = Some(tmp);
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.source_player_entindex = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.message_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.target_player_entindex.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.target_entindex.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.source_player_entindex.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.message_type {
            Some(ref v) => {
                os.write_enum(1, *v as i32);
            },
            None => {},
        };
        match self.value {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.target_player_entindex {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.target_entindex {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        match self.source_player_entindex {
            Some(ref v) => {
                os.write_int32(5, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_OverheadEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_OverheadEvent_message_type_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_OverheadEvent_value_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_OverheadEvent_target_player_entindex_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_OverheadEvent_target_entindex_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_OverheadEvent_source_player_entindex_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_OverheadEvent>(
                    "CDOTAUserMsg_OverheadEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_OverheadEvent>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_OverheadEvent {
    fn clear(&mut self) {
        self.clear_message_type();
        self.clear_value();
        self.clear_target_player_entindex();
        self.clear_target_entindex();
        self.clear_source_player_entindex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_OverheadEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_OverheadEvent_message_type_acc_type;
static CDOTAUserMsg_OverheadEvent_message_type_acc: CDOTAUserMsg_OverheadEvent_message_type_acc_type = CDOTAUserMsg_OverheadEvent_message_type_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent> for CDOTAUserMsg_OverheadEvent_message_type_acc_type {
    fn name(&self) -> &'static str {
        "message_type"
    }

    fn has_field(&self, m: &CDOTAUserMsg_OverheadEvent) -> bool {
        m.has_message_type()
    }

    fn get_enum<'a>(&self, m: &CDOTAUserMsg_OverheadEvent) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        use protobuf::{ProtobufEnum};
        m.get_message_type().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_OverheadEvent_value_acc_type;
static CDOTAUserMsg_OverheadEvent_value_acc: CDOTAUserMsg_OverheadEvent_value_acc_type = CDOTAUserMsg_OverheadEvent_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent> for CDOTAUserMsg_OverheadEvent_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &CDOTAUserMsg_OverheadEvent) -> bool {
        m.has_value()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_OverheadEvent) -> i32 {
        m.get_value()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_OverheadEvent_target_player_entindex_acc_type;
static CDOTAUserMsg_OverheadEvent_target_player_entindex_acc: CDOTAUserMsg_OverheadEvent_target_player_entindex_acc_type = CDOTAUserMsg_OverheadEvent_target_player_entindex_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent> for CDOTAUserMsg_OverheadEvent_target_player_entindex_acc_type {
    fn name(&self) -> &'static str {
        "target_player_entindex"
    }

    fn has_field(&self, m: &CDOTAUserMsg_OverheadEvent) -> bool {
        m.has_target_player_entindex()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_OverheadEvent) -> i32 {
        m.get_target_player_entindex()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_OverheadEvent_target_entindex_acc_type;
static CDOTAUserMsg_OverheadEvent_target_entindex_acc: CDOTAUserMsg_OverheadEvent_target_entindex_acc_type = CDOTAUserMsg_OverheadEvent_target_entindex_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent> for CDOTAUserMsg_OverheadEvent_target_entindex_acc_type {
    fn name(&self) -> &'static str {
        "target_entindex"
    }

    fn has_field(&self, m: &CDOTAUserMsg_OverheadEvent) -> bool {
        m.has_target_entindex()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_OverheadEvent) -> i32 {
        m.get_target_entindex()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_OverheadEvent_source_player_entindex_acc_type;
static CDOTAUserMsg_OverheadEvent_source_player_entindex_acc: CDOTAUserMsg_OverheadEvent_source_player_entindex_acc_type = CDOTAUserMsg_OverheadEvent_source_player_entindex_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_OverheadEvent> for CDOTAUserMsg_OverheadEvent_source_player_entindex_acc_type {
    fn name(&self) -> &'static str {
        "source_player_entindex"
    }

    fn has_field(&self, m: &CDOTAUserMsg_OverheadEvent) -> bool {
        m.has_source_player_entindex()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_OverheadEvent) -> i32 {
        m.get_source_player_entindex()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDOTAUserMsg_TutorialTipInfo {
    name: ::protobuf::SingularField<String>,
    progress: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDOTAUserMsg_TutorialTipInfo {
    pub fn new() -> CDOTAUserMsg_TutorialTipInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TutorialTipInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TutorialTipInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDOTAUserMsg_TutorialTipInfo };
        unsafe {
            instance.get(|| {
                CDOTAUserMsg_TutorialTipInfo {
                    name: ::protobuf::SingularField::none(),
                    progress: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_progress(&mut self) {
        self.progress = None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&'a mut self) -> &'a mut i32 {
        if self.progress.is_none() {
            self.progress = Some(0);
        };
        self.progress.as_mut().unwrap()
    }

    pub fn get_progress(&self) -> i32 {
        self.progress.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialTipInfo {
    fn new() -> CDOTAUserMsg_TutorialTipInfo {
        CDOTAUserMsg_TutorialTipInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.progress = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.progress.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.progress {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDOTAUserMsg_TutorialTipInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_TutorialTipInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_TutorialTipInfo_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_TutorialTipInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CDOTAUserMsg_TutorialTipInfo_progress_acc as &'static ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_TutorialTipInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TutorialTipInfo>(
                    "CDOTAUserMsg_TutorialTipInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDOTAUserMsg_TutorialTipInfo>()
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TutorialTipInfo {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_progress();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDOTAUserMsg_TutorialTipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDOTAUserMsg_TutorialTipInfo_name_acc_type;
static CDOTAUserMsg_TutorialTipInfo_name_acc: CDOTAUserMsg_TutorialTipInfo_name_acc_type = CDOTAUserMsg_TutorialTipInfo_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_TutorialTipInfo> for CDOTAUserMsg_TutorialTipInfo_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &CDOTAUserMsg_TutorialTipInfo) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a CDOTAUserMsg_TutorialTipInfo) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct CDOTAUserMsg_TutorialTipInfo_progress_acc_type;
static CDOTAUserMsg_TutorialTipInfo_progress_acc: CDOTAUserMsg_TutorialTipInfo_progress_acc_type = CDOTAUserMsg_TutorialTipInfo_progress_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDOTAUserMsg_TutorialTipInfo> for CDOTAUserMsg_TutorialTipInfo_progress_acc_type {
    fn name(&self) -> &'static str {
        "progress"
    }

    fn has_field(&self, m: &CDOTAUserMsg_TutorialTipInfo) -> bool {
        m.has_progress()
    }

    fn get_i32(&self, m: &CDOTAUserMsg_TutorialTipInfo) -> i32 {
        m.get_progress()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum EDotaUserMessages {
    DOTA_UM_AddUnitToSelection = 64,
    DOTA_UM_AIDebugLine = 65,
    DOTA_UM_ChatEvent = 66,
    DOTA_UM_CombatHeroPositions = 67,
    DOTA_UM_CombatLogData = 68,
    DOTA_UM_CombatLogShowDeath = 70,
    DOTA_UM_CreateLinearProjectile = 71,
    DOTA_UM_DestroyLinearProjectile = 72,
    DOTA_UM_DodgeTrackingProjectiles = 73,
    DOTA_UM_GlobalLightColor = 74,
    DOTA_UM_GlobalLightDirection = 75,
    DOTA_UM_InvalidCommand = 76,
    DOTA_UM_LocationPing = 77,
    DOTA_UM_MapLine = 78,
    DOTA_UM_MiniKillCamInfo = 79,
    DOTA_UM_MinimapDebugPoint = 80,
    DOTA_UM_MinimapEvent = 81,
    DOTA_UM_NevermoreRequiem = 82,
    DOTA_UM_OverheadEvent = 83,
    DOTA_UM_SetNextAutobuyItem = 84,
    DOTA_UM_SharedCooldown = 85,
    DOTA_UM_SpectatorPlayerClick = 86,
    DOTA_UM_TutorialTipInfo = 87,
    DOTA_UM_UnitEvent = 88,
    DOTA_UM_ParticleManager = 89,
    DOTA_UM_BotChat = 90,
    DOTA_UM_HudError = 91,
    DOTA_UM_ItemPurchased = 92,
    DOTA_UM_Ping = 93,
    DOTA_UM_ItemFound = 94,
}

impl EDotaUserMessages {
    pub fn new(value: i32) -> EDotaUserMessages {
        match value {
            64 => DOTA_UM_AddUnitToSelection,
            65 => DOTA_UM_AIDebugLine,
            66 => DOTA_UM_ChatEvent,
            67 => DOTA_UM_CombatHeroPositions,
            68 => DOTA_UM_CombatLogData,
            70 => DOTA_UM_CombatLogShowDeath,
            71 => DOTA_UM_CreateLinearProjectile,
            72 => DOTA_UM_DestroyLinearProjectile,
            73 => DOTA_UM_DodgeTrackingProjectiles,
            74 => DOTA_UM_GlobalLightColor,
            75 => DOTA_UM_GlobalLightDirection,
            76 => DOTA_UM_InvalidCommand,
            77 => DOTA_UM_LocationPing,
            78 => DOTA_UM_MapLine,
            79 => DOTA_UM_MiniKillCamInfo,
            80 => DOTA_UM_MinimapDebugPoint,
            81 => DOTA_UM_MinimapEvent,
            82 => DOTA_UM_NevermoreRequiem,
            83 => DOTA_UM_OverheadEvent,
            84 => DOTA_UM_SetNextAutobuyItem,
            85 => DOTA_UM_SharedCooldown,
            86 => DOTA_UM_SpectatorPlayerClick,
            87 => DOTA_UM_TutorialTipInfo,
            88 => DOTA_UM_UnitEvent,
            89 => DOTA_UM_ParticleManager,
            90 => DOTA_UM_BotChat,
            91 => DOTA_UM_HudError,
            92 => DOTA_UM_ItemPurchased,
            93 => DOTA_UM_Ping,
            94 => DOTA_UM_ItemFound,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for EDotaUserMessages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<EDotaUserMessages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDotaUserMessages", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum DOTA_CHAT_MESSAGE {
    CHAT_MESSAGE_INVALID = -1,
    CHAT_MESSAGE_HERO_KILL = 0,
    CHAT_MESSAGE_HERO_DENY = 1,
    CHAT_MESSAGE_BARRACKS_KILL = 2,
    CHAT_MESSAGE_TOWER_KILL = 3,
    CHAT_MESSAGE_TOWER_DENY = 4,
    CHAT_MESSAGE_FIRSTBLOOD = 5,
    CHAT_MESSAGE_STREAK_KILL = 6,
    CHAT_MESSAGE_BUYBACK = 7,
    CHAT_MESSAGE_AEGIS = 8,
    CHAT_MESSAGE_ROSHAN_KILL = 9,
    CHAT_MESSAGE_COURIER_LOST = 10,
    CHAT_MESSAGE_COURIER_RESPAWNED = 11,
    CHAT_MESSAGE_GLYPH_USED = 12,
    CHAT_MESSAGE_ITEM_PURCHASE = 13,
    CHAT_MESSAGE_CONNECT = 14,
    CHAT_MESSAGE_DISCONNECT = 15,
    CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT = 16,
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING = 17,
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL = 18,
    CHAT_MESSAGE_RECONNECT = 19,
    CHAT_MESSAGE_ABANDON = 20,
    CHAT_MESSAGE_SAFE_TO_LEAVE = 21,
    CHAT_MESSAGE_RUNE_PICKUP = 22,
    CHAT_MESSAGE_RUNE_BOTTLE = 23,
    CHAT_MESSAGE_INTHEBAG = 24,
    CHAT_MESSAGE_SECRETSHOP = 25,
    CHAT_MESSAGE_ITEM_AUTOPURCHASED = 26,
    CHAT_MESSAGE_ITEMS_COMBINED = 27,
    CHAT_MESSAGE_SUPER_CREEPS = 28,
    CHAT_MESSAGE_CANT_USE_ACTION_ITEM = 29,
    CHAT_MESSAGE_CHARGES_EXHAUSTED = 30,
    CHAT_MESSAGE_CANTPAUSE = 31,
    CHAT_MESSAGE_NOPAUSESLEFT = 32,
    CHAT_MESSAGE_CANTPAUSEYET = 33,
    CHAT_MESSAGE_PAUSED = 34,
    CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 35,
    CHAT_MESSAGE_UNPAUSED = 36,
    CHAT_MESSAGE_AUTO_UNPAUSED = 37,
    CHAT_MESSAGE_YOUPAUSED = 38,
    CHAT_MESSAGE_CANTUNPAUSETEAM = 39,
    CHAT_MESSAGE_SAFE_TO_LEAVE_ABANDONER = 40,
    CHAT_MESSAGE_VOICE_TEXT_BANNED = 41,
    CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME = 42,
    CHAT_MESSAGE_REPORT_REMINDER = 43,
    CHAT_MESSAGE_ECON_ITEM = 44,
    CHAT_MESSAGE_TAUNT = 45,
    CHAT_MESSAGE_RANDOM = 46,
    CHAT_MESSAGE_RD_TURN = 47,
}

impl DOTA_CHAT_MESSAGE {
    pub fn new(value: i32) -> DOTA_CHAT_MESSAGE {
        match value {
            -1 => CHAT_MESSAGE_INVALID,
            0 => CHAT_MESSAGE_HERO_KILL,
            1 => CHAT_MESSAGE_HERO_DENY,
            2 => CHAT_MESSAGE_BARRACKS_KILL,
            3 => CHAT_MESSAGE_TOWER_KILL,
            4 => CHAT_MESSAGE_TOWER_DENY,
            5 => CHAT_MESSAGE_FIRSTBLOOD,
            6 => CHAT_MESSAGE_STREAK_KILL,
            7 => CHAT_MESSAGE_BUYBACK,
            8 => CHAT_MESSAGE_AEGIS,
            9 => CHAT_MESSAGE_ROSHAN_KILL,
            10 => CHAT_MESSAGE_COURIER_LOST,
            11 => CHAT_MESSAGE_COURIER_RESPAWNED,
            12 => CHAT_MESSAGE_GLYPH_USED,
            13 => CHAT_MESSAGE_ITEM_PURCHASE,
            14 => CHAT_MESSAGE_CONNECT,
            15 => CHAT_MESSAGE_DISCONNECT,
            16 => CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT,
            17 => CHAT_MESSAGE_DISCONNECT_TIME_REMAINING,
            18 => CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL,
            19 => CHAT_MESSAGE_RECONNECT,
            20 => CHAT_MESSAGE_ABANDON,
            21 => CHAT_MESSAGE_SAFE_TO_LEAVE,
            22 => CHAT_MESSAGE_RUNE_PICKUP,
            23 => CHAT_MESSAGE_RUNE_BOTTLE,
            24 => CHAT_MESSAGE_INTHEBAG,
            25 => CHAT_MESSAGE_SECRETSHOP,
            26 => CHAT_MESSAGE_ITEM_AUTOPURCHASED,
            27 => CHAT_MESSAGE_ITEMS_COMBINED,
            28 => CHAT_MESSAGE_SUPER_CREEPS,
            29 => CHAT_MESSAGE_CANT_USE_ACTION_ITEM,
            30 => CHAT_MESSAGE_CHARGES_EXHAUSTED,
            31 => CHAT_MESSAGE_CANTPAUSE,
            32 => CHAT_MESSAGE_NOPAUSESLEFT,
            33 => CHAT_MESSAGE_CANTPAUSEYET,
            34 => CHAT_MESSAGE_PAUSED,
            35 => CHAT_MESSAGE_UNPAUSE_COUNTDOWN,
            36 => CHAT_MESSAGE_UNPAUSED,
            37 => CHAT_MESSAGE_AUTO_UNPAUSED,
            38 => CHAT_MESSAGE_YOUPAUSED,
            39 => CHAT_MESSAGE_CANTUNPAUSETEAM,
            40 => CHAT_MESSAGE_SAFE_TO_LEAVE_ABANDONER,
            41 => CHAT_MESSAGE_VOICE_TEXT_BANNED,
            42 => CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME,
            43 => CHAT_MESSAGE_REPORT_REMINDER,
            44 => CHAT_MESSAGE_ECON_ITEM,
            45 => CHAT_MESSAGE_TAUNT,
            46 => CHAT_MESSAGE_RANDOM,
            47 => CHAT_MESSAGE_RD_TURN,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for DOTA_CHAT_MESSAGE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<DOTA_CHAT_MESSAGE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_CHAT_MESSAGE", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum EDotaEntityMessages {
    DOTA_UNIT_SPEECH = 0,
    DOTA_UNIT_SPEECH_MUTE = 1,
    DOTA_UNIT_ADD_GESTURE = 2,
    DOTA_UNIT_REMOVE_GESTURE = 3,
    DOTA_UNIT_REMOVE_ALL_GESTURES = 4,
    DOTA_UNIT_FADE_GESTURE = 6,
}

impl EDotaEntityMessages {
    pub fn new(value: i32) -> EDotaEntityMessages {
        match value {
            0 => DOTA_UNIT_SPEECH,
            1 => DOTA_UNIT_SPEECH_MUTE,
            2 => DOTA_UNIT_ADD_GESTURE,
            3 => DOTA_UNIT_REMOVE_GESTURE,
            4 => DOTA_UNIT_REMOVE_ALL_GESTURES,
            6 => DOTA_UNIT_FADE_GESTURE,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for EDotaEntityMessages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<EDotaEntityMessages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDotaEntityMessages", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum DOTA_PARTICLE_MESSAGE {
    DOTA_PARTICLE_MANAGER_EVENT_CREATE = 0,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE = 1,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6,
    DOTA_PARTICLE_MANAGER_EVENT_DESTROY = 7,
    DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8,
    DOTA_PARTICLE_MANAGER_EVENT_RELEASE = 9,
    DOTA_PARTICLE_MANAGER_EVENT_LATENCY = 10,
}

impl DOTA_PARTICLE_MESSAGE {
    pub fn new(value: i32) -> DOTA_PARTICLE_MESSAGE {
        match value {
            0 => DOTA_PARTICLE_MANAGER_EVENT_CREATE,
            1 => DOTA_PARTICLE_MANAGER_EVENT_UPDATE,
            2 => DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD,
            3 => DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION,
            4 => DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK,
            5 => DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT,
            6 => DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET,
            7 => DOTA_PARTICLE_MANAGER_EVENT_DESTROY,
            8 => DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING,
            9 => DOTA_PARTICLE_MANAGER_EVENT_RELEASE,
            10 => DOTA_PARTICLE_MANAGER_EVENT_LATENCY,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for DOTA_PARTICLE_MESSAGE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<DOTA_PARTICLE_MESSAGE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_PARTICLE_MESSAGE", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum DOTA_OVERHEAD_ALERT {
    OVERHEAD_ALERT_GOLD = 0,
    OVERHEAD_ALERT_DENY = 1,
    OVERHEAD_ALERT_CRITICAL = 2,
    OVERHEAD_ALERT_XP = 3,
    OVERHEAD_ALERT_BONUS_SPELL_DAMAGE = 4,
    OVERHEAD_ALERT_MISS = 5,
    OVERHEAD_ALERT_DAMAGE = 6,
    OVERHEAD_ALERT_EVADE = 7,
    OVERHEAD_ALERT_BLOCK = 8,
    OVERHEAD_ALERT_BONUS_POISON_DAMAGE = 9,
}

impl DOTA_OVERHEAD_ALERT {
    pub fn new(value: i32) -> DOTA_OVERHEAD_ALERT {
        match value {
            0 => OVERHEAD_ALERT_GOLD,
            1 => OVERHEAD_ALERT_DENY,
            2 => OVERHEAD_ALERT_CRITICAL,
            3 => OVERHEAD_ALERT_XP,
            4 => OVERHEAD_ALERT_BONUS_SPELL_DAMAGE,
            5 => OVERHEAD_ALERT_MISS,
            6 => OVERHEAD_ALERT_DAMAGE,
            7 => OVERHEAD_ALERT_EVADE,
            8 => OVERHEAD_ALERT_BLOCK,
            9 => OVERHEAD_ALERT_BONUS_POISON_DAMAGE,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for DOTA_OVERHEAD_ALERT {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<DOTA_OVERHEAD_ALERT>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_OVERHEAD_ALERT", file_descriptor_proto())
            })
        }
    }
}
