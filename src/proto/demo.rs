// This file is generated. Do not edit

#![allow(dead_code)]
#![allow(non_camel_case_types)]

use descriptor::*;

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x0a, 0x64, 0x65, 0x6d, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x67, 0x6f,
    0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65,
    0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xd8,
    0x01, 0x0a, 0x0f, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x46, 0x69, 0x6c, 0x65, 0x48, 0x65, 0x61, 0x64,
    0x65, 0x72, 0x12, 0x17, 0x0a, 0x0f, 0x64, 0x65, 0x6d, 0x6f, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f,
    0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x18, 0x0a, 0x10, 0x6e,
    0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f,
    0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x13, 0x0a, 0x0b, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x10, 0x0a, 0x08, 0x6d, 0x61, 0x70, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x16, 0x0a, 0x0e, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x6f, 0x72, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1b, 0x0a, 0x13, 0x66, 0x75, 0x6c,
    0x6c, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x12, 0x21, 0x0a, 0x19, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x69, 0x64, 0x65, 0x5f, 0x65, 0x6e, 0x74, 0x69, 0x74,
    0x69, 0x65, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x22, 0x89, 0x02, 0x0a, 0x09, 0x43, 0x47,
    0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x26, 0x0a, 0x04, 0x64, 0x6f, 0x74, 0x61, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x43, 0x47, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66,
    0x6f, 0x2e, 0x43, 0x44, 0x6f, 0x74, 0x61, 0x47, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x1a,
    0xd3, 0x01, 0x0a, 0x0d, 0x43, 0x44, 0x6f, 0x74, 0x61, 0x47, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x6d, 0x6f, 0x64, 0x65,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x77,
    0x69, 0x6e, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x39, 0x0a, 0x0b, 0x70,
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x24, 0x2e, 0x43, 0x47, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x43, 0x44, 0x6f,
    0x74, 0x61, 0x47, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x43, 0x50, 0x6c, 0x61, 0x79,
    0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x1a, 0x4d, 0x0a, 0x0b, 0x43, 0x50, 0x6c, 0x61, 0x79, 0x65,
    0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x68, 0x65, 0x72, 0x6f, 0x5f, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x6c, 0x61, 0x79,
    0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x16, 0x0a,
    0x0e, 0x69, 0x73, 0x5f, 0x66, 0x61, 0x6b, 0x65, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x08, 0x22, 0x76, 0x0a, 0x0d, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x46, 0x69,
    0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x15, 0x0a, 0x0d, 0x70, 0x6c, 0x61, 0x79, 0x62, 0x61,
    0x63, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x12, 0x16, 0x0a,
    0x0e, 0x70, 0x6c, 0x61, 0x79, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x17, 0x0a, 0x0f, 0x70, 0x6c, 0x61, 0x79, 0x62, 0x61, 0x63,
    0x6b, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1d,
    0x0a, 0x09, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x0a, 0x2e, 0x43, 0x47, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x4a, 0x0a,
    0x0b, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x13, 0x0a, 0x0b,
    0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x18, 0x0a, 0x10, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x6f, 0x75,
    0x74, 0x5f, 0x61, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x64,
    0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x59, 0x0a, 0x0f, 0x43, 0x44, 0x65,
    0x6d, 0x6f, 0x46, 0x75, 0x6c, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x28, 0x0a, 0x0c,
    0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x12, 0x2e, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
    0x54, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x1c, 0x0a, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x50, 0x61,
    0x63, 0x6b, 0x65, 0x74, 0x22, 0x0f, 0x0a, 0x0d, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x53, 0x79, 0x6e,
    0x63, 0x54, 0x69, 0x63, 0x6b, 0x22, 0x24, 0x0a, 0x0f, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x43, 0x6f,
    0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x43, 0x6d, 0x64, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x6d, 0x64, 0x73,
    0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x22, 0x1f, 0x0a, 0x0f, 0x43,
    0x44, 0x65, 0x6d, 0x6f, 0x53, 0x65, 0x6e, 0x64, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x0c,
    0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x81, 0x01, 0x0a,
    0x0e, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x12,
    0x28, 0x0a, 0x07, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x17, 0x2e, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x49, 0x6e, 0x66,
    0x6f, 0x2e, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x1a, 0x45, 0x0a, 0x07, 0x63, 0x6c, 0x61,
    0x73, 0x73, 0x5f, 0x74, 0x12, 0x10, 0x0a, 0x08, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x69, 0x64,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
    0x6b, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a,
    0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
    0x22, 0x37, 0x0a, 0x0f, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44,
    0x61, 0x74, 0x61, 0x12, 0x16, 0x0a, 0x0e, 0x63, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x5f,
    0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x64,
    0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x2b, 0x0a, 0x18, 0x43, 0x44, 0x65,
    0x6d, 0x6f, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x43, 0x61, 0x6c, 0x6c,
    0x62, 0x61, 0x63, 0x6b, 0x73, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x61, 0x76, 0x65, 0x5f, 0x69, 0x64,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x22, 0xfb, 0x01, 0x0a, 0x11, 0x43, 0x44, 0x65, 0x6d, 0x6f,
    0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x2a, 0x0a, 0x06,
    0x74, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x43,
    0x44, 0x65, 0x6d, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x73,
    0x2e, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x74, 0x1a, 0x24, 0x0a, 0x07, 0x69, 0x74, 0x65, 0x6d,
    0x73, 0x5f, 0x74, 0x12, 0x0b, 0x0a, 0x03, 0x73, 0x74, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x1a, 0x93,
    0x01, 0x0a, 0x07, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x74, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x61,
    0x62, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x29,
    0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
    0x43, 0x44, 0x65, 0x6d, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65,
    0x73, 0x2e, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x74, 0x12, 0x34, 0x0a, 0x10, 0x69, 0x74, 0x65,
    0x6d, 0x73, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x69, 0x64, 0x65, 0x18, 0x03, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e,
    0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x2e, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x74, 0x12,
    0x13, 0x0a, 0x0b, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x05, 0x22, 0x0b, 0x0a, 0x09, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x53, 0x74, 0x6f,
    0x70, 0x22, 0x30, 0x0a, 0x0c, 0x43, 0x44, 0x65, 0x6d, 0x6f, 0x55, 0x73, 0x65, 0x72, 0x43, 0x6d,
    0x64, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x6d, 0x64, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0c, 0x2a, 0xdd, 0x02, 0x0a, 0x0d, 0x45, 0x44, 0x65, 0x6d, 0x6f, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x73, 0x12, 0x16, 0x0a, 0x09, 0x44, 0x45, 0x4d, 0x5f, 0x45, 0x72, 0x72,
    0x6f, 0x72, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x0c, 0x0a,
    0x08, 0x44, 0x45, 0x4d, 0x5f, 0x53, 0x74, 0x6f, 0x70, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x44,
    0x45, 0x4d, 0x5f, 0x46, 0x69, 0x6c, 0x65, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x10, 0x01, 0x12,
    0x10, 0x0a, 0x0c, 0x44, 0x45, 0x4d, 0x5f, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x10,
    0x02, 0x12, 0x10, 0x0a, 0x0c, 0x44, 0x45, 0x4d, 0x5f, 0x53, 0x79, 0x6e, 0x63, 0x54, 0x69, 0x63,
    0x6b, 0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x45, 0x4d, 0x5f, 0x53, 0x65, 0x6e, 0x64, 0x54,
    0x61, 0x62, 0x6c, 0x65, 0x73, 0x10, 0x04, 0x12, 0x11, 0x0a, 0x0d, 0x44, 0x45, 0x4d, 0x5f, 0x43,
    0x6c, 0x61, 0x73, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x10, 0x05, 0x12, 0x14, 0x0a, 0x10, 0x44, 0x45,
    0x4d, 0x5f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x10, 0x06,
    0x12, 0x0e, 0x0a, 0x0a, 0x44, 0x45, 0x4d, 0x5f, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x10, 0x07,
    0x12, 0x14, 0x0a, 0x10, 0x44, 0x45, 0x4d, 0x5f, 0x53, 0x69, 0x67, 0x6e, 0x6f, 0x6e, 0x50, 0x61,
    0x63, 0x6b, 0x65, 0x74, 0x10, 0x08, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x45, 0x4d, 0x5f, 0x43, 0x6f,
    0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x43, 0x6d, 0x64, 0x10, 0x09, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x45,
    0x4d, 0x5f, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x10, 0x0a, 0x12, 0x1b,
    0x0a, 0x17, 0x44, 0x45, 0x4d, 0x5f, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61,
    0x43, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x73, 0x10, 0x0b, 0x12, 0x0f, 0x0a, 0x0b, 0x44,
    0x45, 0x4d, 0x5f, 0x55, 0x73, 0x65, 0x72, 0x43, 0x6d, 0x64, 0x10, 0x0c, 0x12, 0x12, 0x0a, 0x0e,
    0x44, 0x45, 0x4d, 0x5f, 0x46, 0x75, 0x6c, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x10, 0x0d,
    0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45, 0x4d, 0x5f, 0x4d, 0x61, 0x78, 0x10, 0x0e, 0x12, 0x14, 0x0a,
    0x10, 0x44, 0x45, 0x4d, 0x5f, 0x49, 0x73, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65,
    0x64, 0x10, 0x70, 0x42, 0x03, 0x80, 0x01, 0x00, 0x4a, 0xd4, 0x24, 0x0a, 0x07, 0x12, 0x05, 0x2e,
    0x00, 0xd4, 0x01, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x2e, 0x00, 0x23, 0x0a, 0x41,
    0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x2e, 0x00, 0x23, 0x1a, 0x34, 0x20, 0x57, 0x65,
    0x20, 0x64, 0x6f, 0x6e, 0x27, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x0d,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x2e, 0x07, 0x1a, 0x0a,
    0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x2e, 0x07, 0x1a, 0x0a, 0x0e,
    0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x2e, 0x07, 0x1a, 0x0a, 0x0c,
    0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x03, 0x2e, 0x1d, 0x22, 0x0a, 0x09, 0x0a, 0x02,
    0x03, 0x00, 0x12, 0x03, 0x47, 0x07, 0x29, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x00, 0x12, 0x04, 0x49,
    0x00, 0x5d, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01, 0x12, 0x03, 0x49, 0x05, 0x12, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x4b, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x4b, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x00, 0x02, 0x12, 0x03, 0x4b, 0x32, 0x34, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x01,
    0x12, 0x03, 0x4c, 0x08, 0x34, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03,
    0x4c, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x4c, 0x32,
    0x33, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12, 0x03, 0x4d, 0x08, 0x2c, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x4d, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x02, 0x02, 0x12, 0x03, 0x4d, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00,
    0x02, 0x03, 0x12, 0x03, 0x4e, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x01,
    0x12, 0x03, 0x4e, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x02, 0x12, 0x03,
    0x4e, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x04, 0x12, 0x03, 0x4f, 0x08, 0x2c,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x4f, 0x08, 0x14, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x4f, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x05, 0x12, 0x03, 0x50, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x05, 0x01, 0x12, 0x03, 0x50, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x05, 0x02,
    0x12, 0x03, 0x50, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x06, 0x12, 0x03, 0x51,
    0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03, 0x51, 0x08, 0x15,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x51, 0x2a, 0x2b, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x07, 0x12, 0x03, 0x52, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x07, 0x01, 0x12, 0x03, 0x52, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x07, 0x02, 0x12, 0x03, 0x52, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x08, 0x12,
    0x03, 0x53, 0x08, 0x34, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x01, 0x12, 0x03, 0x53,
    0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x02, 0x12, 0x03, 0x53, 0x32, 0x33,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x09, 0x12, 0x03, 0x54, 0x08, 0x2c, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x09, 0x01, 0x12, 0x03, 0x54, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x09, 0x02, 0x12, 0x03, 0x54, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02,
    0x0a, 0x12, 0x03, 0x55, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0a, 0x01, 0x12,
    0x03, 0x55, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0a, 0x02, 0x12, 0x03, 0x55,
    0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0b, 0x12, 0x03, 0x56, 0x08, 0x2d, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x03, 0x56, 0x08, 0x16, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x0b, 0x02, 0x12, 0x03, 0x56, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x00, 0x02, 0x0c, 0x12, 0x03, 0x57, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0c,
    0x01, 0x12, 0x03, 0x57, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0c, 0x02, 0x12,
    0x03, 0x57, 0x22, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0d, 0x12, 0x03, 0x58, 0x08,
    0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x03, 0x58, 0x08, 0x13, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0d, 0x02, 0x12, 0x03, 0x58, 0x32, 0x34, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x00, 0x02, 0x0e, 0x12, 0x03, 0x59, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x0e, 0x01, 0x12, 0x03, 0x59, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0e,
    0x02, 0x12, 0x03, 0x59, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0f, 0x12, 0x03,
    0x5b, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0f, 0x01, 0x12, 0x03, 0x5b, 0x08,
    0x0f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0f, 0x02, 0x12, 0x03, 0x5b, 0x32, 0x34, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x10, 0x12, 0x03, 0x5c, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x10, 0x01, 0x12, 0x03, 0x5c, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x10, 0x02, 0x12, 0x03, 0x5c, 0x2a, 0x2e, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04,
    0x5f, 0x00, 0x69, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x5f, 0x08, 0x17,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x61, 0x08, 0x2c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x61, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x61, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x61, 0x18, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x03, 0x61, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03, 0x62,
    0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x04, 0x12, 0x03, 0x62, 0x08, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x05, 0x12, 0x03, 0x62, 0x11, 0x16, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x62, 0x17, 0x27, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x62, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00,
    0x02, 0x02, 0x12, 0x03, 0x63, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x04,
    0x12, 0x03, 0x63, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x05, 0x12, 0x03,
    0x63, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x63, 0x18,
    0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x03, 0x12, 0x03, 0x63, 0x26, 0x27, 0x0a,
    0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x03, 0x12, 0x03, 0x64, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x03, 0x04, 0x12, 0x03, 0x64, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x03, 0x05, 0x12, 0x03, 0x64, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03,
    0x01, 0x12, 0x03, 0x64, 0x18, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x03, 0x12,
    0x03, 0x64, 0x26, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x04, 0x12, 0x03, 0x65, 0x08,
    0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x04, 0x12, 0x03, 0x65, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x05, 0x12, 0x03, 0x65, 0x11, 0x17, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x65, 0x18, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x04, 0x03, 0x12, 0x03, 0x65, 0x23, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02,
    0x05, 0x12, 0x03, 0x66, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x04, 0x12,
    0x03, 0x66, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x05, 0x12, 0x03, 0x66,
    0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x01, 0x12, 0x03, 0x66, 0x18, 0x26,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x03, 0x12, 0x03, 0x66, 0x29, 0x2a, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x00, 0x02, 0x06, 0x12, 0x03, 0x67, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x06, 0x04, 0x12, 0x03, 0x67, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x06, 0x05, 0x12, 0x03, 0x67, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x01,
    0x12, 0x03, 0x67, 0x17, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x03, 0x12, 0x03,
    0x67, 0x2d, 0x2e, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x07, 0x12, 0x03, 0x68, 0x08, 0x34,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x04, 0x12, 0x03, 0x68, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x05, 0x12, 0x03, 0x68, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x07, 0x01, 0x12, 0x03, 0x68, 0x16, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x07, 0x03, 0x12, 0x03, 0x68, 0x32, 0x33, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04,
    0x6b, 0x00, 0x7d, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x6b, 0x08, 0x11,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x03, 0x00, 0x12, 0x04, 0x6d, 0x08, 0x7a, 0x09, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x01, 0x03, 0x00, 0x01, 0x12, 0x03, 0x6d, 0x10, 0x1d, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x12, 0x04, 0x6f, 0x10, 0x74, 0x11, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x01, 0x12, 0x03, 0x6f, 0x18, 0x23, 0x0a, 0x0f, 0x0a, 0x08,
    0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x03, 0x71, 0x18, 0x36, 0x0a, 0x10, 0x0a,
    0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x71, 0x18, 0x20, 0x0a,
    0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x71, 0x21,
    0x27, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x71, 0x28, 0x31, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x03, 0x71, 0x34, 0x35, 0x0a, 0x0f, 0x0a, 0x08, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x03, 0x72, 0x18, 0x38, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x03, 0x72, 0x18, 0x20, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x03, 0x72, 0x21, 0x27, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01,
    0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x72, 0x28, 0x33, 0x0a, 0x10, 0x0a, 0x09,
    0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x72, 0x36, 0x37, 0x0a, 0x0f,
    0x0a, 0x08, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x12, 0x03, 0x73, 0x18, 0x39, 0x0a,
    0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x03, 0x73, 0x18,
    0x20, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x03,
    0x73, 0x21, 0x25, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x01,
    0x12, 0x03, 0x73, 0x26, 0x34, 0x0a, 0x10, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02,
    0x02, 0x03, 0x12, 0x03, 0x73, 0x37, 0x38, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x03, 0x76, 0x10, 0x2d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x03, 0x76, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x03, 0x76, 0x19, 0x1f, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x76, 0x20, 0x28, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x76, 0x2b, 0x2c, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01,
    0x12, 0x03, 0x77, 0x10, 0x2d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x04,
    0x12, 0x03, 0x77, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x05,
    0x12, 0x03, 0x77, 0x19, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x03, 0x77, 0x1f, 0x28, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x03,
    0x12, 0x03, 0x77, 0x2b, 0x2c, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x00, 0x02, 0x02, 0x12,
    0x03, 0x78, 0x10, 0x2f, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12,
    0x03, 0x78, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12,
    0x03, 0x78, 0x19, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12,
    0x03, 0x78, 0x1f, 0x2a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12,
    0x03, 0x78, 0x2d, 0x2e, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x00, 0x02, 0x03, 0x12, 0x03,
    0x79, 0x10, 0x35, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x03,
    0x79, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x03, 0x06, 0x12, 0x03,
    0x79, 0x19, 0x24, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03,
    0x79, 0x25, 0x30, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x03,
    0x79, 0x33, 0x34, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03, 0x7c, 0x08, 0x28,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x7c, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x06, 0x12, 0x03, 0x7c, 0x11, 0x1e, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x7c, 0x1f, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01,
    0x02, 0x00, 0x03, 0x12, 0x03, 0x7c, 0x26, 0x27, 0x0a, 0x0b, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x05,
    0x7f, 0x00, 0x85, 0x01, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x7f, 0x08,
    0x15, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x04, 0x81, 0x01, 0x08, 0x29, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0x81, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x05, 0x12, 0x04, 0x81, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0x81, 0x01, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0x81, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x02, 0x02, 0x01, 0x12, 0x04, 0x82, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x82, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01,
    0x05, 0x12, 0x04, 0x82, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x82, 0x01, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x82, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x02, 0x12, 0x04, 0x83,
    0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x04, 0x12, 0x04, 0x83, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x05, 0x12, 0x04, 0x83, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x01, 0x12, 0x04, 0x83, 0x01, 0x17, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x03, 0x12, 0x04, 0x83, 0x01, 0x29, 0x2a, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x03, 0x12, 0x04, 0x84, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x03, 0x04, 0x12, 0x04, 0x84, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x03, 0x06, 0x12, 0x04, 0x84, 0x01, 0x11, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x03, 0x01, 0x12, 0x04, 0x84, 0x01, 0x1b, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x03, 0x03, 0x12, 0x04, 0x84, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x03, 0x12,
    0x06, 0x87, 0x01, 0x00, 0x8c, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x04,
    0x87, 0x01, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x04, 0x89, 0x01,
    0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0x89, 0x01, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x05, 0x12, 0x04, 0x89, 0x01, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0x89, 0x01, 0x17, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0x89, 0x01, 0x25, 0x26, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x03, 0x02, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8a, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8a, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x8a, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x02,
    0x12, 0x04, 0x8b, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x8b, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x05, 0x12, 0x04,
    0x8b, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8b,
    0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8b, 0x01,
    0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x06, 0x8e, 0x01, 0x00, 0x92, 0x01, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x04, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x08, 0x17, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x04, 0x02, 0x00, 0x12, 0x04, 0x90, 0x01, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x00, 0x04, 0x12, 0x04, 0x90, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x00, 0x06, 0x12, 0x04, 0x90, 0x01, 0x11, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x90, 0x01, 0x23, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x90, 0x01, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x01, 0x12,
    0x04, 0x91, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x04, 0x12, 0x04,
    0x91, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x06, 0x12, 0x04, 0x91,
    0x01, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0x91, 0x01,
    0x1d, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0x91, 0x01, 0x26,
    0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x06, 0x94, 0x01, 0x00, 0x96, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x04, 0x94, 0x01, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x06, 0x12, 0x06, 0x98, 0x01, 0x00, 0x9b, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x06,
    0x01, 0x12, 0x04, 0x98, 0x01, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12,
    0x04, 0x9a, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x9a, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9a,
    0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9a, 0x01,
    0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9a, 0x01, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x07, 0x12, 0x06, 0x9d, 0x01, 0x00, 0xa0, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x07, 0x02, 0x00, 0x12, 0x04, 0x9f, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x9f, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x00, 0x05, 0x12, 0x04, 0x9f, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x9f, 0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x9f, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0xa2, 0x01,
    0x00, 0xac, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x04, 0xa2, 0x01, 0x08,
    0x16, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x08, 0x03, 0x00, 0x12, 0x06, 0xa4, 0x01, 0x08, 0xa9, 0x01,
    0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x03, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x10, 0x17,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xa6, 0x01, 0x10, 0x2c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa6, 0x01, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa6, 0x01,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa6,
    0x01, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xa6, 0x01, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x08, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04,
    0xa7, 0x01, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xa7, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xa7, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xa7, 0x01, 0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xa7, 0x01, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x08, 0x03, 0x00,
    0x02, 0x02, 0x12, 0x04, 0xa8, 0x01, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03, 0x00,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xa8, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x03,
    0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa8, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08,
    0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa8, 0x01, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x08, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa8, 0x01, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x08, 0x02, 0x00, 0x12, 0x04, 0xab, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xab, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x00, 0x06, 0x12, 0x04, 0xab, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xab, 0x01, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xab, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0xae, 0x01,
    0x00, 0xb2, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x04, 0xae, 0x01, 0x08,
    0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x00, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb0, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb0, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x09, 0x02, 0x01, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xb1, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xb1, 0x01, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xb1, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0xb4, 0x01, 0x00,
    0xb7, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0xb4, 0x01, 0x08, 0x20,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb6, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb6, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb6, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0b,
    0x12, 0x06, 0xb9, 0x01, 0x00, 0xca, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12,
    0x04, 0xb9, 0x01, 0x08, 0x19, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0b, 0x03, 0x00, 0x12, 0x06, 0xbb,
    0x01, 0x08, 0xbf, 0x01, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x03, 0x00, 0x01, 0x12, 0x04,
    0xbb, 0x01, 0x10, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0b, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04,
    0xbd, 0x01, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xbd, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x00, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xbd, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbd, 0x01, 0x20, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x00, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xbd, 0x01, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0b, 0x03, 0x00,
    0x02, 0x01, 0x12, 0x04, 0xbe, 0x01, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xbe, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbe, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbe, 0x01, 0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0b, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbe, 0x01, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x0b, 0x03, 0x01, 0x12, 0x06, 0xc1, 0x01, 0x08, 0xc7, 0x01, 0x09, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x03, 0x01, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x10, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x0b, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xc3, 0x01, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0b, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc3, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0b, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc3, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc3, 0x01, 0x20, 0x2a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc3, 0x01, 0x2d, 0x2e, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xc4, 0x01, 0x10, 0x2b, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc4, 0x01, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc4, 0x01, 0x19,
    0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc4, 0x01,
    0x21, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc4,
    0x01, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xc5,
    0x01, 0x10, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xc5, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x02, 0x06, 0x12,
    0x04, 0xc5, 0x01, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xc5, 0x01, 0x21, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xc5, 0x01, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0b, 0x03, 0x01, 0x02,
    0x03, 0x12, 0x04, 0xc6, 0x01, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01, 0x02,
    0x03, 0x04, 0x12, 0x04, 0xc6, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03, 0x01,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xc6, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x03,
    0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc6, 0x01, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b,
    0x03, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc6, 0x01, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0b, 0x02, 0x00, 0x12, 0x04, 0xc9, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00,
    0x06, 0x12, 0x04, 0xc9, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc9, 0x01, 0x19, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xc9, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x06, 0xcc, 0x01, 0x00,
    0xce, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0c, 0x01, 0x12, 0x04, 0xcc, 0x01, 0x08, 0x11,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06, 0xd0, 0x01, 0x00, 0xd4, 0x01, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0d, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0d, 0x02, 0x00, 0x12, 0x04, 0xd2, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xd2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xd2, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xd2, 0x01, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xd2, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04, 0xd3,
    0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd3, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd3, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd3, 0x01, 0x17, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd3, 0x01, 0x1e, 0x1f,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto };

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data)
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoFileHeader {
    demo_file_stamp: ::protobuf::SingularField<String>,
    network_protocol: Option<i32>,
    server_name: ::protobuf::SingularField<String>,
    client_name: ::protobuf::SingularField<String>,
    map_name: ::protobuf::SingularField<String>,
    game_directory: ::protobuf::SingularField<String>,
    fullpackets_version: Option<i32>,
    allow_clientside_entities: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoFileHeader {
    pub fn new() -> CDemoFileHeader {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoFileHeader {
        static mut instance: ::protobuf::lazy::Lazy<CDemoFileHeader> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoFileHeader };
        unsafe {
            instance.get(|| {
                CDemoFileHeader {
                    demo_file_stamp: ::protobuf::SingularField::none(),
                    network_protocol: None,
                    server_name: ::protobuf::SingularField::none(),
                    client_name: ::protobuf::SingularField::none(),
                    map_name: ::protobuf::SingularField::none(),
                    game_directory: ::protobuf::SingularField::none(),
                    fullpackets_version: None,
                    allow_clientside_entities: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_demo_file_stamp(&mut self) {
        self.demo_file_stamp.clear();
    }

    pub fn has_demo_file_stamp(&self) -> bool {
        self.demo_file_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_file_stamp(&mut self, v: String) {
        self.demo_file_stamp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_demo_file_stamp(&'a mut self) -> &'a mut String {
        if self.demo_file_stamp.is_none() {
            self.demo_file_stamp.set_default();
        };
        self.demo_file_stamp.as_mut().unwrap()
    }

    pub fn get_demo_file_stamp(&'a self) -> &'a str {
        match self.demo_file_stamp.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_network_protocol(&mut self) {
        self.network_protocol = None;
    }

    pub fn has_network_protocol(&self) -> bool {
        self.network_protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_protocol(&mut self, v: i32) {
        self.network_protocol = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_protocol(&'a mut self) -> &'a mut i32 {
        if self.network_protocol.is_none() {
            self.network_protocol = Some(0);
        };
        self.network_protocol.as_mut().unwrap()
    }

    pub fn get_network_protocol(&self) -> i32 {
        self.network_protocol.unwrap_or_else(|| 0)
    }

    pub fn clear_server_name(&mut self) {
        self.server_name.clear();
    }

    pub fn has_server_name(&self) -> bool {
        self.server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_name(&mut self, v: String) {
        self.server_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_name(&'a mut self) -> &'a mut String {
        if self.server_name.is_none() {
            self.server_name.set_default();
        };
        self.server_name.as_mut().unwrap()
    }

    pub fn get_server_name(&'a self) -> &'a str {
        match self.server_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_client_name(&mut self) {
        self.client_name.clear();
    }

    pub fn has_client_name(&self) -> bool {
        self.client_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_name(&mut self, v: String) {
        self.client_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_name(&'a mut self) -> &'a mut String {
        if self.client_name.is_none() {
            self.client_name.set_default();
        };
        self.client_name.as_mut().unwrap()
    }

    pub fn get_client_name(&'a self) -> &'a str {
        match self.client_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&'a mut self) -> &'a mut String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        };
        self.map_name.as_mut().unwrap()
    }

    pub fn get_map_name(&'a self) -> &'a str {
        match self.map_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_game_directory(&mut self) {
        self.game_directory.clear();
    }

    pub fn has_game_directory(&self) -> bool {
        self.game_directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_directory(&mut self, v: String) {
        self.game_directory = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_directory(&'a mut self) -> &'a mut String {
        if self.game_directory.is_none() {
            self.game_directory.set_default();
        };
        self.game_directory.as_mut().unwrap()
    }

    pub fn get_game_directory(&'a self) -> &'a str {
        match self.game_directory.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_fullpackets_version(&mut self) {
        self.fullpackets_version = None;
    }

    pub fn has_fullpackets_version(&self) -> bool {
        self.fullpackets_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullpackets_version(&mut self, v: i32) {
        self.fullpackets_version = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullpackets_version(&'a mut self) -> &'a mut i32 {
        if self.fullpackets_version.is_none() {
            self.fullpackets_version = Some(0);
        };
        self.fullpackets_version.as_mut().unwrap()
    }

    pub fn get_fullpackets_version(&self) -> i32 {
        self.fullpackets_version.unwrap_or_else(|| 0)
    }

    pub fn clear_allow_clientside_entities(&mut self) {
        self.allow_clientside_entities = None;
    }

    pub fn has_allow_clientside_entities(&self) -> bool {
        self.allow_clientside_entities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_clientside_entities(&mut self, v: bool) {
        self.allow_clientside_entities = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_clientside_entities(&'a mut self) -> &'a mut bool {
        if self.allow_clientside_entities.is_none() {
            self.allow_clientside_entities = Some(false);
        };
        self.allow_clientside_entities.as_mut().unwrap()
    }

    pub fn get_allow_clientside_entities(&self) -> bool {
        self.allow_clientside_entities.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CDemoFileHeader {
    fn new() -> CDemoFileHeader {
        CDemoFileHeader::new()
    }

    fn is_initialized(&self) -> bool {
        if self.demo_file_stamp.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.demo_file_stamp.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.network_protocol = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.server_name.set_default();
                    is.read_string_into(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.client_name.set_default();
                    is.read_string_into(tmp)
                },
                5 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.map_name.set_default();
                    is.read_string_into(tmp)
                },
                6 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.game_directory.set_default();
                    is.read_string_into(tmp)
                },
                7 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.fullpackets_version = Some(tmp);
                },
                8 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.allow_clientside_entities = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.demo_file_stamp.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.network_protocol.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.server_name.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        for value in self.client_name.iter() {
            my_size += ::protobuf::rt::string_size(4, value.as_slice());
        };
        for value in self.map_name.iter() {
            my_size += ::protobuf::rt::string_size(5, value.as_slice());
        };
        for value in self.game_directory.iter() {
            my_size += ::protobuf::rt::string_size(6, value.as_slice());
        };
        for value in self.fullpackets_version.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.allow_clientside_entities.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.demo_file_stamp.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.network_protocol {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.server_name.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        match self.client_name.as_ref() {
            Some(ref v) => {
                os.write_string(4, v.as_slice());
            },
            None => {},
        };
        match self.map_name.as_ref() {
            Some(ref v) => {
                os.write_string(5, v.as_slice());
            },
            None => {},
        };
        match self.game_directory.as_ref() {
            Some(ref v) => {
                os.write_string(6, v.as_slice());
            },
            None => {},
        };
        match self.fullpackets_version {
            Some(ref v) => {
                os.write_int32(7, *v);
            },
            None => {},
        };
        match self.allow_clientside_entities {
            Some(ref v) => {
                os.write_bool(8, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoFileHeader>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_demo_file_stamp_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_network_protocol_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_server_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_client_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_map_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_game_directory_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_fullpackets_version_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileHeader_allow_clientside_entities_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileHeader>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoFileHeader>(
                    "CDemoFileHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoFileHeader>()
    }
}

impl ::protobuf::Clear for CDemoFileHeader {
    fn clear(&mut self) {
        self.clear_demo_file_stamp();
        self.clear_network_protocol();
        self.clear_server_name();
        self.clear_client_name();
        self.clear_map_name();
        self.clear_game_directory();
        self.clear_fullpackets_version();
        self.clear_allow_clientside_entities();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoFileHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoFileHeader_demo_file_stamp_acc_type;
static CDemoFileHeader_demo_file_stamp_acc: CDemoFileHeader_demo_file_stamp_acc_type = CDemoFileHeader_demo_file_stamp_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_demo_file_stamp_acc_type {
    fn name(&self) -> &'static str {
        "demo_file_stamp"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_demo_file_stamp()
    }

    fn get_str<'a>(&self, m: &'a CDemoFileHeader) -> &'a str {
        m.get_demo_file_stamp()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileHeader_network_protocol_acc_type;
static CDemoFileHeader_network_protocol_acc: CDemoFileHeader_network_protocol_acc_type = CDemoFileHeader_network_protocol_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_network_protocol_acc_type {
    fn name(&self) -> &'static str {
        "network_protocol"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_network_protocol()
    }

    fn get_i32(&self, m: &CDemoFileHeader) -> i32 {
        m.get_network_protocol()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileHeader_server_name_acc_type;
static CDemoFileHeader_server_name_acc: CDemoFileHeader_server_name_acc_type = CDemoFileHeader_server_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_server_name_acc_type {
    fn name(&self) -> &'static str {
        "server_name"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_server_name()
    }

    fn get_str<'a>(&self, m: &'a CDemoFileHeader) -> &'a str {
        m.get_server_name()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileHeader_client_name_acc_type;
static CDemoFileHeader_client_name_acc: CDemoFileHeader_client_name_acc_type = CDemoFileHeader_client_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_client_name_acc_type {
    fn name(&self) -> &'static str {
        "client_name"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_client_name()
    }

    fn get_str<'a>(&self, m: &'a CDemoFileHeader) -> &'a str {
        m.get_client_name()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileHeader_map_name_acc_type;
static CDemoFileHeader_map_name_acc: CDemoFileHeader_map_name_acc_type = CDemoFileHeader_map_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_map_name_acc_type {
    fn name(&self) -> &'static str {
        "map_name"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_map_name()
    }

    fn get_str<'a>(&self, m: &'a CDemoFileHeader) -> &'a str {
        m.get_map_name()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileHeader_game_directory_acc_type;
static CDemoFileHeader_game_directory_acc: CDemoFileHeader_game_directory_acc_type = CDemoFileHeader_game_directory_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_game_directory_acc_type {
    fn name(&self) -> &'static str {
        "game_directory"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_game_directory()
    }

    fn get_str<'a>(&self, m: &'a CDemoFileHeader) -> &'a str {
        m.get_game_directory()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileHeader_fullpackets_version_acc_type;
static CDemoFileHeader_fullpackets_version_acc: CDemoFileHeader_fullpackets_version_acc_type = CDemoFileHeader_fullpackets_version_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_fullpackets_version_acc_type {
    fn name(&self) -> &'static str {
        "fullpackets_version"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_fullpackets_version()
    }

    fn get_i32(&self, m: &CDemoFileHeader) -> i32 {
        m.get_fullpackets_version()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileHeader_allow_clientside_entities_acc_type;
static CDemoFileHeader_allow_clientside_entities_acc: CDemoFileHeader_allow_clientside_entities_acc_type = CDemoFileHeader_allow_clientside_entities_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileHeader> for CDemoFileHeader_allow_clientside_entities_acc_type {
    fn name(&self) -> &'static str {
        "allow_clientside_entities"
    }

    fn has_field(&self, m: &CDemoFileHeader) -> bool {
        m.has_allow_clientside_entities()
    }

    fn get_bool(&self, m: &CDemoFileHeader) -> bool {
        m.get_allow_clientside_entities()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CGameInfo {
    dota: ::protobuf::SingularPtrField<CGameInfo_CDotaGameInfo>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CGameInfo {
    pub fn new() -> CGameInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CGameInfo {
        static mut instance: ::protobuf::lazy::Lazy<CGameInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CGameInfo };
        unsafe {
            instance.get(|| {
                CGameInfo {
                    dota: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_dota(&mut self) {
        self.dota.clear();
    }

    pub fn has_dota(&self) -> bool {
        self.dota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota(&mut self, v: CGameInfo_CDotaGameInfo) {
        self.dota = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dota(&'a mut self) -> &'a mut CGameInfo_CDotaGameInfo {
        if self.dota.is_none() {
            self.dota.set_default();
        };
        self.dota.as_mut().unwrap()
    }

    pub fn get_dota(&'a self) -> &'a CGameInfo_CDotaGameInfo {
        self.dota.as_ref().unwrap_or_else(|| CGameInfo_CDotaGameInfo::default_instance())
    }
}

impl ::protobuf::Message for CGameInfo {
    fn new() -> CGameInfo {
        CGameInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.dota.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.dota.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.dota.as_ref() {
            Some(ref v) => {
                os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CGameInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CGameInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_dota_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CGameInfo>(
                    "CGameInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CGameInfo>()
    }
}

impl ::protobuf::Clear for CGameInfo {
    fn clear(&mut self) {
        self.clear_dota();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CGameInfo_dota_acc_type;
static CGameInfo_dota_acc: CGameInfo_dota_acc_type = CGameInfo_dota_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo> for CGameInfo_dota_acc_type {
    fn name(&self) -> &'static str {
        "dota"
    }

    fn has_field(&self, m: &CGameInfo) -> bool {
        m.has_dota()
    }

    fn get_message<'a>(&self, m: &'a CGameInfo) -> &'a ::protobuf::Message {
        m.get_dota() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CGameInfo_CDotaGameInfo {
    match_id: Option<u32>,
    game_mode: Option<i32>,
    game_winner: Option<i32>,
    player_info: ::protobuf::RepeatedField<CGameInfo_CDotaGameInfo_CPlayerInfo>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CGameInfo_CDotaGameInfo {
    pub fn new() -> CGameInfo_CDotaGameInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CGameInfo_CDotaGameInfo {
        static mut instance: ::protobuf::lazy::Lazy<CGameInfo_CDotaGameInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CGameInfo_CDotaGameInfo };
        unsafe {
            instance.get(|| {
                CGameInfo_CDotaGameInfo {
                    match_id: None,
                    game_mode: None,
                    game_winner: None,
                    player_info: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u32) {
        self.match_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_id(&'a mut self) -> &'a mut u32 {
        if self.match_id.is_none() {
            self.match_id = Some(0);
        };
        self.match_id.as_mut().unwrap()
    }

    pub fn get_match_id(&self) -> u32 {
        self.match_id.unwrap_or_else(|| 0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: i32) {
        self.game_mode = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mode(&'a mut self) -> &'a mut i32 {
        if self.game_mode.is_none() {
            self.game_mode = Some(0);
        };
        self.game_mode.as_mut().unwrap()
    }

    pub fn get_game_mode(&self) -> i32 {
        self.game_mode.unwrap_or_else(|| 0)
    }

    pub fn clear_game_winner(&mut self) {
        self.game_winner = None;
    }

    pub fn has_game_winner(&self) -> bool {
        self.game_winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_winner(&mut self, v: i32) {
        self.game_winner = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_winner(&'a mut self) -> &'a mut i32 {
        if self.game_winner.is_none() {
            self.game_winner = Some(0);
        };
        self.game_winner.as_mut().unwrap()
    }

    pub fn get_game_winner(&self) -> i32 {
        self.game_winner.unwrap_or_else(|| 0)
    }

    pub fn clear_player_info(&mut self) {
        self.player_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_info(&mut self, v: ::protobuf::RepeatedField<CGameInfo_CDotaGameInfo_CPlayerInfo>) {
        self.player_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_info(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CGameInfo_CDotaGameInfo_CPlayerInfo> {
        &mut self.player_info
    }

    pub fn get_player_info(&'a self) -> &'a [CGameInfo_CDotaGameInfo_CPlayerInfo] {
        self.player_info.as_slice()
    }

    pub fn add_player_info(&mut self, v: CGameInfo_CDotaGameInfo_CPlayerInfo) {
        self.player_info.push(v);
    }
}

impl ::protobuf::Message for CGameInfo_CDotaGameInfo {
    fn new() -> CGameInfo_CDotaGameInfo {
        CGameInfo_CDotaGameInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_uint32();
                    self.match_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.game_mode = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.game_winner = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.player_info.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.match_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_mode.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_winner.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.player_info.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.match_id {
            Some(ref v) => {
                os.write_uint32(1, *v);
            },
            None => {},
        };
        match self.game_mode {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.game_winner {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        for v in self.player_info.iter() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CGameInfo_CDotaGameInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_CDotaGameInfo_match_id_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_CDotaGameInfo_game_mode_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_CDotaGameInfo_game_winner_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_CDotaGameInfo_player_info_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CGameInfo_CDotaGameInfo>(
                    "CGameInfo_CDotaGameInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CGameInfo_CDotaGameInfo>()
    }
}

impl ::protobuf::Clear for CGameInfo_CDotaGameInfo {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_game_mode();
        self.clear_game_winner();
        self.clear_player_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CGameInfo_CDotaGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CGameInfo_CDotaGameInfo_match_id_acc_type;
static CGameInfo_CDotaGameInfo_match_id_acc: CGameInfo_CDotaGameInfo_match_id_acc_type = CGameInfo_CDotaGameInfo_match_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo> for CGameInfo_CDotaGameInfo_match_id_acc_type {
    fn name(&self) -> &'static str {
        "match_id"
    }

    fn has_field(&self, m: &CGameInfo_CDotaGameInfo) -> bool {
        m.has_match_id()
    }

    fn get_u32(&self, m: &CGameInfo_CDotaGameInfo) -> u32 {
        m.get_match_id()
    }
}

#[allow(non_camel_case_types)]
struct CGameInfo_CDotaGameInfo_game_mode_acc_type;
static CGameInfo_CDotaGameInfo_game_mode_acc: CGameInfo_CDotaGameInfo_game_mode_acc_type = CGameInfo_CDotaGameInfo_game_mode_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo> for CGameInfo_CDotaGameInfo_game_mode_acc_type {
    fn name(&self) -> &'static str {
        "game_mode"
    }

    fn has_field(&self, m: &CGameInfo_CDotaGameInfo) -> bool {
        m.has_game_mode()
    }

    fn get_i32(&self, m: &CGameInfo_CDotaGameInfo) -> i32 {
        m.get_game_mode()
    }
}

#[allow(non_camel_case_types)]
struct CGameInfo_CDotaGameInfo_game_winner_acc_type;
static CGameInfo_CDotaGameInfo_game_winner_acc: CGameInfo_CDotaGameInfo_game_winner_acc_type = CGameInfo_CDotaGameInfo_game_winner_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo> for CGameInfo_CDotaGameInfo_game_winner_acc_type {
    fn name(&self) -> &'static str {
        "game_winner"
    }

    fn has_field(&self, m: &CGameInfo_CDotaGameInfo) -> bool {
        m.has_game_winner()
    }

    fn get_i32(&self, m: &CGameInfo_CDotaGameInfo) -> i32 {
        m.get_game_winner()
    }
}

#[allow(non_camel_case_types)]
struct CGameInfo_CDotaGameInfo_player_info_acc_type;
static CGameInfo_CDotaGameInfo_player_info_acc: CGameInfo_CDotaGameInfo_player_info_acc_type = CGameInfo_CDotaGameInfo_player_info_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo> for CGameInfo_CDotaGameInfo_player_info_acc_type {
    fn name(&self) -> &'static str {
        "player_info"
    }

    fn len_field(&self, m: &CGameInfo_CDotaGameInfo) -> uint {
        m.get_player_info().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CGameInfo_CDotaGameInfo, index: uint) -> &'a ::protobuf::Message {
        &m.get_player_info()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CGameInfo_CDotaGameInfo_CPlayerInfo {
    hero_name: ::protobuf::SingularField<String>,
    player_name: ::protobuf::SingularField<String>,
    is_fake_client: Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CGameInfo_CDotaGameInfo_CPlayerInfo {
    pub fn new() -> CGameInfo_CDotaGameInfo_CPlayerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CGameInfo_CDotaGameInfo_CPlayerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CGameInfo_CDotaGameInfo_CPlayerInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CGameInfo_CDotaGameInfo_CPlayerInfo };
        unsafe {
            instance.get(|| {
                CGameInfo_CDotaGameInfo_CPlayerInfo {
                    hero_name: ::protobuf::SingularField::none(),
                    player_name: ::protobuf::SingularField::none(),
                    is_fake_client: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_hero_name(&mut self) {
        self.hero_name.clear();
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: String) {
        self.hero_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&'a mut self) -> &'a mut String {
        if self.hero_name.is_none() {
            self.hero_name.set_default();
        };
        self.hero_name.as_mut().unwrap()
    }

    pub fn get_hero_name(&'a self) -> &'a str {
        match self.hero_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&'a mut self) -> &'a mut String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        };
        self.player_name.as_mut().unwrap()
    }

    pub fn get_player_name(&'a self) -> &'a str {
        match self.player_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_is_fake_client(&mut self) {
        self.is_fake_client = None;
    }

    pub fn has_is_fake_client(&self) -> bool {
        self.is_fake_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fake_client(&mut self, v: bool) {
        self.is_fake_client = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_fake_client(&'a mut self) -> &'a mut bool {
        if self.is_fake_client.is_none() {
            self.is_fake_client = Some(false);
        };
        self.is_fake_client.as_mut().unwrap()
    }

    pub fn get_is_fake_client(&self) -> bool {
        self.is_fake_client.unwrap_or_else(|| false)
    }
}

impl ::protobuf::Message for CGameInfo_CDotaGameInfo_CPlayerInfo {
    fn new() -> CGameInfo_CDotaGameInfo_CPlayerInfo {
        CGameInfo_CDotaGameInfo_CPlayerInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.hero_name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.player_name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_bool();
                    self.is_fake_client = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.hero_name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.player_name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        if self.is_fake_client.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.hero_name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.player_name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.is_fake_client {
            Some(ref v) => {
                os.write_bool(3, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CGameInfo_CDotaGameInfo_CPlayerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo_CPlayerInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_CDotaGameInfo_CPlayerInfo_hero_name_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo_CPlayerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_CDotaGameInfo_CPlayerInfo_player_name_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo_CPlayerInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CGameInfo_CDotaGameInfo_CPlayerInfo_is_fake_client_acc as &'static ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo_CPlayerInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CGameInfo_CDotaGameInfo_CPlayerInfo>(
                    "CGameInfo_CDotaGameInfo_CPlayerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CGameInfo_CDotaGameInfo_CPlayerInfo>()
    }
}

impl ::protobuf::Clear for CGameInfo_CDotaGameInfo_CPlayerInfo {
    fn clear(&mut self) {
        self.clear_hero_name();
        self.clear_player_name();
        self.clear_is_fake_client();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CGameInfo_CDotaGameInfo_CPlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CGameInfo_CDotaGameInfo_CPlayerInfo_hero_name_acc_type;
static CGameInfo_CDotaGameInfo_CPlayerInfo_hero_name_acc: CGameInfo_CDotaGameInfo_CPlayerInfo_hero_name_acc_type = CGameInfo_CDotaGameInfo_CPlayerInfo_hero_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo_CPlayerInfo> for CGameInfo_CDotaGameInfo_CPlayerInfo_hero_name_acc_type {
    fn name(&self) -> &'static str {
        "hero_name"
    }

    fn has_field(&self, m: &CGameInfo_CDotaGameInfo_CPlayerInfo) -> bool {
        m.has_hero_name()
    }

    fn get_str<'a>(&self, m: &'a CGameInfo_CDotaGameInfo_CPlayerInfo) -> &'a str {
        m.get_hero_name()
    }
}

#[allow(non_camel_case_types)]
struct CGameInfo_CDotaGameInfo_CPlayerInfo_player_name_acc_type;
static CGameInfo_CDotaGameInfo_CPlayerInfo_player_name_acc: CGameInfo_CDotaGameInfo_CPlayerInfo_player_name_acc_type = CGameInfo_CDotaGameInfo_CPlayerInfo_player_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo_CPlayerInfo> for CGameInfo_CDotaGameInfo_CPlayerInfo_player_name_acc_type {
    fn name(&self) -> &'static str {
        "player_name"
    }

    fn has_field(&self, m: &CGameInfo_CDotaGameInfo_CPlayerInfo) -> bool {
        m.has_player_name()
    }

    fn get_str<'a>(&self, m: &'a CGameInfo_CDotaGameInfo_CPlayerInfo) -> &'a str {
        m.get_player_name()
    }
}

#[allow(non_camel_case_types)]
struct CGameInfo_CDotaGameInfo_CPlayerInfo_is_fake_client_acc_type;
static CGameInfo_CDotaGameInfo_CPlayerInfo_is_fake_client_acc: CGameInfo_CDotaGameInfo_CPlayerInfo_is_fake_client_acc_type = CGameInfo_CDotaGameInfo_CPlayerInfo_is_fake_client_acc_type;

impl ::protobuf::reflect::FieldAccessor<CGameInfo_CDotaGameInfo_CPlayerInfo> for CGameInfo_CDotaGameInfo_CPlayerInfo_is_fake_client_acc_type {
    fn name(&self) -> &'static str {
        "is_fake_client"
    }

    fn has_field(&self, m: &CGameInfo_CDotaGameInfo_CPlayerInfo) -> bool {
        m.has_is_fake_client()
    }

    fn get_bool(&self, m: &CGameInfo_CDotaGameInfo_CPlayerInfo) -> bool {
        m.get_is_fake_client()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoFileInfo {
    playback_time: Option<f32>,
    playback_ticks: Option<i32>,
    playback_frames: Option<i32>,
    game_info: ::protobuf::SingularPtrField<CGameInfo>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoFileInfo {
    pub fn new() -> CDemoFileInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoFileInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDemoFileInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoFileInfo };
        unsafe {
            instance.get(|| {
                CDemoFileInfo {
                    playback_time: None,
                    playback_ticks: None,
                    playback_frames: None,
                    game_info: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_playback_time(&mut self) {
        self.playback_time = None;
    }

    pub fn has_playback_time(&self) -> bool {
        self.playback_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_time(&mut self, v: f32) {
        self.playback_time = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playback_time(&'a mut self) -> &'a mut f32 {
        if self.playback_time.is_none() {
            self.playback_time = Some(0.);
        };
        self.playback_time.as_mut().unwrap()
    }

    pub fn get_playback_time(&self) -> f32 {
        self.playback_time.unwrap_or_else(|| 0.)
    }

    pub fn clear_playback_ticks(&mut self) {
        self.playback_ticks = None;
    }

    pub fn has_playback_ticks(&self) -> bool {
        self.playback_ticks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_ticks(&mut self, v: i32) {
        self.playback_ticks = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playback_ticks(&'a mut self) -> &'a mut i32 {
        if self.playback_ticks.is_none() {
            self.playback_ticks = Some(0);
        };
        self.playback_ticks.as_mut().unwrap()
    }

    pub fn get_playback_ticks(&self) -> i32 {
        self.playback_ticks.unwrap_or_else(|| 0)
    }

    pub fn clear_playback_frames(&mut self) {
        self.playback_frames = None;
    }

    pub fn has_playback_frames(&self) -> bool {
        self.playback_frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_frames(&mut self, v: i32) {
        self.playback_frames = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playback_frames(&'a mut self) -> &'a mut i32 {
        if self.playback_frames.is_none() {
            self.playback_frames = Some(0);
        };
        self.playback_frames.as_mut().unwrap()
    }

    pub fn get_playback_frames(&self) -> i32 {
        self.playback_frames.unwrap_or_else(|| 0)
    }

    pub fn clear_game_info(&mut self) {
        self.game_info.clear();
    }

    pub fn has_game_info(&self) -> bool {
        self.game_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_info(&mut self, v: CGameInfo) {
        self.game_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_info(&'a mut self) -> &'a mut CGameInfo {
        if self.game_info.is_none() {
            self.game_info.set_default();
        };
        self.game_info.as_mut().unwrap()
    }

    pub fn get_game_info(&'a self) -> &'a CGameInfo {
        self.game_info.as_ref().unwrap_or_else(|| CGameInfo::default_instance())
    }
}

impl ::protobuf::Message for CDemoFileInfo {
    fn new() -> CDemoFileInfo {
        CDemoFileInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeFixed32, wire_type);
                    let tmp = is.read_float();
                    self.playback_time = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.playback_ticks = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.playback_frames = Some(tmp);
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.game_info.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if self.playback_time.is_some() {
            my_size += 5;
        };
        for value in self.playback_ticks.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.playback_frames.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_info.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.playback_time {
            Some(ref v) => {
                os.write_float(1, *v);
            },
            None => {},
        };
        match self.playback_ticks {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.playback_frames {
            Some(ref v) => {
                os.write_int32(3, *v);
            },
            None => {},
        };
        match self.game_info.as_ref() {
            Some(ref v) => {
                os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoFileInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoFileInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileInfo_playback_time_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileInfo_playback_ticks_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileInfo_playback_frames_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileInfo>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFileInfo_game_info_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFileInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoFileInfo>(
                    "CDemoFileInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoFileInfo>()
    }
}

impl ::protobuf::Clear for CDemoFileInfo {
    fn clear(&mut self) {
        self.clear_playback_time();
        self.clear_playback_ticks();
        self.clear_playback_frames();
        self.clear_game_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoFileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoFileInfo_playback_time_acc_type;
static CDemoFileInfo_playback_time_acc: CDemoFileInfo_playback_time_acc_type = CDemoFileInfo_playback_time_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileInfo> for CDemoFileInfo_playback_time_acc_type {
    fn name(&self) -> &'static str {
        "playback_time"
    }

    fn has_field(&self, m: &CDemoFileInfo) -> bool {
        m.has_playback_time()
    }

    fn get_f32(&self, m: &CDemoFileInfo) -> f32 {
        m.get_playback_time()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileInfo_playback_ticks_acc_type;
static CDemoFileInfo_playback_ticks_acc: CDemoFileInfo_playback_ticks_acc_type = CDemoFileInfo_playback_ticks_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileInfo> for CDemoFileInfo_playback_ticks_acc_type {
    fn name(&self) -> &'static str {
        "playback_ticks"
    }

    fn has_field(&self, m: &CDemoFileInfo) -> bool {
        m.has_playback_ticks()
    }

    fn get_i32(&self, m: &CDemoFileInfo) -> i32 {
        m.get_playback_ticks()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileInfo_playback_frames_acc_type;
static CDemoFileInfo_playback_frames_acc: CDemoFileInfo_playback_frames_acc_type = CDemoFileInfo_playback_frames_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileInfo> for CDemoFileInfo_playback_frames_acc_type {
    fn name(&self) -> &'static str {
        "playback_frames"
    }

    fn has_field(&self, m: &CDemoFileInfo) -> bool {
        m.has_playback_frames()
    }

    fn get_i32(&self, m: &CDemoFileInfo) -> i32 {
        m.get_playback_frames()
    }
}

#[allow(non_camel_case_types)]
struct CDemoFileInfo_game_info_acc_type;
static CDemoFileInfo_game_info_acc: CDemoFileInfo_game_info_acc_type = CDemoFileInfo_game_info_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFileInfo> for CDemoFileInfo_game_info_acc_type {
    fn name(&self) -> &'static str {
        "game_info"
    }

    fn has_field(&self, m: &CDemoFileInfo) -> bool {
        m.has_game_info()
    }

    fn get_message<'a>(&self, m: &'a CDemoFileInfo) -> &'a ::protobuf::Message {
        m.get_game_info() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoPacket {
    sequence_in: Option<i32>,
    sequence_out_ack: Option<i32>,
    data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoPacket {
    pub fn new() -> CDemoPacket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoPacket {
        static mut instance: ::protobuf::lazy::Lazy<CDemoPacket> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoPacket };
        unsafe {
            instance.get(|| {
                CDemoPacket {
                    sequence_in: None,
                    sequence_out_ack: None,
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_sequence_in(&mut self) {
        self.sequence_in = None;
    }

    pub fn has_sequence_in(&self) -> bool {
        self.sequence_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_in(&mut self, v: i32) {
        self.sequence_in = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_in(&'a mut self) -> &'a mut i32 {
        if self.sequence_in.is_none() {
            self.sequence_in = Some(0);
        };
        self.sequence_in.as_mut().unwrap()
    }

    pub fn get_sequence_in(&self) -> i32 {
        self.sequence_in.unwrap_or_else(|| 0)
    }

    pub fn clear_sequence_out_ack(&mut self) {
        self.sequence_out_ack = None;
    }

    pub fn has_sequence_out_ack(&self) -> bool {
        self.sequence_out_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_out_ack(&mut self, v: i32) {
        self.sequence_out_ack = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_out_ack(&'a mut self) -> &'a mut i32 {
        if self.sequence_out_ack.is_none() {
            self.sequence_out_ack = Some(0);
        };
        self.sequence_out_ack.as_mut().unwrap()
    }

    pub fn get_sequence_out_ack(&self) -> i32 {
        self.sequence_out_ack.unwrap_or_else(|| 0)
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CDemoPacket {
    fn new() -> CDemoPacket {
        CDemoPacket::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.sequence_in = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.sequence_out_ack = Some(tmp);
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.sequence_in.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sequence_out_ack.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.sequence_in {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.sequence_out_ack {
            Some(ref v) => {
                os.write_int32(2, *v);
            },
            None => {},
        };
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoPacket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoPacket>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoPacket_sequence_in_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoPacket>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoPacket_sequence_out_ack_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoPacket>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoPacket_data_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoPacket>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoPacket>(
                    "CDemoPacket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoPacket>()
    }
}

impl ::protobuf::Clear for CDemoPacket {
    fn clear(&mut self) {
        self.clear_sequence_in();
        self.clear_sequence_out_ack();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoPacket_sequence_in_acc_type;
static CDemoPacket_sequence_in_acc: CDemoPacket_sequence_in_acc_type = CDemoPacket_sequence_in_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoPacket> for CDemoPacket_sequence_in_acc_type {
    fn name(&self) -> &'static str {
        "sequence_in"
    }

    fn has_field(&self, m: &CDemoPacket) -> bool {
        m.has_sequence_in()
    }

    fn get_i32(&self, m: &CDemoPacket) -> i32 {
        m.get_sequence_in()
    }
}

#[allow(non_camel_case_types)]
struct CDemoPacket_sequence_out_ack_acc_type;
static CDemoPacket_sequence_out_ack_acc: CDemoPacket_sequence_out_ack_acc_type = CDemoPacket_sequence_out_ack_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoPacket> for CDemoPacket_sequence_out_ack_acc_type {
    fn name(&self) -> &'static str {
        "sequence_out_ack"
    }

    fn has_field(&self, m: &CDemoPacket) -> bool {
        m.has_sequence_out_ack()
    }

    fn get_i32(&self, m: &CDemoPacket) -> i32 {
        m.get_sequence_out_ack()
    }
}

#[allow(non_camel_case_types)]
struct CDemoPacket_data_acc_type;
static CDemoPacket_data_acc: CDemoPacket_data_acc_type = CDemoPacket_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoPacket> for CDemoPacket_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CDemoPacket) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CDemoPacket) -> &'a [u8] {
        m.get_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoFullPacket {
    string_table: ::protobuf::SingularPtrField<CDemoStringTables>,
    packet: ::protobuf::SingularPtrField<CDemoPacket>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoFullPacket {
    pub fn new() -> CDemoFullPacket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoFullPacket {
        static mut instance: ::protobuf::lazy::Lazy<CDemoFullPacket> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoFullPacket };
        unsafe {
            instance.get(|| {
                CDemoFullPacket {
                    string_table: ::protobuf::SingularPtrField::none(),
                    packet: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_string_table(&mut self) {
        self.string_table.clear();
    }

    pub fn has_string_table(&self) -> bool {
        self.string_table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_table(&mut self, v: CDemoStringTables) {
        self.string_table = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_table(&'a mut self) -> &'a mut CDemoStringTables {
        if self.string_table.is_none() {
            self.string_table.set_default();
        };
        self.string_table.as_mut().unwrap()
    }

    pub fn get_string_table(&'a self) -> &'a CDemoStringTables {
        self.string_table.as_ref().unwrap_or_else(|| CDemoStringTables::default_instance())
    }

    pub fn clear_packet(&mut self) {
        self.packet.clear();
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: CDemoPacket) {
        self.packet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet(&'a mut self) -> &'a mut CDemoPacket {
        if self.packet.is_none() {
            self.packet.set_default();
        };
        self.packet.as_mut().unwrap()
    }

    pub fn get_packet(&'a self) -> &'a CDemoPacket {
        self.packet.as_ref().unwrap_or_else(|| CDemoPacket::default_instance())
    }
}

impl ::protobuf::Message for CDemoFullPacket {
    fn new() -> CDemoFullPacket {
        CDemoFullPacket::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.string_table.set_default();
                    is.merge_message(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.packet.set_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.string_table.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.packet.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.string_table.as_ref() {
            Some(ref v) => {
                os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        match self.packet.as_ref() {
            Some(ref v) => {
                os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
                os.write_raw_varint32(sizes[*sizes_pos]);
                *sizes_pos += 1;
                v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoFullPacket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoFullPacket>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoFullPacket_string_table_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFullPacket>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoFullPacket_packet_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoFullPacket>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoFullPacket>(
                    "CDemoFullPacket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoFullPacket>()
    }
}

impl ::protobuf::Clear for CDemoFullPacket {
    fn clear(&mut self) {
        self.clear_string_table();
        self.clear_packet();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoFullPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoFullPacket_string_table_acc_type;
static CDemoFullPacket_string_table_acc: CDemoFullPacket_string_table_acc_type = CDemoFullPacket_string_table_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFullPacket> for CDemoFullPacket_string_table_acc_type {
    fn name(&self) -> &'static str {
        "string_table"
    }

    fn has_field(&self, m: &CDemoFullPacket) -> bool {
        m.has_string_table()
    }

    fn get_message<'a>(&self, m: &'a CDemoFullPacket) -> &'a ::protobuf::Message {
        m.get_string_table() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDemoFullPacket_packet_acc_type;
static CDemoFullPacket_packet_acc: CDemoFullPacket_packet_acc_type = CDemoFullPacket_packet_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoFullPacket> for CDemoFullPacket_packet_acc_type {
    fn name(&self) -> &'static str {
        "packet"
    }

    fn has_field(&self, m: &CDemoFullPacket) -> bool {
        m.has_packet()
    }

    fn get_message<'a>(&self, m: &'a CDemoFullPacket) -> &'a ::protobuf::Message {
        m.get_packet() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoSyncTick {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoSyncTick {
    pub fn new() -> CDemoSyncTick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoSyncTick {
        static mut instance: ::protobuf::lazy::Lazy<CDemoSyncTick> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoSyncTick };
        unsafe {
            instance.get(|| {
                CDemoSyncTick {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CDemoSyncTick {
    fn new() -> CDemoSyncTick {
        CDemoSyncTick::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoSyncTick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoSyncTick>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDemoSyncTick>(
                    "CDemoSyncTick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoSyncTick>()
    }
}

impl ::protobuf::Clear for CDemoSyncTick {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoSyncTick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CDemoConsoleCmd {
    cmdstring: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoConsoleCmd {
    pub fn new() -> CDemoConsoleCmd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoConsoleCmd {
        static mut instance: ::protobuf::lazy::Lazy<CDemoConsoleCmd> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoConsoleCmd };
        unsafe {
            instance.get(|| {
                CDemoConsoleCmd {
                    cmdstring: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_cmdstring(&mut self) {
        self.cmdstring.clear();
    }

    pub fn has_cmdstring(&self) -> bool {
        self.cmdstring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmdstring(&mut self, v: String) {
        self.cmdstring = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmdstring(&'a mut self) -> &'a mut String {
        if self.cmdstring.is_none() {
            self.cmdstring.set_default();
        };
        self.cmdstring.as_mut().unwrap()
    }

    pub fn get_cmdstring(&'a self) -> &'a str {
        match self.cmdstring.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CDemoConsoleCmd {
    fn new() -> CDemoConsoleCmd {
        CDemoConsoleCmd::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.cmdstring.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.cmdstring.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.cmdstring.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoConsoleCmd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoConsoleCmd>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoConsoleCmd_cmdstring_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoConsoleCmd>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoConsoleCmd>(
                    "CDemoConsoleCmd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoConsoleCmd>()
    }
}

impl ::protobuf::Clear for CDemoConsoleCmd {
    fn clear(&mut self) {
        self.clear_cmdstring();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoConsoleCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoConsoleCmd_cmdstring_acc_type;
static CDemoConsoleCmd_cmdstring_acc: CDemoConsoleCmd_cmdstring_acc_type = CDemoConsoleCmd_cmdstring_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoConsoleCmd> for CDemoConsoleCmd_cmdstring_acc_type {
    fn name(&self) -> &'static str {
        "cmdstring"
    }

    fn has_field(&self, m: &CDemoConsoleCmd) -> bool {
        m.has_cmdstring()
    }

    fn get_str<'a>(&self, m: &'a CDemoConsoleCmd) -> &'a str {
        m.get_cmdstring()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoSendTables {
    data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoSendTables {
    pub fn new() -> CDemoSendTables {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoSendTables {
        static mut instance: ::protobuf::lazy::Lazy<CDemoSendTables> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoSendTables };
        unsafe {
            instance.get(|| {
                CDemoSendTables {
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CDemoSendTables {
    fn new() -> CDemoSendTables {
        CDemoSendTables::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(1, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoSendTables>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoSendTables>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoSendTables_data_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoSendTables>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoSendTables>(
                    "CDemoSendTables",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoSendTables>()
    }
}

impl ::protobuf::Clear for CDemoSendTables {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoSendTables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoSendTables_data_acc_type;
static CDemoSendTables_data_acc: CDemoSendTables_data_acc_type = CDemoSendTables_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoSendTables> for CDemoSendTables_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CDemoSendTables) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CDemoSendTables) -> &'a [u8] {
        m.get_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoClassInfo {
    classes: ::protobuf::RepeatedField<CDemoClassInfo_class_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoClassInfo {
    pub fn new() -> CDemoClassInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoClassInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDemoClassInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoClassInfo };
        unsafe {
            instance.get(|| {
                CDemoClassInfo {
                    classes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_classes(&mut self) {
        self.classes.clear();
    }

    // Param is passed by value, moved
    pub fn set_classes(&mut self, v: ::protobuf::RepeatedField<CDemoClassInfo_class_t>) {
        self.classes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_classes(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CDemoClassInfo_class_t> {
        &mut self.classes
    }

    pub fn get_classes(&'a self) -> &'a [CDemoClassInfo_class_t] {
        self.classes.as_slice()
    }

    pub fn add_classes(&mut self, v: CDemoClassInfo_class_t) {
        self.classes.push(v);
    }
}

impl ::protobuf::Message for CDemoClassInfo {
    fn new() -> CDemoClassInfo {
        CDemoClassInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.classes.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.classes.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.classes.iter() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoClassInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoClassInfo>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoClassInfo_classes_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoClassInfo>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoClassInfo>(
                    "CDemoClassInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoClassInfo>()
    }
}

impl ::protobuf::Clear for CDemoClassInfo {
    fn clear(&mut self) {
        self.clear_classes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoClassInfo_classes_acc_type;
static CDemoClassInfo_classes_acc: CDemoClassInfo_classes_acc_type = CDemoClassInfo_classes_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoClassInfo> for CDemoClassInfo_classes_acc_type {
    fn name(&self) -> &'static str {
        "classes"
    }

    fn len_field(&self, m: &CDemoClassInfo) -> uint {
        m.get_classes().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CDemoClassInfo, index: uint) -> &'a ::protobuf::Message {
        &m.get_classes()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoClassInfo_class_t {
    class_id: Option<i32>,
    network_name: ::protobuf::SingularField<String>,
    table_name: ::protobuf::SingularField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoClassInfo_class_t {
    pub fn new() -> CDemoClassInfo_class_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoClassInfo_class_t {
        static mut instance: ::protobuf::lazy::Lazy<CDemoClassInfo_class_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoClassInfo_class_t };
        unsafe {
            instance.get(|| {
                CDemoClassInfo_class_t {
                    class_id: None,
                    network_name: ::protobuf::SingularField::none(),
                    table_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: i32) {
        self.class_id = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_id(&'a mut self) -> &'a mut i32 {
        if self.class_id.is_none() {
            self.class_id = Some(0);
        };
        self.class_id.as_mut().unwrap()
    }

    pub fn get_class_id(&self) -> i32 {
        self.class_id.unwrap_or_else(|| 0)
    }

    pub fn clear_network_name(&mut self) {
        self.network_name.clear();
    }

    pub fn has_network_name(&self) -> bool {
        self.network_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_name(&mut self, v: String) {
        self.network_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_name(&'a mut self) -> &'a mut String {
        if self.network_name.is_none() {
            self.network_name.set_default();
        };
        self.network_name.as_mut().unwrap()
    }

    pub fn get_network_name(&'a self) -> &'a str {
        match self.network_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&'a mut self) -> &'a mut String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        };
        self.table_name.as_mut().unwrap()
    }

    pub fn get_table_name(&'a self) -> &'a str {
        match self.table_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for CDemoClassInfo_class_t {
    fn new() -> CDemoClassInfo_class_t {
        CDemoClassInfo_class_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.class_id = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.network_name.set_default();
                    is.read_string_into(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.table_name.set_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.class_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.network_name.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.table_name.iter() {
            my_size += ::protobuf::rt::string_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.class_id {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.network_name.as_ref() {
            Some(ref v) => {
                os.write_string(2, v.as_slice());
            },
            None => {},
        };
        match self.table_name.as_ref() {
            Some(ref v) => {
                os.write_string(3, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoClassInfo_class_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoClassInfo_class_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoClassInfo_class_t_class_id_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoClassInfo_class_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoClassInfo_class_t_network_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoClassInfo_class_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoClassInfo_class_t_table_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoClassInfo_class_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoClassInfo_class_t>(
                    "CDemoClassInfo_class_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoClassInfo_class_t>()
    }
}

impl ::protobuf::Clear for CDemoClassInfo_class_t {
    fn clear(&mut self) {
        self.clear_class_id();
        self.clear_network_name();
        self.clear_table_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoClassInfo_class_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoClassInfo_class_t_class_id_acc_type;
static CDemoClassInfo_class_t_class_id_acc: CDemoClassInfo_class_t_class_id_acc_type = CDemoClassInfo_class_t_class_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoClassInfo_class_t> for CDemoClassInfo_class_t_class_id_acc_type {
    fn name(&self) -> &'static str {
        "class_id"
    }

    fn has_field(&self, m: &CDemoClassInfo_class_t) -> bool {
        m.has_class_id()
    }

    fn get_i32(&self, m: &CDemoClassInfo_class_t) -> i32 {
        m.get_class_id()
    }
}

#[allow(non_camel_case_types)]
struct CDemoClassInfo_class_t_network_name_acc_type;
static CDemoClassInfo_class_t_network_name_acc: CDemoClassInfo_class_t_network_name_acc_type = CDemoClassInfo_class_t_network_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoClassInfo_class_t> for CDemoClassInfo_class_t_network_name_acc_type {
    fn name(&self) -> &'static str {
        "network_name"
    }

    fn has_field(&self, m: &CDemoClassInfo_class_t) -> bool {
        m.has_network_name()
    }

    fn get_str<'a>(&self, m: &'a CDemoClassInfo_class_t) -> &'a str {
        m.get_network_name()
    }
}

#[allow(non_camel_case_types)]
struct CDemoClassInfo_class_t_table_name_acc_type;
static CDemoClassInfo_class_t_table_name_acc: CDemoClassInfo_class_t_table_name_acc_type = CDemoClassInfo_class_t_table_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoClassInfo_class_t> for CDemoClassInfo_class_t_table_name_acc_type {
    fn name(&self) -> &'static str {
        "table_name"
    }

    fn has_field(&self, m: &CDemoClassInfo_class_t) -> bool {
        m.has_table_name()
    }

    fn get_str<'a>(&self, m: &'a CDemoClassInfo_class_t) -> &'a str {
        m.get_table_name()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoCustomData {
    callback_index: Option<i32>,
    data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoCustomData {
    pub fn new() -> CDemoCustomData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoCustomData {
        static mut instance: ::protobuf::lazy::Lazy<CDemoCustomData> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoCustomData };
        unsafe {
            instance.get(|| {
                CDemoCustomData {
                    callback_index: None,
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_callback_index(&mut self) {
        self.callback_index = None;
    }

    pub fn has_callback_index(&self) -> bool {
        self.callback_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callback_index(&mut self, v: i32) {
        self.callback_index = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callback_index(&'a mut self) -> &'a mut i32 {
        if self.callback_index.is_none() {
            self.callback_index = Some(0);
        };
        self.callback_index.as_mut().unwrap()
    }

    pub fn get_callback_index(&self) -> i32 {
        self.callback_index.unwrap_or_else(|| 0)
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CDemoCustomData {
    fn new() -> CDemoCustomData {
        CDemoCustomData::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.callback_index = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.callback_index.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.callback_index {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoCustomData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoCustomData>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoCustomData_callback_index_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoCustomData>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoCustomData_data_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoCustomData>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoCustomData>(
                    "CDemoCustomData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoCustomData>()
    }
}

impl ::protobuf::Clear for CDemoCustomData {
    fn clear(&mut self) {
        self.clear_callback_index();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoCustomData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoCustomData_callback_index_acc_type;
static CDemoCustomData_callback_index_acc: CDemoCustomData_callback_index_acc_type = CDemoCustomData_callback_index_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoCustomData> for CDemoCustomData_callback_index_acc_type {
    fn name(&self) -> &'static str {
        "callback_index"
    }

    fn has_field(&self, m: &CDemoCustomData) -> bool {
        m.has_callback_index()
    }

    fn get_i32(&self, m: &CDemoCustomData) -> i32 {
        m.get_callback_index()
    }
}

#[allow(non_camel_case_types)]
struct CDemoCustomData_data_acc_type;
static CDemoCustomData_data_acc: CDemoCustomData_data_acc_type = CDemoCustomData_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoCustomData> for CDemoCustomData_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CDemoCustomData) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CDemoCustomData) -> &'a [u8] {
        m.get_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoCustomDataCallbacks {
    save_id: ::protobuf::RepeatedField<String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoCustomDataCallbacks {
    pub fn new() -> CDemoCustomDataCallbacks {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoCustomDataCallbacks {
        static mut instance: ::protobuf::lazy::Lazy<CDemoCustomDataCallbacks> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoCustomDataCallbacks };
        unsafe {
            instance.get(|| {
                CDemoCustomDataCallbacks {
                    save_id: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_save_id(&mut self) {
        self.save_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_save_id(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.save_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_save_id(&'a mut self) -> &'a mut ::protobuf::RepeatedField<String> {
        &mut self.save_id
    }

    pub fn get_save_id(&'a self) -> &'a [String] {
        self.save_id.as_slice()
    }

    pub fn add_save_id(&mut self, v: String) {
        self.save_id.push(v);
    }
}

impl ::protobuf::Message for CDemoCustomDataCallbacks {
    fn new() -> CDemoCustomDataCallbacks {
        CDemoCustomDataCallbacks::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.save_id.push_default();
                    is.read_string_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.save_id.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.save_id.iter() {
            os.write_string(1, v.as_slice());
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoCustomDataCallbacks>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoCustomDataCallbacks>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoCustomDataCallbacks_save_id_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoCustomDataCallbacks>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoCustomDataCallbacks>(
                    "CDemoCustomDataCallbacks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoCustomDataCallbacks>()
    }
}

impl ::protobuf::Clear for CDemoCustomDataCallbacks {
    fn clear(&mut self) {
        self.clear_save_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoCustomDataCallbacks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoCustomDataCallbacks_save_id_acc_type;
static CDemoCustomDataCallbacks_save_id_acc: CDemoCustomDataCallbacks_save_id_acc_type = CDemoCustomDataCallbacks_save_id_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoCustomDataCallbacks> for CDemoCustomDataCallbacks_save_id_acc_type {
    fn name(&self) -> &'static str {
        "save_id"
    }

    fn len_field(&self, m: &CDemoCustomDataCallbacks) -> uint {
        m.get_save_id().len()
    }

    fn get_rep_str<'a>(&self, m: &'a CDemoCustomDataCallbacks) -> &'a [String] {
        m.get_save_id()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoStringTables {
    tables: ::protobuf::RepeatedField<CDemoStringTables_table_t>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoStringTables {
    pub fn new() -> CDemoStringTables {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoStringTables {
        static mut instance: ::protobuf::lazy::Lazy<CDemoStringTables> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoStringTables };
        unsafe {
            instance.get(|| {
                CDemoStringTables {
                    tables: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_tables(&mut self) {
        self.tables.clear();
    }

    // Param is passed by value, moved
    pub fn set_tables(&mut self, v: ::protobuf::RepeatedField<CDemoStringTables_table_t>) {
        self.tables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tables(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CDemoStringTables_table_t> {
        &mut self.tables
    }

    pub fn get_tables(&'a self) -> &'a [CDemoStringTables_table_t] {
        self.tables.as_slice()
    }

    pub fn add_tables(&mut self, v: CDemoStringTables_table_t) {
        self.tables.push(v);
    }
}

impl ::protobuf::Message for CDemoStringTables {
    fn new() -> CDemoStringTables {
        CDemoStringTables::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.tables.push_default();
                    is.merge_message(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.tables.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        for v in self.tables.iter() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoStringTables>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoStringTables>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoStringTables_tables_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoStringTables>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoStringTables>(
                    "CDemoStringTables",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoStringTables>()
    }
}

impl ::protobuf::Clear for CDemoStringTables {
    fn clear(&mut self) {
        self.clear_tables();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoStringTables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoStringTables_tables_acc_type;
static CDemoStringTables_tables_acc: CDemoStringTables_tables_acc_type = CDemoStringTables_tables_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoStringTables> for CDemoStringTables_tables_acc_type {
    fn name(&self) -> &'static str {
        "tables"
    }

    fn len_field(&self, m: &CDemoStringTables) -> uint {
        m.get_tables().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CDemoStringTables, index: uint) -> &'a ::protobuf::Message {
        &m.get_tables()[index] as &'a ::protobuf::Message
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoStringTables_items_t {
    str: ::protobuf::SingularField<String>,
    data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoStringTables_items_t {
    pub fn new() -> CDemoStringTables_items_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoStringTables_items_t {
        static mut instance: ::protobuf::lazy::Lazy<CDemoStringTables_items_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoStringTables_items_t };
        unsafe {
            instance.get(|| {
                CDemoStringTables_items_t {
                    str: ::protobuf::SingularField::none(),
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_str(&mut self) {
        self.str.clear();
    }

    pub fn has_str(&self) -> bool {
        self.str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str(&mut self, v: String) {
        self.str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_str(&'a mut self) -> &'a mut String {
        if self.str.is_none() {
            self.str.set_default();
        };
        self.str.as_mut().unwrap()
    }

    pub fn get_str(&'a self) -> &'a str {
        match self.str.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CDemoStringTables_items_t {
    fn new() -> CDemoStringTables_items_t {
        CDemoStringTables_items_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.str.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.str.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.str.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoStringTables_items_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_items_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoStringTables_items_t_str_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_items_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoStringTables_items_t_data_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_items_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoStringTables_items_t>(
                    "CDemoStringTables_items_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoStringTables_items_t>()
    }
}

impl ::protobuf::Clear for CDemoStringTables_items_t {
    fn clear(&mut self) {
        self.clear_str();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoStringTables_items_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoStringTables_items_t_str_acc_type;
static CDemoStringTables_items_t_str_acc: CDemoStringTables_items_t_str_acc_type = CDemoStringTables_items_t_str_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoStringTables_items_t> for CDemoStringTables_items_t_str_acc_type {
    fn name(&self) -> &'static str {
        "str"
    }

    fn has_field(&self, m: &CDemoStringTables_items_t) -> bool {
        m.has_str()
    }

    fn get_str<'a>(&self, m: &'a CDemoStringTables_items_t) -> &'a str {
        m.get_str()
    }
}

#[allow(non_camel_case_types)]
struct CDemoStringTables_items_t_data_acc_type;
static CDemoStringTables_items_t_data_acc: CDemoStringTables_items_t_data_acc_type = CDemoStringTables_items_t_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoStringTables_items_t> for CDemoStringTables_items_t_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CDemoStringTables_items_t) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CDemoStringTables_items_t) -> &'a [u8] {
        m.get_data()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoStringTables_table_t {
    table_name: ::protobuf::SingularField<String>,
    items: ::protobuf::RepeatedField<CDemoStringTables_items_t>,
    items_clientside: ::protobuf::RepeatedField<CDemoStringTables_items_t>,
    table_flags: Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoStringTables_table_t {
    pub fn new() -> CDemoStringTables_table_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoStringTables_table_t {
        static mut instance: ::protobuf::lazy::Lazy<CDemoStringTables_table_t> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoStringTables_table_t };
        unsafe {
            instance.get(|| {
                CDemoStringTables_table_t {
                    table_name: ::protobuf::SingularField::none(),
                    items: ::protobuf::RepeatedField::new(),
                    items_clientside: ::protobuf::RepeatedField::new(),
                    table_flags: None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&'a mut self) -> &'a mut String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        };
        self.table_name.as_mut().unwrap()
    }

    pub fn get_table_name(&'a self) -> &'a str {
        match self.table_name.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<CDemoStringTables_items_t>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CDemoStringTables_items_t> {
        &mut self.items
    }

    pub fn get_items(&'a self) -> &'a [CDemoStringTables_items_t] {
        self.items.as_slice()
    }

    pub fn add_items(&mut self, v: CDemoStringTables_items_t) {
        self.items.push(v);
    }

    pub fn clear_items_clientside(&mut self) {
        self.items_clientside.clear();
    }

    // Param is passed by value, moved
    pub fn set_items_clientside(&mut self, v: ::protobuf::RepeatedField<CDemoStringTables_items_t>) {
        self.items_clientside = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items_clientside(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CDemoStringTables_items_t> {
        &mut self.items_clientside
    }

    pub fn get_items_clientside(&'a self) -> &'a [CDemoStringTables_items_t] {
        self.items_clientside.as_slice()
    }

    pub fn add_items_clientside(&mut self, v: CDemoStringTables_items_t) {
        self.items_clientside.push(v);
    }

    pub fn clear_table_flags(&mut self) {
        self.table_flags = None;
    }

    pub fn has_table_flags(&self) -> bool {
        self.table_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_flags(&mut self, v: i32) {
        self.table_flags = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_flags(&'a mut self) -> &'a mut i32 {
        if self.table_flags.is_none() {
            self.table_flags = Some(0);
        };
        self.table_flags.as_mut().unwrap()
    }

    pub fn get_table_flags(&self) -> i32 {
        self.table_flags.unwrap_or_else(|| 0)
    }
}

impl ::protobuf::Message for CDemoStringTables_table_t {
    fn new() -> CDemoStringTables_table_t {
        CDemoStringTables_table_t::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.table_name.set_default();
                    is.read_string_into(tmp)
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.items.push_default();
                    is.merge_message(tmp)
                },
                3 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.items_clientside.push_default();
                    is.merge_message(tmp)
                },
                4 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.table_flags = Some(tmp);
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.table_name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.items.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.items_clientside.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.table_flags.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.table_name.as_ref() {
            Some(ref v) => {
                os.write_string(1, v.as_slice());
            },
            None => {},
        };
        for v in self.items.iter() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        for v in self.items_clientside.iter() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited);
            os.write_raw_varint32(sizes[*sizes_pos]);
            *sizes_pos += 1;
            v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos);
        };
        match self.table_flags {
            Some(ref v) => {
                os.write_int32(4, *v);
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoStringTables_table_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoStringTables_table_t_table_name_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoStringTables_table_t_items_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoStringTables_table_t_items_clientside_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoStringTables_table_t_table_flags_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoStringTables_table_t>(
                    "CDemoStringTables_table_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoStringTables_table_t>()
    }
}

impl ::protobuf::Clear for CDemoStringTables_table_t {
    fn clear(&mut self) {
        self.clear_table_name();
        self.clear_items();
        self.clear_items_clientside();
        self.clear_table_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoStringTables_table_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoStringTables_table_t_table_name_acc_type;
static CDemoStringTables_table_t_table_name_acc: CDemoStringTables_table_t_table_name_acc_type = CDemoStringTables_table_t_table_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t> for CDemoStringTables_table_t_table_name_acc_type {
    fn name(&self) -> &'static str {
        "table_name"
    }

    fn has_field(&self, m: &CDemoStringTables_table_t) -> bool {
        m.has_table_name()
    }

    fn get_str<'a>(&self, m: &'a CDemoStringTables_table_t) -> &'a str {
        m.get_table_name()
    }
}

#[allow(non_camel_case_types)]
struct CDemoStringTables_table_t_items_acc_type;
static CDemoStringTables_table_t_items_acc: CDemoStringTables_table_t_items_acc_type = CDemoStringTables_table_t_items_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t> for CDemoStringTables_table_t_items_acc_type {
    fn name(&self) -> &'static str {
        "items"
    }

    fn len_field(&self, m: &CDemoStringTables_table_t) -> uint {
        m.get_items().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CDemoStringTables_table_t, index: uint) -> &'a ::protobuf::Message {
        &m.get_items()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDemoStringTables_table_t_items_clientside_acc_type;
static CDemoStringTables_table_t_items_clientside_acc: CDemoStringTables_table_t_items_clientside_acc_type = CDemoStringTables_table_t_items_clientside_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t> for CDemoStringTables_table_t_items_clientside_acc_type {
    fn name(&self) -> &'static str {
        "items_clientside"
    }

    fn len_field(&self, m: &CDemoStringTables_table_t) -> uint {
        m.get_items_clientside().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a CDemoStringTables_table_t, index: uint) -> &'a ::protobuf::Message {
        &m.get_items_clientside()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct CDemoStringTables_table_t_table_flags_acc_type;
static CDemoStringTables_table_t_table_flags_acc: CDemoStringTables_table_t_table_flags_acc_type = CDemoStringTables_table_t_table_flags_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoStringTables_table_t> for CDemoStringTables_table_t_table_flags_acc_type {
    fn name(&self) -> &'static str {
        "table_flags"
    }

    fn has_field(&self, m: &CDemoStringTables_table_t) -> bool {
        m.has_table_flags()
    }

    fn get_i32(&self, m: &CDemoStringTables_table_t) -> i32 {
        m.get_table_flags()
    }
}

#[deriving(Clone,PartialEq,Default)]
pub struct CDemoStop {
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoStop {
    pub fn new() -> CDemoStop {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoStop {
        static mut instance: ::protobuf::lazy::Lazy<CDemoStop> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoStop };
        unsafe {
            instance.get(|| {
                CDemoStop {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }
}

impl ::protobuf::Message for CDemoStop {
    fn new() -> CDemoStop {
        CDemoStop::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoStop>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoStop>> = Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDemoStop>(
                    "CDemoStop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoStop>()
    }
}

impl ::protobuf::Clear for CDemoStop {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[deriving(Clone,PartialEq,Default)]
pub struct CDemoUserCmd {
    cmd_number: Option<i32>,
    data: ::protobuf::SingularField<Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> CDemoUserCmd {
    pub fn new() -> CDemoUserCmd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDemoUserCmd {
        static mut instance: ::protobuf::lazy::Lazy<CDemoUserCmd> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const CDemoUserCmd };
        unsafe {
            instance.get(|| {
                CDemoUserCmd {
                    cmd_number: None,
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    pub fn clear_cmd_number(&mut self) {
        self.cmd_number = None;
    }

    pub fn has_cmd_number(&self) -> bool {
        self.cmd_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_number(&mut self, v: i32) {
        self.cmd_number = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd_number(&'a mut self) -> &'a mut i32 {
        if self.cmd_number.is_none() {
            self.cmd_number = Some(0);
        };
        self.cmd_number.as_mut().unwrap()
    }

    pub fn get_cmd_number(&self) -> i32 {
        self.cmd_number.unwrap_or_else(|| 0)
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&'a mut self) -> &'a mut Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    pub fn get_data(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(ref v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for CDemoUserCmd {
    fn new() -> CDemoUserCmd {
        CDemoUserCmd::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) {
        while !is.eof() {
            let (field_number, wire_type) = is.read_tag_unpack();
            match field_number {
                1 => {
                    assert_eq!(::protobuf::wire_format::WireTypeVarint, wire_type);
                    let tmp = is.read_int32();
                    self.cmd_number = Some(tmp);
                },
                2 => {
                    assert_eq!(::protobuf::wire_format::WireTypeLengthDelimited, wire_type);
                    let tmp = self.data.set_default();
                    is.read_bytes_into(tmp)
                },
                _ => {
                    let unknown = is.read_unknown(wire_type);
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.cmd_number.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        *sizes.get_mut(pos) = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variable)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) {
        use protobuf::{Message};
        match self.cmd_number {
            Some(ref v) => {
                os.write_int32(1, *v);
            },
            None => {},
        };
        match self.data.as_ref() {
            Some(ref v) => {
                os.write_bytes(2, v.as_slice());
            },
            None => {},
        };
        os.write_unknown_fields(self.get_unknown_fields());
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: Option<CDemoUserCmd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::MessageDescriptor };
        unsafe {
            descriptor.get(|| {
                let mut fields: Vec<&'static ::protobuf::reflect::FieldAccessor<CDemoUserCmd>> = Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&CDemoUserCmd_cmd_number_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoUserCmd>) });
                fields.push(unsafe { ::std::mem::transmute(&CDemoUserCmd_data_acc as &'static ::protobuf::reflect::FieldAccessor<CDemoUserCmd>) });
                ::protobuf::reflect::MessageDescriptor::new::<CDemoUserCmd>(
                    "CDemoUserCmd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<CDemoUserCmd>()
    }
}

impl ::protobuf::Clear for CDemoUserCmd {
    fn clear(&mut self) {
        self.clear_cmd_number();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Show for CDemoUserCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        use protobuf::{Message};
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct CDemoUserCmd_cmd_number_acc_type;
static CDemoUserCmd_cmd_number_acc: CDemoUserCmd_cmd_number_acc_type = CDemoUserCmd_cmd_number_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoUserCmd> for CDemoUserCmd_cmd_number_acc_type {
    fn name(&self) -> &'static str {
        "cmd_number"
    }

    fn has_field(&self, m: &CDemoUserCmd) -> bool {
        m.has_cmd_number()
    }

    fn get_i32(&self, m: &CDemoUserCmd) -> i32 {
        m.get_cmd_number()
    }
}

#[allow(non_camel_case_types)]
struct CDemoUserCmd_data_acc_type;
static CDemoUserCmd_data_acc: CDemoUserCmd_data_acc_type = CDemoUserCmd_data_acc_type;

impl ::protobuf::reflect::FieldAccessor<CDemoUserCmd> for CDemoUserCmd_data_acc_type {
    fn name(&self) -> &'static str {
        "data"
    }

    fn has_field(&self, m: &CDemoUserCmd) -> bool {
        m.has_data()
    }

    fn get_bytes<'a>(&self, m: &'a CDemoUserCmd) -> &'a [u8] {
        m.get_data()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum EDemoCommands {
    DEM_Error = -1,
    DEM_Stop = 0,
    DEM_FileHeader = 1,
    DEM_FileInfo = 2,
    DEM_SyncTick = 3,
    DEM_SendTables = 4,
    DEM_ClassInfo = 5,
    DEM_StringTables = 6,
    DEM_Packet = 7,
    DEM_SignonPacket = 8,
    DEM_ConsoleCmd = 9,
    DEM_CustomData = 10,
    DEM_CustomDataCallbacks = 11,
    DEM_UserCmd = 12,
    DEM_FullPacket = 13,
    DEM_Max = 14,
    DEM_IsCompressed = 112,
}

impl EDemoCommands {
    pub fn new(value: i32) -> EDemoCommands {
        match value {
            -1 => DEM_Error,
            0 => DEM_Stop,
            1 => DEM_FileHeader,
            2 => DEM_FileInfo,
            3 => DEM_SyncTick,
            4 => DEM_SendTables,
            5 => DEM_ClassInfo,
            6 => DEM_StringTables,
            7 => DEM_Packet,
            8 => DEM_SignonPacket,
            9 => DEM_ConsoleCmd,
            10 => DEM_CustomData,
            11 => DEM_CustomDataCallbacks,
            12 => DEM_UserCmd,
            13 => DEM_FullPacket,
            14 => DEM_Max,
            112 => DEM_IsCompressed,
            _ => fail!()
        }
    }
}

impl ::protobuf::ProtobufEnum for EDemoCommands {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<EDemoCommands>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDemoCommands", file_descriptor_proto())
            })
        }
    }
}
